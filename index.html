<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Durak Online PRO</title>
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');

        :root {
            /* Стиль "Дурак Онлайн" */
            --bg-color: #2b3e50;
            --felt-gradient: radial-gradient(circle at 50% 50%, #3a6073 0%, #16222a 100%);
            
            /* Размеры карт (Большие) */
            --card-w: 120px;
            --card-h: 175px;
            --card-radius: 8px;
            
            --accent: #ffb300;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0;
            font-family: 'Roboto', sans-serif;
            background: var(--felt-gradient);
            height: 100vh;
            overflow: hidden;
            color: white;
            display: flex;
            flex-direction: column;
        }

        /* --- СЛОЙ АНИМАЦИИ --- */
        #anim-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 9999;
        }
        .flying-card {
            position: absolute;
            width: var(--card-w); height: var(--card-h);
            background-size: 100% 100%;
            border-radius: var(--card-radius);
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            transition: all 0.6s cubic-bezier(0.25, 1, 0.5, 1);
            transform-origin: center;
        }

        /* --- ЛОББИ --- */
        #lobby {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 10000;
            display: flex; align-items: center; justify-content: center;
        }
        .panel {
            background: #fff; color: #333; padding: 40px;
            border-radius: 12px; width: 90%; max-width: 450px;
            text-align: center; box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        .panel h1 { margin-top: 0; color: #2b3e50; }
        
        .inp {
            width: 100%; padding: 15px; margin: 10px 0;
            border: 2px solid #ccc; border-radius: 6px;
            font-size: 18px; text-align: center; font-weight: bold;
        }
        .btn {
            width: 100%; padding: 15px; border: none; margin-top: 10px;
            font-size: 18px; font-weight: bold; text-transform: uppercase;
            cursor: pointer; border-radius: 6px; color: white;
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.98); }
        .btn-green { background: #27ae60; }
        .btn-blue { background: #2980b9; }

        .avatar-select { display: flex; justify-content: center; gap: 10px; margin: 20px 0; }
        .ava-opt {
            width: 50px; height: 50px; border-radius: 50%; border: 3px solid transparent;
            cursor: pointer; background-size: cover; transition: 0.2s;
        }
        .ava-opt.active { border-color: var(--accent); transform: scale(1.15); }

        /* --- ИГРОВОЕ ПОЛЕ --- */
        #game {
            display: none; flex: 1; position: relative;
        }

        /* ЧАТ (Слева, фиксированный) */
        .chat-sidebar {
            position: absolute; top: 0; left: 0; bottom: 0; width: 250px;
            background: rgba(0,0,0,0.3); backdrop-filter: blur(5px);
            display: flex; flex-direction: column; z-index: 50;
            border-right: 1px solid rgba(255,255,255,0.1);
            transition: transform 0.3s;
        }
        .chat-toggle { display: none; } /* Для мобил можно добавить кнопку */
        
        .chat-log {
            flex: 1; overflow-y: auto; padding: 10px;
            display: flex; flex-direction: column; justify-content: flex-end;
        }
        .msg {
            margin-bottom: 8px; font-size: 13px; color: #ddd;
            word-break: break-word; line-height: 1.4;
        }
        .msg b { color: var(--accent); }
        .msg img { 
            width: 20px; height: 20px; border-radius: 50%; 
            vertical-align: middle; margin-right: 5px; border: 1px solid #fff;
        }
        
        .chat-input-area { padding: 10px; border-top: 1px solid rgba(255,255,255,0.1); display: flex; }
        #chat-in { flex: 1; background: rgba(0,0,0,0.5); border: none; color: white; padding: 8px; border-radius: 4px; }
        #chat-send { background: transparent; border: none; color: var(--accent); font-size: 20px; cursor: pointer; padding: 0 10px; }

        /* ВЕРХНЯЯ ЗОНА (Соперники) */
        .top-zone {
            height: 140px; margin-left: 250px; /* Отступ под чат */
            display: flex; justify-content: center; align-items: flex-start;
            padding-top: 15px; gap: 40px;
        }
        .player-info {
            display: flex; flex-direction: column; align-items: center;
            width: 100px; position: relative;
        }
        .avatar {
            width: 64px; height: 64px; background: #333; border: 2px solid #fff;
            border-radius: 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            position: relative; z-index: 2; object-fit: cover;
        }
        /* Индикатор хода (пульсация) */
        .player-info.turn .avatar { border-color: var(--accent); box-shadow: 0 0 15px var(--accent); }
        
        .p-name { font-size: 14px; font-weight: bold; margin-top: 5px; text-shadow: 1px 1px 2px black; }
        
        /* Рука соперника (стопка) */
        .p-hand-stack {
            margin-top: -15px; z-index: 1; display: flex; justify-content: center;
        }
        .mini-card {
            width: 40px; height: 56px; background-image: url('https://deckofcardsapi.com/static/img/back.png');
            background-size: cover; border-radius: 4px; border: 1px solid #fff;
            margin-left: -30px; box-shadow: -2px 0 5px rgba(0,0,0,0.3);
        }
        .mini-card:first-child { margin-left: 0; }

        /* ЦЕНТР (Стол) */
        .table-center {
            flex: 1; margin-left: 250px; position: relative;
            display: flex; justify-content: center; align-items: center;
        }

        /* Колода (Слева) */
        .deck-wrap {
            position: absolute; left: 40px; top: 50%; transform: translateY(-50%);
            width: var(--card-w); height: var(--card-h);
        }
        .trump-card {
            position: absolute; left: 20px; top: 0; transform: rotate(90deg);
            z-index: 0; box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
        }
        .deck-top { position: absolute; top:0; left:0; z-index: 2; }
        .deck-counter {
            position: absolute; top: -30px; width: 100%; text-align: center;
            background: rgba(0,0,0,0.5); border-radius: 10px; padding: 2px; font-size: 13px;
        }

        /* Бито (Справа) */
        .bito-wrap {
            position: absolute; right: 40px; top: 50%; transform: translateY(-50%);
            width: var(--card-w); height: var(--card-h);
            border: 2px dashed rgba(255,255,255,0.2); border-radius: var(--card-radius);
            display: flex; align-items: center; justify-content: center;
        }
        .bito-text { color: rgba(255,255,255,0.2); font-weight: bold; font-size: 20px; }
        /* Карты в бито (визуально) */
        .bito-card {
            position: absolute; width: 100%; height: 100%;
            background-image: url('https://deckofcardsapi.com/static/img/back.png');
            background-size: cover; border-radius: var(--card-radius);
        }

        /* Слоты карт (По центру) */
        .field-slots {
            display: flex; gap: 15px; align-items: center; justify-content: center;
            z-index: 10;
        }
        .slot {
            width: var(--card-w); height: var(--card-h);
            position: relative;
        }
        
        /* Карты */
        .card {
            width: var(--card-w); height: var(--card-h);
            border-radius: var(--card-radius);
            background-color: #fff; background-size: 100% 100%;
            position: absolute;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            transition: transform 0.2s;
        }
        .card-att { top: 0; left: 0; z-index: 10; }
        .card-def { top: 25px; left: 20px; z-index: 20; transform: rotate(10deg); }
        .card-back { background-image: url('https://deckofcardsapi.com/static/img/back.png'); }

        /* НИЗ (Я) */
        .my-zone {
            height: 220px; margin-left: 250px;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
            padding-bottom: 20px; position: relative;
            background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
        }
        
        .my-hand {
            display: flex; justify-content: center; align-items: flex-end;
            margin-bottom: 10px; perspective: 1000px;
        }
        .my-card-wrapper {
            width: 50px; /* Сжатие */
            height: var(--card-h);
            position: relative;
            transition: width 0.3s ease;
            cursor: pointer;
        }
        .my-card-wrapper:hover { width: 90px; } /* Раскрытие при наведении */
        .my-card-wrapper:last-child { width: var(--card-w); }
        
        .my-card-wrapper .card {
            position: absolute; bottom: 0; left: 0;
            transition: bottom 0.2s, transform 0.2s;
            transform-origin: bottom center;
        }
        /* Эффект просмотра карты */
        .my-card-wrapper:hover .card { bottom: 40px; z-index: 100; transform: scale(1.1); }
        .my-card-wrapper.selected .card { bottom: 60px; box-shadow: 0 0 0 4px var(--accent); z-index: 101; }

        .my-info {
            position: absolute; bottom: 20px; left: 20px;
            display: flex; align-items: center; gap: 10px;
        }
        .my-ava { width: 60px; height: 60px; border-radius: 12px; border: 2px solid #fff; background: #333; }
        .my-info.turn .my-ava { border-color: var(--accent); box-shadow: 0 0 15px var(--accent); }

        /* КНОПКИ */
        .controls {
            position: absolute; right: 30px; bottom: 240px;
            display: flex; flex-direction: column; gap: 10px; align-items: flex-end;
        }
        .status-bubble {
            background: rgba(0,0,0,0.7); padding: 10px 20px; border-radius: 20px;
            font-size: 16px; font-weight: bold; border: 1px solid rgba(255,255,255,0.2);
        }
        .act-btn {
            border: none; padding: 15px 40px; font-size: 20px; font-weight: 900;
            text-transform: uppercase; border-radius: 8px; cursor: pointer; color: white;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); display: none;
            transition: transform 0.1s;
        }
        .act-btn:active { transform: scale(0.95); }
        .btn-take { background: linear-gradient(to bottom, #f39c12, #d35400); }
        .btn-bito { background: linear-gradient(to bottom, #e74c3c, #c0392b); }

        /* АДАПТИВ (Мобилки) */
        @media (max-width: 900px) {
            :root { --card-w: 80px; --card-h: 116px; }
            .chat-sidebar { display: none; } /* На мобилках чат скрываем ради места */
            .top-zone, .table-center, .my-zone { margin-left: 0; }
            .top-zone { height: 100px; }
            .my-zone { height: 150px; }
            .deck-wrap { left: 10px; } .bito-wrap { right: 10px; }
            .controls { bottom: 170px; right: 10px; }
            .my-card-wrapper { width: 30px; } .my-card-wrapper:hover { width: 50px; }
        }
    </style>
</head>
<body>

    <!-- СЛОЙ АНИМАЦИИ -->
    <div id="anim-layer"></div>

    <!-- ЛОББИ -->
    <div id="lobby">
        <div class="panel" id="panel-setup">
            <h1>DURAK ONLINE PRO</h1>
            
            <div class="avatar-select" id="ava-list"></div>
            <input type="text" id="my-name" class="inp" placeholder="Ваше Имя" value="Игрок">

            <div style="margin: 15px 0; font-weight: bold; font-size: 18px;">
                <label><input type="radio" name="mode" value="2" checked> 1 на 1</label>
                <span style="margin:0 10px">|</span>
                <label><input type="radio" name="mode" value="3"> 3 Игрока</label>
            </div>
            
            <div style="margin-bottom: 15px;">
                <label style="cursor:pointer; font-weight:bold;">
                    <input type="checkbox" id="chk-transfer" style="transform:scale(1.5);"> Переводной
                </label>
            </div>

            <button class="btn btn-green" onclick="Lobby.create()">СОЗДАТЬ СТОЛ</button>
            <div style="margin:10px; color:#aaa;">или</div>
            <input type="text" id="join-id" class="inp" placeholder="Вставьте ID">
            <button class="btn btn-blue" onclick="Lobby.join()">ПРИСОЕДИНИТЬСЯ</button>
        </div>

        <div class="panel" id="panel-wait" style="display:none;">
            <h2>Комната создана</h2>
            <p>Ваш ID:</p>
            <input type="text" id="host-id-disp" class="inp" style="background:#eee;" readonly onclick="this.select()">
            <p id="wait-count" style="color:#2980b9; font-weight:bold; font-size:24px;">1/2</p>
            <div style="font-size:30px; margin-top:20px;">⌛</div>
        </div>
    </div>

    <!-- ИГРА -->
    <div id="game">
        <!-- Чат -->
        <div class="chat-sidebar">
            <div class="chat-log" id="chat-log">
                <div class="msg" style="color:#aaa; text-align:center;">--- ЧАТ ---</div>
            </div>
            <div class="chat-input-area">
                <input type="text" id="chat-in" placeholder="Сообщение..." autocomplete="off">
                <button id="chat-send" onclick="Game.sendChat()">➤</button>
            </div>
        </div>

        <!-- Соперники -->
        <div class="top-zone" id="top-opponents"></div>

        <!-- Стол -->
        <div class="table-center">
            <!-- Колода -->
            <div class="deck-wrap" id="deck-area">
                <div class="deck-counter" id="deck-num">36</div>
                <div id="trump-slot"></div>
                <div id="deck-slot" class="card card-back deck-top"></div>
            </div>

            <!-- Слоты -->
            <div class="field-slots" id="table-slots"></div>

            <!-- Бито -->
            <div class="bito-wrap" id="bito-area">
                <div class="bito-text">БИТО</div>
            </div>

            <!-- Кнопки -->
            <div class="controls">
                <div class="status-bubble" id="game-status">Ожидание...</div>
                <button class="act-btn btn-bito" id="btn-bito" onclick="Game.act('BITO')">БИТО</button>
                <button class="act-btn btn-take" id="btn-take" onclick="Game.act('TAKE')">ВЗЯТЬ</button>
            </div>
        </div>

        <!-- Моя рука -->
        <div class="my-zone">
            <div class="my-info" id="my-info-box">
                <img id="my-ava-img" class="my-ava" src="">
                <div style="font-weight:bold; text-shadow:1px 1px 2px black;">ВЫ</div>
            </div>
            <div class="my-hand" id="my-hand"></div>
        </div>
    </div>

    <script>
        const SUITS = ['S','C','H','D']; 
        const RANKS = ['6','7','8','9','0','J','Q','K','A'];
        // Картинки. 0 = 10 для API
        const GET_IMG = (r,s) => `https://deckofcardsapi.com/static/img/${r}${s}.png`;
        const AVATARS = [1,2,3,4,5,6]; // RoboHash sets

        // --- ДВИЖОК ИГРЫ (Логика Хоста) ---
        class Engine {
            constructor(hName, hAva, mode, transfer) {
                this.mode = mode;
                this.transfer = transfer;
                this.players = [{id:'host', name:hName, ava:hAva, hand:[]}];
                this.deck = [];
                this.trump = null;
                this.field = [];
                this.bitoCount = 0;
                this.turn = 0; // Индекс игрока, чей ход
                this.state = 'lobby';
                this.winner = null;
            }

            addPlayer(id, name, ava) {
                if(this.players.length >= this.mode) return false;
                this.players.push({id, name, ava, hand:[]});
                return true;
            }

            start() {
                // Генерация колоды
                this.deck = [];
                SUITS.forEach(s => RANKS.forEach(r => this.deck.push({r, s})));
                this.deck.sort(() => Math.random() - 0.5);

                // Раздача
                this.players.forEach(p => p.hand = this.deck.splice(0,6));

                // Козырь
                this.trump = this.deck.pop();
                this.deck.unshift(this.trump);

                // Определение первого хода (младший козырь)
                let minVal = 100, firstP = 0;
                this.players.forEach((p,i) => {
                    p.hand.forEach(c => {
                        if(c.s === this.trump.s && RANKS.indexOf(c.r) < minVal) {
                            minVal = RANKS.indexOf(c.r); firstP = i;
                        }
                    });
                });
                this.turn = firstP;
                this.state = 'game';
            }

            next(offset=1) { return (this.turn + offset) % this.mode; }
            
            canBeat(att, def) {
                if(att.s === def.s) return RANKS.indexOf(def.r) > RANKS.indexOf(att.r);
                return def.s === this.trump.s;
            }

            // Обработка действий
            move(pidx, type, data) {
                if(this.state !== 'game') return;
                const p = this.players[pidx];

                // АТАКА (или Перевод)
                if(type === 'ATTACK') {
                    const isAttacker = (pidx === this.turn);
                    // Условие перевода: ход следующего игрока (он должен отбиваться, но кидает такую же), поле не пустое и не бито
                    const isTransfer = (this.transfer && pidx === this.next() && this.field.length > 0 && this.field.every(s => !s.def));
                    
                    if(!isAttacker && !isTransfer) return false;

                    const card = p.hand[data.i];

                    // Проверка номинала (подкидной)
                    if(this.field.length > 0) {
                        const ranks = new Set(this.field.flatMap(s => [s.att.r, s.def?.r].filter(Boolean)));
                        if(!ranks.has(card.r)) return false;
                    }

                    // Проверка лимитов карт у следующего
                    let targetIdx = this.next();
                    if(isTransfer) targetIdx = (pidx + 1) % this.mode;
                    
                    const targetP = this.players[targetIdx];
                    const slotsNeeded = this.field.filter(x=>!x.def).length + 1; // +1 текущая карта
                    
                    if(slotsNeeded > targetP.hand.length) return false;
                    if(this.field.length >= 6) return false;

                    // Ход валиден
                    p.hand.splice(data.i, 1);
                    this.field.push({ att: card, def: null, from: pidx });

                    if(isTransfer) this.turn = pidx; // Переводящий становится атакующим
                    return true;
                }

                // ЗАЩИТА
                if(type === 'DEFEND') {
                    if(pidx !== this.next()) return false;
                    const slot = this.field[data.s];
                    if(!slot || slot.def) return false;
                    
                    const card = p.hand[data.i];
                    if(this.canBeat(slot.att, card)) {
                        p.hand.splice(data.i, 1);
                        slot.def = card;
                        return true;
                    }
                }

                // БИТО
                if(type === 'BITO') {
                    if(pidx !== this.turn) return false;
                    if(this.field.length===0 || this.field.some(x=>!x.def)) return false;
                    
                    this.bitoCount += (this.field.length * 2);
                    this.field = [];
                    this.refill();
                    this.turn = this.next();
                    return true;
                }

                // ВЗЯТЬ
                if(type === 'TAKE') {
                    if(pidx !== this.next()) return false;
                    
                    // Забирает все карты со стола
                    this.field.forEach(s => {
                        p.hand.push(s.att);
                        if(s.def) p.hand.push(s.def);
                    });
                    this.field = [];
                    this.refill(true); // Атакующие добирают, взявший - нет
                    
                    // Ход переходит через одного (в режиме 2 игрока - к тому же атакующему)
                    let nextTurn = this.next(2);
                    if(this.mode === 2) nextTurn = this.next(1);
                    this.turn = nextTurn;
                    return true;
                }
            }

            refill(skipLoser = false) {
                const queue = [];
                for(let i=0; i<this.mode; i++) queue.push((this.turn + i) % this.mode);
                
                queue.forEach(idx => {
                    if(skipLoser && idx === this.next()) return;
                    const p = this.players[idx];
                    while(p.hand.length < 6 && this.deck.length > 0) {
                        p.hand.push(this.deck.pop());
                    }
                });

                // Проверка победы
                if(this.deck.length === 0) {
                    this.players.forEach(p => {
                        if(p.hand.length === 0 && !this.win) this.win = p.name;
                    });
                }
            }

            getSnapshot() {
                return {
                    d: this.deck.length,
                    tr: this.trump,
                    f: this.field,
                    bc: this.bitoCount,
                    t: this.turn,
                    ps: this.players.map(p => ({id:p.id, name:p.name, ava:p.ava, cnt:p.hand.length})),
                    win: this.win
                };
            }
        }

        // --- КЛИЕНТ (UI) ---
        const Lobby = {
            ava: 1,
            init() {
                const c = document.getElementById('ava-list');
                AVATARS.forEach(i => {
                    const d = document.createElement('div');
                    d.className = 'ava-opt' + (i===1?' active':'');
                    d.style.backgroundImage = `url('https://robohash.org/${i}.png?set=set4')`;
                    d.onclick = () => {
                        this.ava=i;
                        document.querySelectorAll('.ava-opt').forEach(x=>x.classList.remove('active'));
                        d.classList.add('active');
                    };
                    c.appendChild(d);
                });
            },
            create() {
                const n = document.getElementById('my-name').value;
                const m = parseInt(document.querySelector('input[name="mode"]:checked').value);
                const t = document.getElementById('chk-transfer').checked;
                Game.initHost(n, this.ava, m, t);
            },
            join() {
                const n = document.getElementById('my-name').value;
                const id = document.getElementById('join-id').value;
                if(!id) return alert('ID?');
                Game.initClient(n, this.ava, id);
            }
        };

        const Game = {
            role: null, eng: null, peer: null, conns: [], conn: null,
            myId: null, st: null, hand: [], sel: null,
            
            // Состояние для анимаций (чтобы знать откуда лететь)
            lastFieldLen: 0,
            lastBitoCnt: 0,
            lastHandLen: 0,

            // HOST START
            initHost(n, a, m, t) {
                this.role='host'; this.eng=new Engine(n, a, m, t);
                this.peer = new Peer();
                this.peer.on('open', id => {
                    document.getElementById('panel-setup').style.display='none';
                    document.getElementById('panel-wait').style.display='block';
                    document.getElementById('host-id-disp').value = id;
                });
                this.peer.on('connection', c => {
                    c.on('open', () => this.conns.push(c));
                    c.on('data', d => {
                        if(d.t==='J') {
                            if(this.eng.addPlayer(c.peer, d.n, d.a)) {
                                this.bc({t:'C', n:'SYS', m:`${d.n} зашел`});
                                document.getElementById('wait-count').innerText = `${this.eng.players.length}/${this.eng.mode}`;
                                if(this.eng.players.length === m) {
                                    this.eng.start();
                                    this.sync();
                                }
                            } else c.close();
                        }
                        if(d.t==='A') {
                            const idx = this.eng.players.findIndex(p=>p.id===c.peer);
                            if(idx!==-1 && this.eng.move(idx, d.a, d.d)) this.sync();
                        }
                        if(d.t==='C') this.bc(d);
                    });
                });
            },

            // CLIENT START
            initClient(n, a, id) {
                this.role='client';
                this.peer = new Peer();
                this.peer.on('open', () => {
                    this.conn = this.peer.connect(id);
                    this.conn.on('open', () => {
                        this.conn.send({t:'J', n, a});
                        document.getElementById('lobby').style.display='none';
                    });
                    this.conn.on('data', d => {
                        if(d.t==='S') {
                            document.getElementById('lobby').style.display='none';
                            document.getElementById('game').style.display='flex';
                            this.st = d.s; this.hand = d.h; this.myId = d.mid;
                            this.draw();
                        }
                        if(d.t==='C') this.addChat(d);
                    });
                });
            },

            sync() {
                if(this.role!=='host') return;
                const snap = this.eng.getSnapshot();
                this.st = snap; this.hand = this.eng.players[0].hand; this.myId = 'host';
                this.draw();
                this.conns.forEach(c => {
                    const p = this.eng.players.find(x=>x.id===c.peer);
                    if(p) c.send({t:'S', s:snap, h:p.hand, mid:c.peer});
                });
            },

            act(type, d={}) {
                if(this.role==='host') {
                    if(this.eng.move(0, type, d)) this.sync();
                } else {
                    this.conn.send({t:'A', a:type, d});
                }
            },

            // CHAT
            sendChat() {
                const i = document.getElementById('chat-in');
                const v = i.value.trim();
                if(!v) return;
                
                let myName = 'Я', myAva = 1;
                if(this.role==='host') { myName = this.eng.players[0].name; myAva = this.eng.players[0].ava; }
                
                if(this.role==='host') {
                    const msg = {t:'C', n:myName, a:myAva, m:v, id:this.myId};
                    this.addChat(msg); this.bc(msg);
                } else {
                    this.conn.send({t:'C', m:v, id:this.myId});
                }
                i.value='';
            },
            bc(d) {
                if(d.t==='C' && !d.n && this.eng) {
                    const p = this.eng.players.find(x=>x.id===d.id);
                    if(p) { d.n=p.name; d.a=p.ava; }
                }
                this.conns.forEach(c=>c.send(d));
                if(d.t==='C') this.addChat(d);
            },
            addChat(d) {
                const box = document.getElementById('chat-log');
                const el = document.createElement('div');
                let isMe = false;
                // Try to identify self
                if(this.st) {
                    const me = this.st.ps.find(p=>p.id===this.myId);
                    if(me && d.n===me.name) isMe=true;
                    if(!me && this.role==='host' && d.n===this.eng.players[0].name) isMe=true;
                }
                el.className = 'msg chat-msg' + (isMe?' me':'');
                const avaSrc = d.a ? `https://robohash.org/${d.a}.png?set=set4` : '';
                
                if(d.n==='SYS') el.innerHTML = `<i>${d.m}</i>`;
                else el.innerHTML = `<img src="${avaSrc}"> <b>${d.n}:</b> ${d.m}`;
                
                box.appendChild(el);
                box.scrollTop = box.scrollHeight;
            },

            // ANIMATION SYSTEM
            fly(fromRect, toRect, img) {
                const el = document.createElement('div');
                el.className = 'flying-card';
                el.style.backgroundImage = `url('${img}')`;
                el.style.left = fromRect.left + 'px';
                el.style.top = fromRect.top + 'px';
                document.getElementById('anim-layer').appendChild(el);
                
                // Trigger Reflow
                el.getBoundingClientRect();
                
                el.style.left = toRect.left + 'px';
                el.style.top = toRect.top + 'px';
                
                setTimeout(() => el.remove(), 600);
            },

            // MAIN RENDER
            draw() {
                const s = this.st;
                if(!s) return;
                
                // Identify Indexes
                let myIdx = s.ps.findIndex(p=>p.id===this.myId);
                if(myIdx===-1 && this.role==='host') myIdx=0;

                // 1. OPPONENTS (Top)
                const oppDiv = document.getElementById('top-opponents');
                oppDiv.innerHTML = '';
                
                for(let i=1; i<s.ps.length; i++) {
                    const idx = (myIdx + i) % s.ps.length;
                    const p = s.ps[idx];
                    const isTurn = (s.t === idx);
                    
                    const el = document.createElement('div');
                    el.className = `player-info ${isTurn?'turn':''}`;
                    el.id = `player-pos-${idx}`; // Anchor for animation
                    
                    // Render Stacked Hand
                    let handHtml = '';
                    for(let c=0; c<p.cnt; c++) {
                        handHtml += `<div class="mini-card" style="margin-left:${c===0?0:-30}px"></div>`;
                    }

                    el.innerHTML = `
                        <img src="https://robohash.org/${p.ava}.png?set=set4" class="avatar">
                        <div class="p-name">${p.name}</div>
                        <div class="p-hand-stack">${handHtml}</div>
                    `;
                    oppDiv.appendChild(el);
                }

                // 2. DECK & TRUMP
                document.getElementById('deck-num').innerText = s.d;
                const dSlot = document.getElementById('deck-slot');
                dSlot.style.display = s.d > 1 ? 'block' : 'none';
                
                const tSlot = document.getElementById('trump-slot');
                tSlot.innerHTML = '';
                if(s.tr) {
                    const tCard = document.createElement('div');
                    tCard.className = 'card trump-card';
                    tCard.style.backgroundImage = `url('${GET_IMG(s.tr.r, s.tr.s)}')`;
                    tSlot.appendChild(tCard);
                }

                // 3. BITO (Visual Stack)
                const bitoArea = document.getElementById('bito-area');
                bitoArea.innerHTML = '<div class="bito-text">БИТО</div>';
                
                // Animation Check for Bito: If count increased significantly
                if(s.bc > this.lastBitoCnt) {
                    // Trigger flying to bito from center
                    const tableRect = document.getElementById('table-slots').getBoundingClientRect();
                    const bitoRect = bitoArea.getBoundingClientRect();
                    this.fly(tableRect, bitoRect, 'https://deckofcardsapi.com/static/img/back.png');
                }
                this.lastBitoCnt = s.bc;

                if(s.bc > 0) {
                    const cnt = Math.min(Math.ceil(s.bc/2), 10);
                    for(let i=0; i<cnt; i++) {
                        const c = document.createElement('div');
                        c.className = 'bito-card';
                        c.style.transform = `rotate(${Math.random()*15-7}deg)`;
                        c.style.top = `${-i}px`;
                        bitoArea.appendChild(c);
                    }
                }

                // 4. TABLE SLOTS & ANIMATIONS
                const fieldDiv = document.getElementById('table-slots');
                fieldDiv.innerHTML = '';
                
                s.f.forEach((slot, si) => {
                    const d = document.createElement('div');
                    d.className = 'slot';
                    
                    // Attack Card
                    const c1 = document.createElement('div');
                    c1.className = 'card card-att';
                    const imgUrl = GET_IMG(slot.att.r, slot.att.s);
                    c1.style.backgroundImage = `url('${imgUrl}')`;
                    d.appendChild(c1);

                    // Animate if this is new (index > stored length)
                    if(si >= this.lastFieldLen) {
                        let fromRect;
                        if(slot.from === myIdx) {
                            fromRect = document.getElementById('my-hand').getBoundingClientRect();
                        } else {
                            const oppEl = document.getElementById(`player-pos-${slot.from}`);
                            fromRect = oppEl ? oppEl.getBoundingClientRect() : {top:0,left:0};
                        }
                        // We need coordinates of this specific slot, but it's not rendered yet in DOM fully
                        // Simple hack: Fly to center of table container
                        const destRect = fieldDiv.getBoundingClientRect(); 
                        // Adjust slightly for slot index
                        destRect.left += (si * 130); 
                        
                        this.fly(fromRect, destRect, imgUrl);
                    }

                    // Defense Card
                    if(slot.def) {
                        const c2 = document.createElement('div');
                        c2.className = 'card card-def';
                        c2.style.backgroundImage = `url('${GET_IMG(slot.def.r, slot.def.s)}')`;
                        d.appendChild(c2);
                    } else {
                        // Logic for Click to Defend
                        const nextP = (s.t + 1) % s.ps.length;
                        if(myIdx === nextP && this.sel !== null) {
                            d.style.boxShadow = "inset 0 0 20px #ffb300"; d.style.cursor="pointer";
                            d.onclick = () => { this.act('DEFEND', {i:this.sel, s:si}); this.sel=null; };
                        }
                    }
                    fieldDiv.appendChild(d);
                });
                this.lastFieldLen = s.f.length;

                // 5. MY HAND
                const myInfoBox = document.getElementById('my-info-box');
                const myHandDiv = document.getElementById('my-hand');
                myHandDiv.innerHTML = '';
                
                if(s.t === myIdx) myInfoBox.classList.add('turn');
                else myInfoBox.classList.remove('turn');
                
                const myInfo = s.ps[myIdx];
                if(myInfo) document.getElementById('my-ava-img').src = `https://robohash.org/${myInfo.ava}.png?set=set4`;

                // Draw Cards if we have them (check for undefined error fix)
                if(this.hand) {
                    // Anim check: if hand grew, fly from deck
                    if(this.hand.length > this.lastHandLen && this.lastHandLen !== 0) {
                        // Fly from deck to me
                        this.fly(document.getElementById('deck-area').getBoundingClientRect(), myHandDiv.getBoundingClientRect(), 'https://deckofcardsapi.com/static/img/back.png');
                    }
                    this.lastHandLen = this.hand.length;

                    const isMyTurn = (s.t === myIdx);
                    // Transfer possible logic
                    const isTransfer = (myIdx === (s.t+1)%s.ps.length && s.f.length>0 && s.f.every(x=>!x.def));

                    this.hand.forEach((c, i) => {
                        const w = document.createElement('div');
                        w.className = 'my-card-wrapper';
                        if(this.sel === i) w.classList.add('selected');
                        
                        const el = document.createElement('div');
                        el.className = 'card';
                        el.style.backgroundImage = `url('${GET_IMG(c.r,c.s)}')`;
                        w.appendChild(el);

                        w.onclick = () => {
                            if(isMyTurn) this.act('ATTACK', {i});
                            else if(isTransfer) this.act('ATTACK', {i});
                            else { this.sel = (this.sel===i)?null:i; this.draw(); }
                        };
                        myHandDiv.appendChild(w);
                    });
                }

                // 6. STATUS & BUTTONS
                const bB = document.getElementById('btn-bito');
                const bT = document.getElementById('btn-take');
                const st = document.getElementById('game-status');
                bB.style.display = 'none'; bT.style.display = 'none';

                if(s.t === myIdx) {
                    st.innerText = "ВАШ ХОД"; st.style.borderLeftColor = "#27ae60";
                    if(s.f.length > 0 && s.f.every(x=>x.def)) bB.style.display='block';
                } else {
                    const defIdx = (s.t + 1) % s.ps.length;
                    if(myIdx === defIdx) {
                        st.innerText = "ОТБИВАЙТЕСЬ"; st.style.borderLeftColor = "#e67e22";
                        if(s.f.some(x=>!x.def)) bT.style.display='block';
                        // Transfer hint
                        const canTrans = (s.f.length>0 && s.f.every(x=>!x.def));
                        if(canTrans) st.innerText = "ОТБЕЙ ИЛИ ПЕРЕВЕДИ";
                    } else {
                        st.innerText = `ХОДИТ: ${s.ps[s.t].name}`;
                        st.style.borderLeftColor = "#ccc";
                    }
                }
            }
        };

        // Bind Chat Key
        document.getElementById('chat-in').addEventListener('keypress', e=>{if(e.key==='Enter')Game.sendChat()});
        
        Lobby.init();
    </script>
</body>
</html>
