<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Durak Online</title>
    <!-- PeerJS для P2P соединения -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- Font Awesome для иконок -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

        :root {
            --card-w: 100px;
            --card-h: 140px;
            --bg-color: #1b262c;
            --panel-bg: rgba(15, 23, 42, 0.9);
            --accent: #3282b8;
            --accent-hover: #0f4c75;
            --gold: #c9a227;
            --danger: #b91c1c;
            --success: #15803d;
            --text-main: #e2e8f0;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; outline: none; }
        
        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at center, #263842 0%, #0f1519 100%);
            height: 100vh;
            overflow: hidden;
            color: var(--text-main);
            display: flex; flex-direction: column;
        }

        /* --- LOBBY UI --- */
        #lobby {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 9999;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(5px);
        }
        
        .panel {
            background: var(--panel-bg);
            border: 1px solid rgba(255,255,255,0.1);
            padding: 40px; width: 100%; max-width: 420px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.7);
            text-align: center;
        }

        .logo { font-size: 32px; font-weight: 800; margin-bottom: 30px; letter-spacing: 2px; text-transform: uppercase; color: var(--text-main); }
        .logo i { color: var(--accent); margin-right: 10px; }

        .form-group { margin-bottom: 20px; text-align: left; }
        .form-group label { font-size: 12px; text-transform: uppercase; color: #94a3b8; font-weight: 600; margin-bottom: 5px; display: block; }
        
        .inp {
            width: 100%; padding: 12px 15px;
            background: rgba(0,0,0,0.3);
            border: 1px solid #334155;
            color: white; font-size: 16px; font-family: inherit;
            transition: 0.2s;
        }
        .inp:focus { border-color: var(--accent); background: rgba(0,0,0,0.5); }

        .btn {
            width: 100%; padding: 14px; border: none; margin-top: 10px;
            font-size: 16px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px;
            cursor: pointer; transition: 0.2s; color: white;
            display: flex; align-items: center; justify-content: center; gap: 10px;
        }
        .btn-primary { background: var(--accent); }
        .btn-primary:hover { background: var(--accent-hover); }
        .btn-outline { background: transparent; border: 1px solid #334155; margin-top: 20px; color: #94a3b8; }
        .btn-outline:hover { border-color: var(--text-main); color: var(--text-main); }

        .avatars { display: flex; gap: 15px; justify-content: center; margin-bottom: 25px; }
        .ava-opt {
            width: 50px; height: 50px; border: 2px solid #334155; cursor: pointer;
            background-size: cover; background-color: #000;
            opacity: 0.6; transition: 0.2s;
        }
        .ava-opt:hover { opacity: 1; }
        .ava-opt.selected { border-color: var(--accent); opacity: 1; box-shadow: 0 0 15px rgba(50, 130, 184, 0.3); }

        .opts-row { display: flex; justify-content: space-between; gap: 10px; margin-bottom: 20px; }
        .radio-label {
            flex: 1; background: rgba(255,255,255,0.05); padding: 10px;
            cursor: pointer; font-size: 14px; text-align: center; border: 1px solid transparent; transition: 0.2s;
        }
        .radio-label:hover { background: rgba(255,255,255,0.1); }
        input[type="radio"]:checked + span { color: var(--accent); font-weight: bold; }
        input[type="radio"] { display: none; }
        
        .check-label { display: flex; align-items: center; gap: 10px; font-size: 14px; cursor: pointer; user-select: none; }
        .custom-check { width: 18px; height: 18px; border: 1px solid #475569; display: inline-block; position: relative; }
        input[type="checkbox"]:checked + .custom-check { background: var(--accent); border-color: var(--accent); }

        /* --- GAME UI --- */
        #game { display: none; flex-direction: column; height: 100%; position: relative; }

        /* Opponents */
        .opponents-area {
            height: 180px; display: flex; justify-content: center; padding-top: 20px; gap: 40px;
            z-index: 10;
        }
        .player-wrap {
            position: relative; width: 90px; display: flex; flex-direction: column; align-items: center;
        }
        .p-info {
            position: absolute; top: -25px; width: 120%; text-align: center;
        }
        .p-name {
            font-size: 12px; font-weight: 600; color: #cbd5e1;
            text-shadow: 0 1px 2px black; letter-spacing: 0.5px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        
        .avatar-box {
            position: relative; width: 60px; height: 60px; z-index: 20;
        }
        .avatar {
            width: 100%; height: 100%; background: #0f172a; 
            object-fit: cover; box-shadow: 0 10px 20px rgba(0,0,0,0.5);
            /* Square with slight radius, strict look */
            border-radius: 2px; 
        }
        
        /* Timer SVG overlay */
        .timer-svg {
            position: absolute; top: -4px; left: -4px; width: 68px; height: 68px;
            pointer-events: none; z-index: 25; transform: rotate(-90deg);
        }
        .timer-path {
            fill: none; stroke: var(--success); stroke-width: 3;
            stroke-dasharray: 240; stroke-dashoffset: 0; /* Full length approx */
            transition: stroke 0.3s;
        }
        
        /* Opponent Cards */
        .p-hand-fan {
            position: absolute; top: 70px; /* Lowered as requested */
            left: 50%; width: 0; height: 0; z-index: 15;
        }
        .opp-card {
            position: absolute; width: 40px; height: 56px;
            background: #334155; border: 1px solid #1e293b;
            background-image: repeating-linear-gradient(45deg, #334155 0, #334155 5px, #475569 5px, #475569 10px);
            box-shadow: -1px 2px 4px rgba(0,0,0,0.5);
            transform-origin: 50% 0%; left: -20px;
        }

        /* Chat */
        .chat-wrap {
            position: absolute; bottom: 20px; right: 20px; width: 280px;
            z-index: 100; pointer-events: none;
            display: flex; flex-direction: column; gap: 8px;
        }
        .chat-box {
            max-height: 200px; overflow-y: auto; display: flex; flex-direction: column; justify-content: flex-end;
            scrollbar-width: none; mask-image: linear-gradient(to bottom, transparent, black 20%);
        }
        .msg {
            background: rgba(15, 23, 42, 0.85); padding: 6px 10px; margin-top: 4px;
            font-size: 13px; color: #e2e8f0; border-left: 2px solid var(--accent);
            align-self: flex-end; max-width: 100%; backdrop-filter: blur(2px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .msg b { color: var(--accent); margin-right: 5px; }
        .msg.sys { border-color: var(--gold); color: #f1f5f9; font-style: italic; }
        
        .chat-input-row {
            display: flex; gap: 0; pointer-events: auto; opacity: 0.4; transition: 0.2s;
            background: rgba(0,0,0,0.8); border: 1px solid #334155;
        }
        .chat-input-row:hover, .chat-input-row:focus-within { opacity: 1; border-color: var(--accent); }
        #chat-in {
            flex: 1; background: transparent; border: none; padding: 8px 10px; color: white; font-size: 13px;
        }
        #chat-btn {
            background: transparent; border: none; color: var(--accent); cursor: pointer; padding: 0 10px;
        }

        /* Table */
        .table-area {
            flex: 1; position: relative; width: 100%;
            display: flex; justify-content: center; align-items: center;
        }
        
        /* Deck */
        .deck-area {
            position: absolute; left: 40px; top: 50%; transform: translateY(-50%);
            width: var(--card-w); height: var(--card-h);
        }
        .deck-card {
            position: absolute; width: 100%; height: 100%; border-radius: 4px;
            background: #fff; background-size: 100% 100%;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }
        .deck-back {
            background-image: url('https://deckofcardsapi.com/static/img/back.png');
            border: 1px solid #ccc;
        }
        .trump-r { transform: rotate(90deg) translateX(20px); z-index: 1; filter: brightness(0.9); }
        .deck-count {
            position: absolute; top: -30px; left: 0; width: 100%; text-align: center;
            font-weight: 800; color: rgba(255,255,255,0.3); font-size: 24px;
        }

        /* Slots */
        .slots { display: flex; gap: 20px; z-index: 5; }
        .slot { width: var(--card-w); height: var(--card-h); position: relative; }
        .slot.active { cursor: pointer; }
        .slot.active::after {
            content: ''; position: absolute; inset: -10px; border: 2px dashed rgba(255,255,255,0.2);
        }
        .card-face {
            width: 100%; height: 100%; position: absolute; border-radius: 4px;
            background-size: 100% 100%; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .c-att { transform: rotate(-2deg); z-index: 2; }
        .c-def { transform: rotate(10deg) translate(15px, 10px); z-index: 3; }

        /* Actions Overlay */
        .actions-overlay {
            position: absolute; bottom: 250px; right: 40px;
            display: flex; flex-direction: column; align-items: flex-end; gap: 15px;
            pointer-events: none; z-index: 50;
        }
        .status-pill {
            background: rgba(0,0,0,0.8); border: 1px solid rgba(255,255,255,0.2);
            padding: 8px 20px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px;
            font-size: 14px; color: #fff; box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            backdrop-filter: blur(4px);
        }
        .action-btn {
            pointer-events: auto; border: none; padding: 12px 30px;
            font-size: 16px; font-weight: 800; text-transform: uppercase;
            color: white; cursor: pointer; box-shadow: 0 5px 20px rgba(0,0,0,0.6);
            transition: transform 0.1s; display: none;
            clip-path: polygon(10% 0, 100% 0, 100% 90%, 90% 100%, 0 100%, 0 10%);
        }
        .action-btn:active { transform: scale(0.95); }
        .btn-take { background: var(--accent); }
        .btn-bito { background: var(--danger); }

        /* My Zone */
        .my-zone {
            height: 240px; position: relative; display: flex; justify-content: center;
            background: linear-gradient(to top, rgba(0,0,0,0.6), transparent);
        }
        .my-info {
            position: absolute; bottom: 20px; left: 30px; display: flex; gap: 15px; align-items: center;
        }
        .my-ava { width: 64px; height: 64px; border: 2px solid #475569; background: #0f172a; object-fit: cover; }
        
        .hand-wrapper {
            position: relative; width: 100%; max-width: 800px; height: 100%;
            display: flex; justify-content: center;
        }
        .my-card {
            position: absolute; bottom: -20px; width: var(--card-w); height: var(--card-h);
            transform-origin: 50% 200%; transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.4);
        }
        .my-card:hover {
            z-index: 100 !important;
            transform: translateX(var(--x)) translateY(-60px) rotate(0deg) scale(1.1);
        }
        .my-card.selected {
            z-index: 99 !important;
            transform: translateX(var(--x)) translateY(-80px) rotate(0deg) scale(1.1);
            box-shadow: 0 0 0 3px var(--gold), 0 10px 30px rgba(0,0,0,0.8);
        }
        
        /* Invalid Move Animation (Red flash) */
        @keyframes invalidFlash {
            0% { box-shadow: 0 0 0 0 rgba(220, 38, 38, 0); transform: translateX(var(--x)) translateY(-80px) rotate(0deg) scale(1.1); }
            20% { box-shadow: 0 0 20px 5px rgba(220, 38, 38, 0.8); transform: translateX(calc(var(--x) - 5px)) translateY(-80px) rotate(-2deg) scale(1.1); }
            40% { transform: translateX(calc(var(--x) + 5px)) translateY(-80px) rotate(2deg) scale(1.1); }
            100% { box-shadow: 0 0 0 3px var(--gold); transform: translateX(var(--x)) translateY(-80px) rotate(0deg) scale(1.1); }
        }
        .my-card.invalid { animation: invalidFlash 0.4s ease-out; }

        /* Media */
        @media (max-width: 768px) {
            :root { --card-w: 80px; --card-h: 112px; }
            .opponents-area { height: 140px; gap: 15px; }
            .actions-overlay { bottom: 180px; right: 20px; }
            .my-zone { height: 180px; }
            .chat-wrap { bottom: 60px; right: 10px; width: 200px; }
            .deck-area { left: 10px; transform: translateY(-50%) scale(0.8); }
        }
    </style>
</head>
<body>

    <!-- LOBBY -->
    <div id="lobby">
        <!-- CREATE/JOIN PANEL -->
        <div class="panel" id="panel-setup">
            <div class="logo"><i class="fas fa-layer-group"></i> Durak</div>
            
            <div class="avatars" id="ava-list"></div>
            
            <div class="form-group">
                <label>Ваш Никнейм</label>
                <input type="text" id="p-name" class="inp" placeholder="Введите имя..." maxlength="12" value="Игрок">
            </div>

            <div class="form-group">
                <label>Режим игры</label>
                <div class="opts-row">
                    <label class="radio-label">
                        <input type="radio" name="mode" value="2" checked>
                        <span><i class="fas fa-user"></i> 1x1</span>
                    </label>
                    <label class="radio-label">
                        <input type="radio" name="mode" value="3">
                        <span><i class="fas fa-users"></i> 3 Игрока</span>
                    </label>
                    <label class="radio-label">
                        <input type="radio" name="mode" value="4">
                        <span><i class="fas fa-users"></i> 4 Игрока</span>
                    </label>
                </div>
                <label class="check-label">
                    <input type="checkbox" id="chk-transfer">
                    <span class="custom-check"></span> Переводной дурак
                </label>
            </div>

            <button class="btn btn-primary" onclick="Lobby.create()">
                <i class="fas fa-plus-circle"></i> Создать стол
            </button>
            
            <div style="margin: 20px 0; border-bottom: 1px solid #334155; position: relative;">
                <span style="position: absolute; top:-10px; left:50%; transform:translateX(-50%); background:var(--panel-bg); padding:0 10px; color:#64748b; font-size:12px;">ИЛИ</span>
            </div>

            <div class="form-group" style="margin-top:20px;">
                <input type="text" id="join-id" class="inp" placeholder="Вставьте ID комнаты">
            </div>
            <button class="btn btn-outline" onclick="Lobby.join()">
                <i class="fas fa-sign-in-alt"></i> Присоединиться
            </button>
        </div>

        <!-- WAITING PANEL -->
        <div class="panel" id="panel-wait" style="display:none;">
            <div class="logo"><i class="fas fa-spinner fa-spin"></i> Ожидание</div>
            <p style="color:#94a3b8; font-size:14px;">Отправьте этот ID друзьям:</p>
            <input type="text" id="host-id" class="inp" style="text-align:center; font-family:monospace; font-size:18px; color:var(--accent);" readonly onclick="this.select()">
            <div id="wait-count" style="margin: 30px 0; font-size: 40px; font-weight: 800; color: var(--text-main);">1 / 2</div>
            <p style="color:#64748b; font-size:12px;">Игра начнется автоматически, когда все соберутся.</p>
        </div>
    </div>

    <!-- GAMEPLAY -->
    <div id="game">
        <!-- UI Layer -->
        <div class="opponents-area" id="opp-area"></div>
        
        <div class="table-area">
            <!-- Deck & Trump -->
            <div class="deck-area">
                <div class="deck-count" id="deck-num">36</div>
                <div class="deck-card trump-r" id="trump-card"></div>
                <div class="deck-card deck-back" id="deck-top"></div>
            </div>

            <!-- Slots -->
            <div class="slots" id="slots-area"></div>
        </div>

        <div class="actions-overlay">
            <div class="status-pill" id="game-status">Ожидание хода...</div>
            <button class="action-btn btn-bito" id="btn-bito" onclick="Game.act('BITO')">Бито</button>
            <button class="action-btn btn-take" id="btn-take" onclick="Game.act('TAKE')">Взять</button>
        </div>

        <div class="chat-wrap">
            <div class="chat-box" id="chat-log"></div>
            <div class="chat-input-row">
                <input type="text" id="chat-in" placeholder="Чат..." autocomplete="off" maxlength="40">
                <button id="chat-btn" onclick="Game.sendChat()"><i class="fas fa-paper-plane"></i></button>
            </div>
        </div>

        <div class="my-zone">
            <div class="my-info">
                <img id="my-ava" class="my-ava" src="">
                <div>
                    <div style="font-weight:700; font-size:14px;">ВЫ</div>
                    <div style="font-size:12px; color:#94a3b8;" id="my-name">Nick</div>
                </div>
            </div>
            <div class="hand-wrapper" id="my-hand"></div>
        </div>
    </div>

    <script>
        // --- CONSTANTS & CONFIG ---
        const SUITS = ['S','C','H','D'];
        const RANKS = ['6','7','8','9','0','J','Q','K','A'];
        const IMG = (r, s) => `https://deckofcardsapi.com/static/img/${r}${s}.png`;
        const TIMEOUT_SEC = 30; // 30 seconds turn limit

        // --- AUDIO ---
        const Snd = {
            play(type) {
                // Minimal distinct sounds
                const sounds = {
                    click: 'data:audio/wav;base64,UklGRiYAAABXQVZFZm10IBAAAAABAAARIyQBESMkAQABAAgAZGF0YQAAAAA=', // Placeholder dummy
                    card: 'https://cdn.pixabay.com/audio/2022/03/15/audio_2c416e3427.mp3', // Shuffle-like
                    alert: 'https://cdn.pixabay.com/audio/2022/03/10/audio_c8c8a73467.mp3'  // Invalid move
                };
                if(type === 'card' || type === 'alert') {
                    new Audio(sounds[type]).play().catch(()=>{});
                }
            }
        };

        // --- GAME ENGINE (Host Logic) ---
        class Engine {
            constructor(hName, hAva, mode, transfer) {
                this.mode = parseInt(mode);
                this.transfer = transfer;
                this.players = [{id:'host', name:hName, ava:hAva, hand:[]}];
                this.deck = [];
                this.trump = null;
                this.field = [];
                this.turn = 0;
                this.state = 'lobby';
                this.turnStart = 0;
                this.win = null;
                this.la = null; // Last action
            }

            // --- Core Logic ---
            initDeck() {
                this.deck = [];
                SUITS.forEach(s => RANKS.forEach(r => this.deck.push({r, s})));
                this.deck.sort(() => Math.random() - 0.5);
                this.players.forEach(p => p.hand = this.deck.splice(0, 6));
                this.trump = this.deck.pop();
                this.deck.unshift(this.trump);
                
                // Determine first player (smallest trump)
                let min = 100, first = 0;
                this.players.forEach((p, i) => {
                    p.hand.forEach(c => {
                        if (c.s === this.trump.s) {
                            const val = RANKS.indexOf(c.r);
                            if (val < min) { min = val; first = i; }
                        }
                    });
                });
                this.setTurn(first);
            }

            setTurn(idx) {
                this.turn = idx;
                this.turnStart = Date.now();
            }

            nextP(offset = 1) { return (this.turn + offset) % this.players.length; }

            // --- Bot / Autoplay Logic ---
            checkTimeout() {
                if (this.state !== 'game' || this.win) return false;
                if (Date.now() - this.turnStart > TIMEOUT_SEC * 1000) {
                    this.autoPlay();
                    return true;
                }
                return false;
            }

            autoPlay() {
                const pIdx = this.players[this.turn].hand.length > 0 ? this.turn : this.nextP(); // Active player
                const isDef = (this.turn !== pIdx); // Wait, logic: turn is attacker. next is defender.
                
                // Logic breakdown:
                // If table empty: Attacker (turn) must throw.
                // If table not empty: Attacker can throw or BITO. Defender must beat or TAKE.
                
                // Current "Turn" variable usually points to Attacker.
                const attacker = this.turn;
                const defender = this.nextP();
                
                // Are we waiting for Attacker or Defender?
                // In my simplified engine, I assume 'turn' handles attacks.
                // But if field has cards and one is undefended, we are waiting for Defender.
                
                const needsDef = this.field.some(s => !s.def);
                
                if (needsDef) {
                    // Timeout on Defender -> TAKE
                    this.move(defender, 'TAKE');
                } else {
                    // Timeout on Attacker
                    if (this.field.length === 0) {
                        // Must start round. Pick random.
                        this.move(attacker, 'ATTACK', { i: 0 }); // Just picking first card
                    } else {
                        // Can add more or Bito. Just Bito to speed up.
                        // Or try to add random matching card.
                        const p = this.players[attacker];
                        let thrown = false;
                        for(let i=0; i<p.hand.length; i++) {
                            const res = this.move(attacker, 'ATTACK', {i});
                            if(res.success) { thrown = true; break; }
                        }
                        if(!thrown) this.move(attacker, 'BITO');
                    }
                }
            }

            // --- Moves ---
            beat(att, def) {
                if (att.s === def.s) return RANKS.indexOf(def.r) > RANKS.indexOf(att.r);
                return def.s === this.trump.s;
            }

            move(pIdx, type, data = {}) {
                if (this.state !== 'game') return { success: false };
                const p = this.players[pIdx];
                const defIdx = this.nextP();

                if (type === 'ATTACK') {
                    // Can only attack if it's your turn OR you are adding cards (in multi, simplifed to turn player)
                    if (pIdx !== this.turn && !(this.transfer && pIdx === defIdx)) return { success: false };
                    
                    const card = p.hand[data.i];
                    
                    // Transfer logic?
                    const isTransfer = (this.transfer && pIdx === defIdx && this.field.length > 0 && this.field.every(s => !s.def));
                    if (pIdx !== this.turn && !isTransfer) return { success: false };

                    // Card validation
                    if (this.field.length > 0) {
                        const allRanks = new Set(this.field.flatMap(s => [s.att.r, s.def?.r].filter(Boolean)));
                        if (!allRanks.has(card.r)) return { success: false, error: 'card_mismatch' };
                    }
                    
                    if (this.field.length >= 6) return { success: false, error: 'table_full' };
                    
                    // Check defender card count
                    const targetP = this.players[isTransfer ? this.nextP(2) : defIdx]; // roughly
                    // Actually simpler: Total cards on table + 1 vs Defender Hand
                    const dP = this.players[isTransfer ? (pIdx + 1)%this.players.length : defIdx];
                    if (this.field.filter(x=>!x.def).length + 1 > dP.hand.length) return { success: false, error: 'too_many' };

                    // Execute
                    p.hand.splice(data.i, 1);
                    this.field.push({ att: card, def: null });
                    
                    if (isTransfer) {
                        this.setTurn(pIdx); // Transferer becomes attacker
                        this.la = { t: 'TRANSFER', p: pIdx };
                    } else {
                        this.turnStart = Date.now(); // Reset timer for action
                        this.la = { t: 'ATTACK', p: pIdx };
                    }
                    return { success: true };
                }

                if (type === 'DEFEND') {
                    if (pIdx !== defIdx) return { success: false };
                    const slot = this.field[data.s];
                    if (!slot || slot.def) return { success: false };
                    
                    const card = p.hand[data.i];
                    if (!this.beat(slot.att, card)) return { success: false, error: 'weak_card' };

                    p.hand.splice(data.i, 1);
                    slot.def = card;
                    this.turnStart = Date.now(); // Reset timer
                    this.la = { t: 'DEFEND', p: pIdx };
                    return { success: true };
                }

                if (type === 'BITO') {
                    if (pIdx !== this.turn) return { success: false };
                    if (this.field.some(x => !x.def)) return { success: false }; // Can't bito if not all defended
                    
                    this.field = [];
                    this.refillHands();
                    this.setTurn(defIdx); // Defender becomes attacker
                    this.la = { t: 'BITO', p: pIdx };
                    return { success: true };
                }

                if (type === 'TAKE') {
                    if (pIdx !== defIdx) return { success: false };
                    
                    // Take all cards
                    this.field.forEach(s => {
                        p.hand.push(s.att);
                        if (s.def) p.hand.push(s.def);
                    });
                    this.field = [];
                    this.refillHands(true); // Skip defender refill logic effectively
                    
                    // Attacker skips turn, next player attacks the one after defender
                    // In 2 player: Attacker attacks Defender again? No, Defender took, so Attacker goes again.
                    // Logic: Turn passes to next person after Defender.
                    let next = (defIdx + 1) % this.players.length;
                    this.setTurn(next);
                    
                    this.la = { t: 'TAKE', p: pIdx };
                    return { success: true };
                }
            }

            refillHands() {
                const order = [];
                for(let i=0; i<this.players.length; i++) order.push((this.turn + i) % this.players.length);
                
                order.forEach(i => {
                    const p = this.players[i];
                    while (p.hand.length < 6 && this.deck.length > 0) p.hand.push(this.deck.pop());
                });

                // Win check
                const winners = this.players.filter(p => p.hand.length === 0 && this.deck.length === 0);
                if (winners.length > 0) this.win = winners[0].name;
            }

            getState() {
                return {
                    d_cnt: this.deck.length,
                    tr: this.trump,
                    f: this.field,
                    t: this.turn,
                    ts: this.turnStart,
                    ps: this.players.map(p => ({ name: p.name, ava: p.ava, cnt: p.hand.length, id: p.id })),
                    win: this.win,
                    la: this.la
                };
            }
        }

        // --- CLIENT / UI LOGIC ---
        const Lobby = {
            ava: 1,
            init() {
                const list = document.getElementById('ava-list');
                [1,2,3,4,5].forEach(i => {
                    const d = document.createElement('div');
                    d.className = 'ava-opt' + (i===1 ? ' selected':'');
                    d.style.backgroundImage = `url('https://robohash.org/${i}.png?set=set3')`;
                    d.onclick = () => {
                        document.querySelectorAll('.ava-opt').forEach(x => x.classList.remove('selected'));
                        d.classList.add('selected');
                        this.ava = i;
                        Snd.play('click');
                    };
                    list.appendChild(d);
                });
            },
            create() {
                const name = document.getElementById('p-name').value || 'Host';
                const mode = document.querySelector('input[name="mode"]:checked').value;
                const transfer = document.getElementById('chk-transfer').checked;
                Game.startHost(name, this.ava, mode, transfer);
            },
            join() {
                const name = document.getElementById('p-name').value || 'Guest';
                const id = document.getElementById('join-id').value;
                if(!id) return alert('Введите ID');
                Game.startClient(name, this.ava, id);
            }
        };

        const Game = {
            role: null, engine: null, peer: null, conn: null, conns: [],
            myId: null, state: null, hand: [], sel: null,
            
            startHost(name, ava, mode, transfer) {
                this.role = 'host';
                this.engine = new Engine(name, ava, mode, transfer);
                this.peer = new Peer();
                this.peer.on('open', id => {
                    document.getElementById('panel-setup').style.display = 'none';
                    document.getElementById('panel-wait').style.display = 'block';
                    document.getElementById('host-id').value = id;
                });
                this.peer.on('connection', c => {
                    c.on('open', () => {
                        this.conns.push(c);
                        c.send({t:'CHAT', n:'System', m:'Connected'});
                    });
                    c.on('data', d => this.handleHostData(c, d));
                });
                
                // Game Loop for Timer
                setInterval(() => {
                    if(this.engine.checkTimeout()) {
                        this.sync();
                    }
                }, 1000);
            },

            handleHostData(conn, data) {
                if(data.t === 'JOIN') {
                    if(this.engine.players.length < this.engine.mode) {
                        this.engine.players.push({id: conn.peer, name: data.n, ava: data.a, hand: []});
                        this.broadcast({t:'CHAT', n:'System', m:`${data.n} joined`});
                        document.getElementById('wait-count').innerText = `${this.engine.players.length} / ${this.engine.mode}`;
                        
                        if(this.engine.players.length == this.engine.mode) {
                            this.engine.initDeck();
                            this.engine.state = 'game';
                            this.sync();
                        }
                    }
                }
                if(data.t === 'ACT') {
                    // Find player index
                    const idx = this.engine.players.findIndex(p => p.id === conn.peer);
                    if(idx > -1) {
                        const res = this.engine.move(idx, data.a, data.d);
                        if(res.success) this.sync();
                        else conn.send({t:'ERR', err: res.error, i: data.d?.i});
                    }
                }
                if(data.t === 'CHAT') this.broadcast(data);
            },

            startClient(name, ava, hostId) {
                this.role = 'client';
                this.peer = new Peer();
                this.peer.on('open', id => {
                    this.conn = this.peer.connect(hostId);
                    this.conn.on('open', () => {
                        this.conn.send({t:'JOIN', n: name, a: ava});
                        document.getElementById('lobby').style.display = 'none';
                        document.getElementById('game').style.display = 'flex';
                        this.addChat({n:'System', m:'Подключение...'});
                    });
                    this.conn.on('data', d => this.handleClientData(d));
                });
            },

            handleClientData(d) {
                if(d.t === 'SYNC') {
                    this.state = d.s;
                    this.hand = d.h;
                    this.myId = this.peer.id;
                    this.render();
                    // Audio cues based on last action
                    if(d.s.la && d.s.la.t) Snd.play('card');
                }
                if(d.t === 'CHAT') this.addChat(d);
                if(d.t === 'ERR') this.animInvalid(d.i);
            },

            broadcast(msg) {
                this.conns.forEach(c => c.send(msg));
                if(msg.t === 'CHAT') this.addChat(msg);
            },

            sync() {
                const s = this.engine.getState();
                // Send to Host (Self)
                this.state = s;
                this.hand = this.engine.players[0].hand;
                this.myId = 'host';
                this.render();
                
                // Send to Clients
                this.conns.forEach(c => {
                    const p = this.engine.players.find(x => x.id === c.peer);
                    c.send({t:'SYNC', s: s, h: p ? p.hand : []});
                });
            },

            act(type, data={}) {
                if(this.role === 'host') {
                    const res = this.engine.move(0, type, data);
                    if(res.success) this.sync();
                    else this.animInvalid(data.i);
                } else {
                    this.conn.send({t:'ACT', a: type, d: data});
                }
                this.sel = null;
            },

            // --- RENDER ---
            render() {
                document.getElementById('lobby').style.display = 'none';
                document.getElementById('game').style.display = 'flex';
                const s = this.state;
                if(!s) return;

                const myIdx = s.ps.findIndex(p => p.id === this.myId);
                const me = s.ps[myIdx];
                
                // 1. My Info
                document.getElementById('my-name').innerText = me.name;
                document.getElementById('my-ava').src = `https://robohash.org/${me.ava}.png?set=set3`;

                // 2. Opponents
                const oppDiv = document.getElementById('opp-area');
                oppDiv.innerHTML = '';
                // Render relative to me
                for(let i=1; i < s.ps.length; i++) {
                    const idx = (myIdx + i) % s.ps.length;
                    const p = s.ps[idx];
                    const isTurn = (s.t === idx);
                    
                    // Card back visual stack (no count)
                    let fan = '';
                    if(p.cnt > 0) {
                        fan = `<div class="opp-card"></div>`; // Just one visual card representing the stack
                        if(p.cnt > 1) fan += `<div class="opp-card" style="transform: rotate(5deg) translate(2px, -2px);"></div>`;
                        if(p.cnt > 4) fan += `<div class="opp-card" style="transform: rotate(-5deg) translate(-2px, -2px);"></div>`;
                    }

                    // Timer Logic
                    let timerHTML = '';
                    if(isTurn) {
                        // Calculate %
                        const elapsed = Date.now() - s.ts; // Note: Date.now() on client might differ slightly, but OK for visual
                        // Correction: Host sends TS. We need to approximate locally or just use CSS animation restart
                        // Let's use CSS transition trick: set stroke-offset based on time left
                        timerHTML = `<svg class="timer-svg" viewBox="0 0 74 74"><rect class="timer-path" id="timer-${idx}" x="2" y="2" width="70" height="70" rx="2"></rect></svg>`;
                    }

                    const html = `
                        <div class="player-wrap">
                            <div class="p-info">
                                <div class="p-name">${p.name}</div>
                            </div>
                            <div class="avatar-box">
                                <img src="https://robohash.org/${p.ava}.png?set=set3" class="avatar" style="${isTurn ? 'border-color:#fff' : ''}">
                                ${timerHTML}
                            </div>
                            <div class="p-hand-fan">${fan}</div>
                        </div>
                    `;
                    oppDiv.innerHTML += html;
                    
                    if(isTurn) {
                        setTimeout(() => this.updateTimer(`timer-${idx}`, s.ts), 10);
                    }
                }

                // 3. Deck & Trump
                document.getElementById('deck-num').innerText = s.d_cnt > 0 ? '' : ''; // Hiding count as per request? Or making it subtle. User said "Hide counter how many HE has". I hid opp counter. Deck counter I'll leave empty or minimal.
                document.getElementById('deck-top').style.display = s.d_cnt > 0 ? 'block' : 'none';
                const tEl = document.getElementById('trump-card');
                if(s.tr && s.d_cnt > 0) {
                    tEl.style.backgroundImage = `url('${IMG(s.tr.r, s.tr.s)}')`;
                    tEl.style.display = 'block';
                } else if (s.tr) {
                     // Empty deck, show trump icon phantom?
                     tEl.style.display = 'none';
                }

                // 4. Field
                const slDiv = document.getElementById('slots-area');
                slDiv.innerHTML = '';
                s.f.forEach((slot, si) => {
                    const el = document.createElement('div');
                    el.className = 'slot';
                    
                    const cAtt = document.createElement('div');
                    cAtt.className = 'card-face c-att';
                    cAtt.style.backgroundImage = `url('${IMG(slot.att.r, slot.att.s)}')`;
                    el.appendChild(cAtt);
                    
                    if(slot.def) {
                        const cDef = document.createElement('div');
                        cDef.className = 'card-face c-def';
                        cDef.style.backgroundImage = `url('${IMG(slot.def.r, slot.def.s)}')`;
                        el.appendChild(cDef);
                    } else {
                        // Interactive slot for defense
                        const defIdx = (s.t + 1) % s.ps.length;
                        if(myIdx === defIdx) {
                            el.classList.add('active');
                            el.onclick = () => {
                                if(this.sel !== null) this.act('DEFEND', {s: si, i: this.sel});
                            };
                        }
                    }
                    slDiv.appendChild(el);
                });

                // 5. My Hand
                const hDiv = document.getElementById('my-hand');
                hDiv.innerHTML = '';
                const width = Math.min(800, window.innerWidth - 20);
                const overlap = Math.min(50, width / (this.hand.length || 1));
                const totalW = (this.hand.length - 1) * overlap;
                const startX = -totalW / 2;

                this.hand.forEach((c, i) => {
                    const d = document.createElement('div');
                    d.className = 'my-card' + (this.sel === i ? ' selected' : '');
                    d.style.backgroundImage = `url('${IMG(c.r, c.s)}')`;
                    const x = startX + (i * overlap);
                    d.style.setProperty('--x', `${x}px`);
                    d.style.transform = `translateX(${x}px)`;
                    d.style.zIndex = i + 10;
                    
                    d.onclick = (e) => {
                        e.stopPropagation();
                        // Smart Click
                        const isAttacker = (s.t === myIdx);
                        const isTransfer = (myIdx === (s.t+1)%s.ps.length && s.f.length > 0 && s.f.every(x=>!x.def));
                        
                        if(isAttacker || isTransfer) {
                            this.sel = i;
                            this.act('ATTACK', {i});
                        } else {
                            // Select for defense
                            this.sel = (this.sel === i) ? null : i;
                            this.render();
                        }
                    };
                    hDiv.appendChild(d);
                });

                // 6. Status & Controls
                const bB = document.getElementById('btn-bito');
                const bT = document.getElementById('btn-take');
                const stat = document.getElementById('game-status');
                
                bB.style.display = 'none';
                bT.style.display = 'none';
                
                let statusText = "";
                let statusColor = "#fff";

                if(s.win) {
                    statusText = `Победа: ${s.win}!`;
                    statusColor = "var(--success)";
                } else if(s.t === myIdx) {
                    statusText = "Ваш ход: Атака";
                    statusColor = "var(--success)";
                    if(s.f.length > 0 && s.f.every(x => x.def)) bB.style.display = 'block';
                    else if(s.f.length > 0) bB.style.display = 'block'; // Can finish early?
                } else {
                    const defIdx = (s.t + 1) % s.ps.length;
                    if(myIdx === defIdx) {
                        statusText = "Ваш ход: Защита";
                        statusColor = "var(--gold)";
                        if(s.f.some(x => !x.def)) bT.style.display = 'block';
                    } else {
                        statusText = `Ход: ${s.ps[s.t].name}`;
                        statusColor = "var(--text-main)";
                    }
                }
                
                stat.innerText = statusText;
                stat.style.color = statusColor;
                stat.style.borderColor = statusColor;
            },

            updateTimer(id, startTs) {
                const el = document.getElementById(id);
                if(!el) return;
                
                const now = Date.now();
                // We need to estimate server time diff, but for simplicity assume synced clocks or short diff
                // In P2P, timestamps might be skewed. Better approach: Host sends "Time Remaining" or we just use local elapsed since receiving packet.
                // Let's assume startTs is relatively correct.
                
                const passed = (now - startTs) / 1000;
                const left = Math.max(0, TIMEOUT_SEC - passed);
                const pct = left / TIMEOUT_SEC;
                
                const dash = 240 * (1 - pct); // 240 is array length
                el.style.strokeDashoffset = dash;

                // Color logic
                if(pct > 0.5) el.style.stroke = 'var(--success)';
                else if(pct > 0.2) el.style.stroke = 'var(--gold)';
                else el.style.stroke = 'var(--danger)';

                if(left > 0) requestAnimationFrame(() => this.updateTimer(id, startTs));
            },

            animInvalid(i) {
                if(i === undefined || i === null) return;
                const cards = document.querySelectorAll('.my-card');
                if(cards[i]) {
                    cards[i].classList.remove('invalid');
                    void cards[i].offsetWidth; // trigger reflow
                    cards[i].classList.add('invalid');
                    Snd.play('alert');
                }
            },

            sendChat() {
                const inp = document.getElementById('chat-in');
                const m = inp.value.trim();
                if(!m) return;
                if(this.role === 'host') {
                    const msg = {t:'CHAT', n: this.engine.players[0].name, m};
                    this.broadcast(msg);
                } else {
                    this.conn.send({t:'CHAT', m});
                }
                inp.value = '';
            },

            addChat(d) {
                const log = document.getElementById('chat-log');
                const div = document.createElement('div');
                div.className = 'msg';
                if(d.n === 'System') div.className += ' sys';
                div.innerHTML = d.n === 'System' ? d.m : `<b>${d.n}:</b> ${d.m}`;
                log.appendChild(div);
                log.scrollTop = log.scrollHeight;
            }
        };

        Lobby.init();
        document.getElementById('chat-in').addEventListener('keydown', e => { if(e.key === 'Enter') Game.sendChat(); });

    </script>
</body>
</html>
