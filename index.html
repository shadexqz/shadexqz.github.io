<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Durak Online (Realtime P2P)</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');

        :root {
            --bg-color: #355c7d; /* –¶–≤–µ—Ç —Ñ–æ–Ω–∞ –∫–∞–∫ –Ω–∞ —Å–∫—Ä–∏–Ω–µ */
            --card-w: 90px;
            --card-h: 130px;
            --accent: #ffb300;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0;
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            background-image: 
                radial-gradient(circle at 50% 50%, #456c8d 0%, #2a4865 100%);
            height: 100vh;
            overflow: hidden;
            color: white;
            display: flex;
            flex-direction: column;
        }

        /* --- –ö–ê–†–¢–´ (SVG) --- */
        .card {
            width: var(--card-w);
            height: var(--card-h);
            border-radius: 6px;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
            position: relative;
            transition: transform 0.2s, margin 0.2s;
            cursor: pointer;
            background-color: white; /* –ø–æ–¥–ª–æ–∂–∫–∞ */
        }
        
        .card:hover { transform: translateY(-10px); z-index: 50; }
        .card.selected { transform: translateY(-20px); box-shadow: 0 0 10px var(--accent); z-index: 51; border: 2px solid var(--accent); }
        
        /* –•–∞–∫ –¥–ª—è —Ä—É—Å–∏—Ñ–∏–∫–∞—Ü–∏–∏ –±—É–∫–≤ (J, Q, K, A -> –í, –î, –ö, –¢) */
        .card[data-rank="J"]::after { content: "–í"; position: absolute; top:3px; left:4px; font-weight:bold; font-size:18px; color:inherit; background:white; padding:0 2px; line-height:1; }
        .card[data-rank="Q"]::after { content: "–î"; position: absolute; top:3px; left:4px; font-weight:bold; font-size:18px; color:inherit; background:white; padding:0 2px; line-height:1; }
        .card[data-rank="K"]::after { content: "–ö"; position: absolute; top:3px; left:4px; font-weight:bold; font-size:18px; color:inherit; background:white; padding:0 2px; line-height:1; }
        .card[data-rank="A"]::after { content: "–¢"; position: absolute; top:3px; left:4px; font-weight:bold; font-size:18px; color:inherit; background:white; padding:0 2px; line-height:1; }
        
        /* –¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ –¥–ª—è —Ö–∞–∫–∞ */
        .card.red::after { color: #d40000; }
        .card.black::after { color: #2d2d2d; }

        /* –†—É–±–∞—à–∫–∞ */
        .card-back {
            background-image: url('https://raw.githubusercontent.com/htdebeer/SVG-cards/master/png/1x/back-red.png');
            background-size: cover;
        }

        /* --- –õ–û–ë–ë–ò (–°—Ç–µ–∫–ª–æ) --- */
        #lobby {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            z-index: 9999;
            display: flex; align-items: center; justify-content: center;
        }
        .panel {
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
            max-width: 400px; width: 90%;
        }
        .btn {
            background: linear-gradient(to bottom, #4caf50, #388e3c);
            border: none; color: white;
            padding: 15px 30px; font-size: 18px; font-weight: bold;
            border-radius: 50px; cursor: pointer;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            margin: 10px 0; width: 100%;
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.98); }
        .btn.secondary { background: linear-gradient(to bottom, #2196f3, #1976d2); }
        input.input-box {
            width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #ccc;
            margin-bottom: 10px; font-size: 16px; text-align: center;
        }

        /* --- –ò–ì–†–û–í–û–ô –ò–ù–¢–ï–†–§–ï–ô–° --- */
        #game-board {
            display: none; flex-direction: column; height: 100%; position: relative;
        }

        /* –í–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å (–°–æ–ø–µ—Ä–Ω–∏–∫) */
        .top-bar {
            height: 120px;
            display: flex; justify-content: center; align-items: center;
            position: relative;
            background: linear-gradient(to bottom, rgba(0,0,0,0.3), transparent);
        }
        .avatar-zone {
            display: flex; flex-direction: column; align-items: center;
            margin: 0 20px;
        }
        .avatar {
            width: 60px; height: 60px; border-radius: 50%;
            background: #ddd; border: 3px solid #fff;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .avatar img { width: 100%; height: 100%; object-fit: cover; }
        .player-name { font-size: 14px; font-weight: bold; margin-top: 5px; text-shadow: 1px 1px 2px black; }
        
        /* –†—É–∫–∞ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ */
        .opp-hand { display: flex; margin-left: 20px; height: 80px; align-items: center; }
        .opp-card {
            width: 50px; height: 75px; 
            background-image: url('https://raw.githubusercontent.com/htdebeer/SVG-cards/master/png/1x/back-red.png');
            background-size: cover;
            border-radius: 4px;
            margin-left: -35px;
            box-shadow: -2px 0 5px rgba(0,0,0,0.3);
            border: 1px solid white;
        }

        /* –°—Ç–æ–ª (–¶–µ–Ω—Ç—Ä) */
        .table-area {
            flex: 1;
            position: relative;
            display: flex; justify-content: center; align-items: center;
        }
        .field-row {
            display: flex; gap: 15px;
            min-height: var(--card-h);
            padding: 20px;
        }
        .slot {
            position: relative;
            width: var(--card-w); height: var(--card-h);
        }
        /* –ö–∞—Ä—Ç–∞ –∞—Ç–∞–∫–∏ */
        .slot .card:nth-child(1) { position: absolute; top:0; left:0; z-index: 10; cursor: default; }
        /* –ö–∞—Ä—Ç–∞ –∑–∞—â–∏—Ç—ã (—Å –ø–æ–≤–æ—Ä–æ—Ç–æ–º) */
        .slot .card:nth-child(2) { position: absolute; top:15px; left:10px; z-index: 11; transform: rotate(10deg); cursor: default; }
        .slot:hover .card { transform: none; } /* –û—Ç–∫–ª—é—á–∞–µ–º —Ö–æ–≤–µ—Ä –Ω–∞ —Å—Ç–æ–ª–µ */

        /* –ö–æ–ª–æ–¥–∞ –∏ –ö–æ–∑—ã—Ä—å */
        .deck-zone {
            position: absolute; left: 20px; top: 50%; transform: translateY(-50%);
            display: flex; align-items: center;
        }
        .trump-card-el {
            transform: rotate(90deg); margin-right: -40px; margin-bottom: -10px;
        }
        .deck-stack {
            z-index: 5;
            position: relative;
        }
        .deck-badge {
            position: absolute; top: -15px; right: -10px;
            background: red; color: white; font-weight: bold;
            border-radius: 50%; width: 24px; height: 24px;
            display: flex; align-items: center; justify-content: center;
            font-size: 12px; z-index: 20; border: 2px solid white;
        }

        /* –†—É–∫–∞ –∏–≥—Ä–æ–∫–∞ */
        .player-hand {
            height: 180px;
            display: flex; justify-content: center; align-items: flex-end;
            padding-bottom: 20px;
            /* –°–º–µ—â–µ–Ω–∏–µ –∫–∞—Ä—Ç –≤–µ–µ—Ä–æ–º */
            perspective: 1000px;
        }
        .my-card-wrapper {
            margin-right: -40px;
            transition: 0.3s;
        }
        .my-card-wrapper:last-child { margin-right: 0; }
        .my-card-wrapper:hover { margin-bottom: 15px; margin-right: -10px; z-index: 100; }

        /* –ö–Ω–æ–ø–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π */
        .actions-ui {
            position: absolute; right: 20px; bottom: 180px;
            display: flex; flex-direction: column; align-items: flex-end; gap: 10px;
        }
        .game-status {
            background: rgba(0,0,0,0.7); padding: 8px 16px; border-radius: 8px;
            font-size: 16px; margin-bottom: 5px;
        }
        .action-btn {
            width: 80px; height: 80px;
            border-radius: 12px; border: none;
            font-weight: bold; color: white; font-size: 14px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            cursor: pointer; display: none;
            background-size: 40px; background-position: center 10px; background-repeat: no-repeat;
            padding-top: 40px;
        }
        .btn-bito { background-color: #d32f2f; } /* –ö—Ä–∞—Å–Ω–∞—è */
        .btn-take { background-color: #f57c00; } /* –û—Ä–∞–Ω–∂–µ–≤–∞—è */
        .btn-pass { background-color: #388e3c; } /* –ó–µ–ª–µ–Ω–∞—è */

        /* –ß–ê–¢ */
        #chat-btn-toggle {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.3);
            color: white; width: 40px; height: 40px; border-radius: 50%;
            cursor: pointer; z-index: 200; font-size: 20px;
        }
        .chat-box {
            position: absolute; top: 60px; right: 10px; width: 280px; height: 200px;
            background: rgba(30, 30, 30, 0.9); border-radius: 8px;
            display: none; flex-direction: column; z-index: 200;
            border: 1px solid #555; font-size: 13px;
        }
        .chat-visible { display: flex; }
        .chat-msgs {
            flex: 1; overflow-y: auto; padding: 10px;
            color: #ddd;
        }
        .chat-msg { margin-bottom: 4px; word-break: break-word; }
        .chat-msg b { color: var(--accent); }
        .chat-input-area {
            display: flex; border-top: 1px solid #555;
        }
        .chat-input {
            flex: 1; background: transparent; border: none; color: white; padding: 10px; outline: none;
        }
        .chat-send {
            background: var(--accent); border: none; color: black; font-weight: bold;
            padding: 0 15px; cursor: pointer;
        }
        .unread-dot {
            position: absolute; top: 0; right: 0; width: 12px; height: 12px; background: red; border-radius: 50%; border: 2px solid white; display: none;
        }

        /* –ê–¥–∞–ø—Ç–∏–≤ */
        @media (max-width: 600px) {
            :root { --card-w: 60px; --card-h: 90px; }
            .opp-card { width: 30px; height: 45px; margin-left: -20px; }
            .player-hand { height: 130px; }
            .actions-ui { bottom: 140px; }
            .action-btn { width: 60px; height: 60px; font-size: 11px; padding-top: 0; display: flex; justify-content: center; align-items: center; }
        }
    </style>
</head>
<body>

    <!-- –õ–û–ë–ë–ò -->
    <div id="lobby">
        <div class="panel">
            <h1 style="margin:0 0 20px 0; color:#355c7d;">DURAK P2P</h1>
            <div id="lobby-menu">
                <input type="text" id="my-name" class="input-box" placeholder="–í–∞—à–µ –∏–º—è" value="–ò–≥—Ä–æ–∫">
                <button class="btn" onclick="App.hostGame()">–°–æ–∑–¥–∞—Ç—å —Å—Ç–æ–ª</button>
                <div style="margin:10px; opacity:0.5">- –∏–ª–∏ -</div>
                <input type="text" id="join-id" class="input-box" placeholder="ID —Å—Ç–æ–ª–∞">
                <button class="btn secondary" onclick="App.joinGame()">–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è</button>
            </div>
            <div id="lobby-wait" style="display:none;">
                <h3>–û–∂–∏–¥–∞–Ω–∏–µ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞...</h3>
                <p>–û—Ç–ø—Ä–∞–≤—å—Ç–µ ID –¥—Ä—É–≥—É:</p>
                <input type="text" id="host-id-display" class="input-box" readonly onclick="this.select()">
                <div class="loader">‚åõ</div>
            </div>
        </div>
    </div>

    <!-- –ò–ì–†–ê -->
    <div id="game-board">
        <!-- –ö–Ω–æ–ø–∫–∞ —á–∞—Ç–∞ -->
        <button id="chat-btn-toggle" onclick="UI.toggleChat()">üí¨<div class="unread-dot" id="chat-dot"></div></button>
        <div class="chat-box" id="chat-window">
            <div class="chat-msgs" id="chat-history">
                <div class="chat-msg" style="color:#aaa;"><i>–ß–∞—Ç –∏–≥—Ä—ã...</i></div>
            </div>
            <div class="chat-input-area">
                <input type="text" class="chat-input" id="chat-in" placeholder="–°–æ–æ–±—â–µ–Ω–∏–µ..." onkeypress="if(event.key==='Enter') App.sendChat()">
                <button class="chat-send" onclick="App.sendChat()">‚û§</button>
            </div>
        </div>

        <!-- –í–µ—Ä—Ö: –°–æ–ø–µ—Ä–Ω–∏–∫ -->
        <div class="top-bar">
            <div class="avatar-zone">
                <div class="avatar"><img src="https://robohash.org/opponent?set=set4" alt="Opp"></div>
                <div class="player-name" id="opp-name">–°–æ–ø–µ—Ä–Ω–∏–∫</div>
            </div>
            <div class="opp-hand" id="opp-hand-container">
                <!-- –ö–∞—Ä—Ç—ã —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ -->
            </div>
        </div>

        <!-- –¶–µ–Ω—Ç—Ä: –°—Ç–æ–ª -->
        <div class="table-area">
            <!-- –ö–æ–ª–æ–¥–∞ -->
            <div class="deck-zone">
                <div id="trump-slot" class="trump-card-el"></div>
                <div id="deck-slot" class="card card-back deck-stack"></div>
                <div class="deck-badge" id="deck-count">36</div>
            </div>
            
            <!-- –ü–æ–ª–µ –±–∏—Ç–≤—ã -->
            <div class="field-row" id="field-container">
                <!-- –°–ª–æ—Ç—ã -->
            </div>

            <!-- UI –î–µ–π—Å—Ç–≤–∏–π -->
            <div class="actions-ui">
                <div class="game-status" id="status-text">–û–∂–∏–¥–∞–Ω–∏–µ —Ö–æ–¥–∞...</div>
                <button class="action-btn btn-bito" id="btn-bito" onclick="App.doAction('BITO')">–ë–ò–¢–û</button>
                <button class="action-btn btn-take" id="btn-take" onclick="App.doAction('TAKE')">–í–ó–Ø–¢–¨</button>
            </div>
        </div>

        <!-- –ù–∏–∑: –Ø -->
        <div class="player-hand" id="my-hand-container">
            <!-- –ú–æ–∏ –∫–∞—Ä—Ç—ã -->
        </div>
        <div style="position: absolute; bottom: 10px; left: 10px; display: flex; align-items: center; gap:10px;">
            <div class="avatar" style="width: 50px; height: 50px;"><img src="https://robohash.org/me?set=set4" alt="Me"></div>
            <div class="player-name" id="my-name-display">–Ø</div>
        </div>
    </div>

    <script>
        // --- –î–ê–ù–ù–´–ï –ò –£–¢–ò–õ–ò–¢–´ ---
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º SVG –∫–∞—Ä—Ç—ã –∏–∑ open source —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è
        const SUITS = ['S', 'C', 'H', 'D']; // Spades, Clubs, Hearts, Diamonds
        const RANKS = ['6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è URL –¥–ª—è SVG –∫–∞—Ä—Ç—ã
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º rawgit –∏–ª–∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–π CDN –¥–ª—è –∫–∞—Ä—Ç
        const getCardUrl = (rank, suit) => {
            // –§–æ—Ä–º–∞—Ç –∏–º–µ–Ω —Ñ–∞–π–ª–æ–≤ –≤ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏: 6H.svg, KD.svg, etc.
            // –†–µ–ø–æ: https://github.com/htdebeer/SVG-cards
            return `https://raw.githubusercontent.com/htdebeer/SVG-cards/master/svg/${rank}${suit}.svg`;
        };

        const getSuitSymbol = (s) => {
            if(s==='S') return '‚ô†'; if(s==='C') return '‚ô£';
            if(s==='H') return '‚ô•'; if(s==='D') return '‚ô¶';
        };

        const isRed = (s) => s==='H' || s==='D';

        // --- –õ–û–ì–ò–ö–ê –î–£–†–ê–ö–ê (Engine) ---
        class GameEngine {
            constructor() {
                this.deck = [];
                this.trump = null;
                this.hands = { host: [], client: [] };
                this.field = []; 
                this.turn = 'host';
                this.gameOver = false;
                this.names = { host: 'Host', client: 'Client' };
            }

            init(hostName, clientName) {
                this.names.host = hostName;
                this.names.client = clientName;
                this.deck = [];
                SUITS.forEach(s => RANKS.forEach(r => this.deck.push({r, s, id: r+s})));
                this.deck.sort(() => Math.random() - 0.5); // Shuffle

                this.hands.host = this.deck.splice(0, 6);
                this.hands.client = this.deck.splice(0, 6);
                
                this.trump = this.deck.pop();
                this.deck.unshift(this.trump); // –í –º–∞—Å—Å–∏–≤ –≤ –Ω–∞—á–∞–ª–æ (–Ω–∏–∑ –∫–æ–ª–æ–¥—ã)

                // –ö—Ç–æ –ø–µ—Ä–≤—ã–π —Ö–æ–¥–∏—Ç (—É –∫–æ–≥–æ –º–µ–Ω—å—à–∏–π –∫–æ–∑—ã—Ä—å)
                let minH = 100, minC = 100;
                const val = c => RANKS.indexOf(c.r);
                this.hands.host.forEach(c => { if(c.s === this.trump.s && val(c) < minH) minH = val(c); });
                this.hands.client.forEach(c => { if(c.s === this.trump.s && val(c) < minC) minC = val(c); });
                
                this.turn = (minC < minH && minC !== 100) ? 'client' : 'host';
            }

            canBeat(att, def) {
                if (def.s === att.s) return RANKS.indexOf(def.r) > RANKS.indexOf(att.r);
                return def.s === this.trump.s;
            }

            attack(player, cardIdx) {
                if(player !== this.turn) return false;
                const hand = this.hands[player];
                if(!hand[cardIdx]) return false;
                const card = hand[cardIdx];

                if(this.field.length > 0) {
                    // –ü–æ–¥–∫–∏–¥–Ω–æ–π: —Ä–∞–Ω–≥ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–∞ —Å—Ç–æ–ª–µ
                    const ranks = new Set(this.field.flatMap(p => [p.att.r, p.def?.r].filter(Boolean)));
                    if(!ranks.has(card.r)) return false;
                }

                // –õ–∏–º–∏—Ç 6 –∏–ª–∏ –∫–∞—Ä—Ç –∑–∞—â–∏—â–∞—é—â–µ–≥–æ—Å—è
                const defPlayer = player==='host'?'client':'host';
                const unbeat = this.field.filter(p=>!p.def).length;
                if(unbeat >= this.hands[defPlayer].length) return false;
                if(this.field.length >= 6) return false;

                hand.splice(cardIdx, 1);
                this.field.push({ att: card, def: null });
                return true;
            }

            defend(player, cardIdx, slotIdx) {
                if(player === this.turn) return false;
                const slot = this.field[slotIdx];
                if(!slot || slot.def) return false;
                
                const card = this.hands[player][cardIdx];
                if(this.canBeat(slot.att, card)) {
                    this.hands[player].splice(cardIdx, 1);
                    slot.def = card;
                    return true;
                }
                return false;
            }

            bito(player) {
                if(player !== this.turn) return false;
                if(this.field.length === 0 || this.field.some(p => !p.def)) return false;
                
                this.field = [];
                this.drawCards();
                this.turn = this.turn==='host'?'client':'host';
                this.checkWin();
                return true;
            }

            take(player) {
                if(player === this.turn) return false;
                
                this.field.forEach(p => {
                    this.hands[player].push(p.att);
                    if(p.def) this.hands[player].push(p.def);
                });
                this.field = [];
                this.drawCards(true); // –¢–æ–ª—å–∫–æ –∞—Ç–∞–∫—É—é—â–∏–π –¥–æ–±–∏—Ä–∞–µ—Ç
                // –•–æ–¥ –Ω–µ –º–µ–Ω—è–µ—Ç—Å—è (–∞—Ç–∞–∫—É—é—â–∏–π —Ç–æ—Ç –∂–µ)
                this.checkWin();
                return true;
            }

            drawCards(skipDefender = false) {
                const att = this.turn;
                const def = att==='host'?'client':'host';
                const fill = (p) => {
                    while(this.hands[p].length < 6 && this.deck.length > 0) {
                        this.hands[p].push(this.deck.pop()); // –ë–µ—Ä–µ–º —Å–≤–µ—Ä—Ö—É (–∫–æ–Ω–µ—Ü –º–∞—Å—Å–∏–≤–∞)
                    }
                };
                fill(att);
                if(!skipDefender) fill(def);
            }

            checkWin() {
                if(this.deck.length === 0) {
                    if(this.hands.host.length === 0) this.gameOver = 'host';
                    else if(this.hands.client.length === 0) this.gameOver = 'client';
                }
            }

            getState() {
                return {
                    trump: this.trump,
                    deckCount: this.deck.length,
                    field: this.field,
                    turn: this.turn,
                    handsCounts: { host: this.hands.host.length, client: this.hands.client.length },
                    gameOver: this.gameOver,
                    names: this.names
                };
            }
        }

        // --- NETWORK & CONTROLLER ---
        const App = {
            peer: null,
            conn: null,
            role: null, // 'host' or 'client'
            name: 'Player',
            game: null, // Exists only on Host
            state: null,
            myHand: [],
            selIdx: null, // Selected card index

            init() {
                const url = new URLSearchParams(window.location.search);
                if(url.has('game')) {
                    document.getElementById('join-id').value = url.get('game');
                }
            },

            hostGame() {
                this.role = 'host';
                this.name = document.getElementById('my-name').value || 'Host';
                this.game = new GameEngine();
                
                this.peer = new Peer();
                this.peer.on('open', id => {
                    document.getElementById('lobby-menu').style.display = 'none';
                    document.getElementById('lobby-wait').style.display = 'block';
                    document.getElementById('host-id-display').value = id;
                });

                this.peer.on('connection', conn => {
                    this.conn = conn;
                    this.setupConn();
                });
            },

            joinGame() {
                const id = document.getElementById('join-id').value;
                if(!id) return alert("–í–≤–µ–¥–∏—Ç–µ ID");
                this.role = 'client';
                this.name = document.getElementById('my-name').value || 'Client';
                
                this.peer = new Peer();
                this.peer.on('open', () => {
                    this.conn = this.peer.connect(id);
                    this.setupConn();
                });
            },

            setupConn() {
                this.conn.on('open', () => {
                    // Handshake: Client –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∏–º—è
                    if(this.role === 'client') {
                        this.conn.send({ type: 'HI', name: this.name });
                    }
                });

                this.conn.on('data', data => {
                    if(data.type === 'HI' && this.role === 'host') {
                        // Host receives name, starts game
                        this.game.init(this.name, data.name);
                        this.sync();
                        UI.startGame();
                    }
                    else if(data.type === 'SYNC') {
                        this.state = data.state;
                        this.myHand = data.hand;
                        if(!UI.gameRunning) UI.startGame();
                        UI.render();
                    }
                    else if(data.type === 'ACT' && this.role === 'host') {
                        this.handleAct(data);
                    }
                    else if(data.type === 'CHAT') {
                        UI.addChatMsg(data.sender, data.msg);
                    }
                });
                
                this.conn.on('close', () => alert("–°–≤—è–∑—å –ø–æ—Ç–µ—Ä—è–Ω–∞"));
            },

            handleAct(data) {
                // Host logic wrapper
                let ok = false;
                const p = data.p;
                if(data.act === 'ATTACK') ok = this.game.attack(p, data.idx);
                else if(data.act === 'DEFEND') ok = this.game.defend(p, data.idx, data.slot);
                else if(data.act === 'BITO') ok = this.game.bito(p);
                else if(data.act === 'TAKE') ok = this.game.take(p);

                if(ok) this.sync();
            },

            sync() {
                if(this.role !== 'host') return;
                const common = this.game.getState();
                
                // Update Self
                this.state = common;
                this.myHand = this.game.hands.host;
                UI.render();

                // Send to Client
                this.conn.send({
                    type: 'SYNC',
                    state: common,
                    hand: this.game.hands.client
                });
            },

            sendAct(act, payload={}) {
                if(this.role === 'host') {
                    this.handleAct({ p: 'host', act, ...payload });
                } else {
                    this.conn.send({ type: 'ACT', p: 'client', act, ...payload });
                }
            },

            sendChat() {
                const input = document.getElementById('chat-in');
                const txt = input.value.trim();
                if(!txt) return;
                
                // Show locally
                UI.addChatMsg('–Ø', txt);
                // Send
                if(this.conn) this.conn.send({ type: 'CHAT', sender: this.name, msg: txt });
                input.value = '';
            },

            doAction(type) {
                this.sendAct(type);
            }
        };

        // --- UI RENDERER ---
        const UI = {
            gameRunning: false,
            
            startGame() {
                this.gameRunning = true;
                document.getElementById('lobby').style.display = 'none';
                document.getElementById('game-board').style.display = 'flex';
                document.getElementById('my-name-display').innerText = App.name;
            },

            render() {
                const s = App.state;
                if(s.gameOver) {
                    alert("–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: " + s.names[s.gameOver]);
                    location.reload();
                    return;
                }

                // Opponent Info
                const oppRole = App.role === 'host' ? 'client' : 'host';
                document.getElementById('opp-name').innerText = s.names[oppRole];
                
                // 1. Deck & Trump
                const trumpEl = document.getElementById('trump-slot');
                trumpEl.innerHTML = '';
                const deckBadge = document.getElementById('deck-count');
                const deckBack = document.getElementById('deck-slot');

                if(s.deckCount > 0) {
                    trumpEl.appendChild(this.createCard(s.trump));
                    deckBadge.innerText = s.deckCount;
                    deckBack.style.visibility = s.deckCount > 1 ? 'visible' : 'hidden';
                } else {
                    deckBadge.innerText = '0';
                    deckBack.style.visibility = 'hidden';
                    // Show trump icon ghost if needed, or leave empty
                }

                // 2. Opponent Hand
                const oppCount = s.handsCounts[oppRole];
                const oppDiv = document.getElementById('opp-hand-container');
                oppDiv.innerHTML = '';
                for(let i=0; i<oppCount; i++) {
                    const c = document.createElement('div');
                    c.className = 'opp-card';
                    oppDiv.appendChild(c);
                }

                // 3. Field
                const fieldDiv = document.getElementById('field-container');
                fieldDiv.innerHTML = '';
                s.field.forEach((slotData, idx) => {
                    const slot = document.createElement('div');
                    slot.className = 'slot';
                    
                    slot.appendChild(this.createCard(slotData.att));
                    if(slotData.def) {
                        slot.appendChild(this.createCard(slotData.def));
                    } else {
                        // Drop zone for click
                        if(App.role !== s.turn && App.selIdx !== null) {
                            slot.onclick = () => {
                                App.sendAct('DEFEND', { idx: App.selIdx, slot: idx });
                                App.selIdx = null;
                            };
                            slot.style.boxShadow = "inset 0 0 10px #ffb300";
                            slot.style.borderRadius = "6px";
                            slot.style.cursor = "pointer";
                        }
                    }
                    fieldDiv.appendChild(slot);
                });

                // 4. My Hand
                const myDiv = document.getElementById('my-hand-container');
                myDiv.innerHTML = '';
                App.myHand.forEach((c, i) => {
                    const wrap = document.createElement('div');
                    wrap.className = 'my-card-wrapper';
                    const el = this.createCard(c);
                    if(App.selIdx === i) el.classList.add('selected');
                    
                    el.onclick = () => {
                        if(App.role === s.turn) {
                            App.sendAct('ATTACK', { idx: i });
                        } else {
                            App.selIdx = (App.selIdx === i) ? null : i;
                            this.render();
                        }
                    };
                    wrap.appendChild(el);
                    myDiv.appendChild(wrap);
                });

                // 5. Controls
                const isMyTurn = App.role === s.turn;
                const status = document.getElementById('status-text');
                const btnBito = document.getElementById('btn-bito');
                const btnTake = document.getElementById('btn-take');

                btnBito.style.display = 'none';
                btnTake.style.display = 'none';

                if(isMyTurn) {
                    status.innerText = "–í–∞—à —Ö–æ–¥ (–ê—Ç–∞–∫–∞)";
                    status.style.color = "#81c784";
                    // –ï—Å–ª–∏ –µ—Å—Ç—å —á—Ç–æ –±–∏—Ç—å
                    const allCovered = s.field.length > 0 && s.field.every(p => p.def);
                    if(allCovered) btnBito.style.display = 'block'; 
                } else {
                    status.innerText = "–û—Ç–±–∏–≤–∞–π—Ç–µ—Å—å!";
                    status.style.color = "#ffb74d";
                    if(s.field.some(p => !p.def)) btnTake.style.display = 'block';
                }
            },

            createCard(c) {
                const el = document.createElement('div');
                const color = isRed(c.s) ? 'red' : 'black';
                el.className = `card ${color}`;
                el.dataset.rank = c.r; // For CSS content hack
                el.style.backgroundImage = `url('${getCardUrl(c.r, c.s)}')`;
                return el;
            },

            addChatMsg(sender, msg) {
                const box = document.getElementById('chat-history');
                const div = document.createElement('div');
                div.className = 'chat-msg';
                div.innerHTML = `<b>${sender}:</b> ${msg}`;
                box.appendChild(div);
                box.scrollTop = box.scrollHeight;

                const win = document.getElementById('chat-window');
                if(win.style.display !== 'flex' && sender !== '–Ø') {
                    document.getElementById('chat-dot').style.display = 'block';
                }
            },

            toggleChat() {
                const win = document.getElementById('chat-window');
                const dot = document.getElementById('chat-dot');
                if(win.style.display === 'flex') {
                    win.style.display = 'none';
                } else {
                    win.style.display = 'flex';
                    dot.style.display = 'none';
                }
            }
        };

        App.init();

    </script>
</body>
</html>
