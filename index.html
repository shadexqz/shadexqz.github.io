<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Durak Elite: Private Club</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-dark: #1b2120;
            --felt: #2b4539;
            --gold: #c5a059;
            --gold-dim: #8a703d;
            --text-main: #e0e0e0;
            --card-w: 100px;
            --card-h: 140px;
            --radius: 8px;
            --shadow-soft: 0 4px 12px rgba(0,0,0,0.3);
            --shadow-hard: 0 10px 25px rgba(0,0,0,0.6);
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; outline: none; }
        
        body {
            margin: 0;
            font-family: 'Lato', sans-serif;
            background-color: var(--bg-dark);
            /* Elegant Felt Texture */
            background-image: 
                radial-gradient(circle at 50% 50%, rgba(255,255,255,0.05) 0%, rgba(0,0,0,0.6) 100%),
                url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.07'/%3E%3C/svg%3E");
            background-size: cover;
            height: 100vh;
            overflow: hidden;
            display: flex; flex-direction: column;
            color: var(--text-main);
        }

        h1, h2, h3, .brand-font { font-family: 'Playfair Display', serif; }

        /* --- UI UTILS --- */
        .hidden { display: none !important; }
        .btn {
            background: linear-gradient(135deg, var(--gold), var(--gold-dim));
            border: 1px solid #fff3;
            color: #1a1a1a;
            padding: 14px 24px;
            font-size: 16px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            border-radius: 4px;
            box-shadow: var(--shadow-soft);
            transition: transform 0.1s, filter 0.2s;
        }
        .btn:active { transform: translateY(2px); filter: brightness(0.9); }
        .btn:disabled { filter: grayscale(1); opacity: 0.5; cursor: not-allowed; }
        .btn-sec { background: #444; color: var(--gold); border: 1px solid var(--gold-dim); }

        .inp {
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--gold-dim);
            color: var(--gold);
            padding: 12px;
            font-family: 'Playfair Display', serif;
            font-size: 18px;
            text-align: center;
            border-radius: 4px;
            width: 100%;
        }

        /* --- LOBBY --- */
        #lobby {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 15, 13, 0.95);
            z-index: 9999;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(8px);
        }
        .panel {
            background: linear-gradient(to bottom, #2a2a2a, #1f1f1f);
            padding: 40px; border-radius: 4px;
            width: 90%; max-width: 500px;
            text-align: center;
            box-shadow: 0 0 0 1px #444, 0 30px 80px #000;
            position: relative;
        }
        .panel::after {
            content: ''; position: absolute; top: 4px; left: 4px; right: 4px; bottom: 4px;
            border: 1px solid rgba(197, 160, 89, 0.3); pointer-events: none;
        }
        .panel h1 { margin: 0 0 25px; color: var(--gold); font-size: 36px; letter-spacing: 2px; }

        .avatar-grid { display: flex; gap: 15px; justify-content: center; margin: 20px 0; }
        .ava-opt {
            width: 55px; height: 55px; border-radius: 50%;
            background-size: cover; cursor: pointer;
            border: 2px solid #555;
            transition: 0.2s;
            position: relative;
        }
        .ava-opt.selected { border-color: var(--gold); box-shadow: 0 0 15px var(--gold-dim); transform: scale(1.1); }

        .radio-group { display: flex; justify-content: center; gap: 30px; margin: 20px 0; color: #aaa; font-weight: bold; }
        .radio-group label { cursor: pointer; display: flex; align-items: center; gap: 8px; }
        .radio-group input { accent-color: var(--gold); transform: scale(1.3); }

        /* --- GAME LAYOUT --- */
        #game { display: none; width: 100%; height: 100%; position: relative; }

        /* CHAT: Bottom Left */
        .chat-container {
            position: absolute; bottom: 20px; left: 20px;
            width: 300px; z-index: 1000;
            display: flex; flex-direction: column; gap: 10px;
            pointer-events: none; /* Let clicks pass through empty areas */
        }
        .chat-log {
            display: flex; flex-direction: column; align-items: flex-start;
            gap: 6px;
            max-height: 250px;
            overflow: hidden;
            mask-image: linear-gradient(to top, black 80%, transparent 100%);
            -webkit-mask-image: linear-gradient(to top, black 80%, transparent 100%);
        }
        .chat-msg {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 14px;
            border-radius: 4px;
            border-left: 3px solid var(--gold);
            color: #eee;
            font-size: 14px;
            backdrop-filter: blur(4px);
            pointer-events: auto;
            animation: fadeIn 0.3s ease-out;
            max-width: 100%;
            word-wrap: break-word;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        .chat-msg b { color: var(--gold); font-family: 'Playfair Display', serif; margin-right: 5px; }
        .chat-msg.sys { border-left-color: #666; font-style: italic; color: #aaa; }
        .chat-msg.me { border-left-color: #4caf50; align-self: flex-start; } /* Keep align start for consistency */
        
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .chat-input-wrap {
            display: flex; pointer-events: auto;
            background: rgba(0,0,0,0.8);
            border: 1px solid #555; border-radius: 4px;
        }
        #chat-in {
            flex: 1; background: transparent; border: none; color: white; padding: 10px;
            font-family: 'Lato', sans-serif;
        }
        #chat-btn {
            background: #333; border: none; border-left: 1px solid #555; color: var(--gold);
            width: 40px; cursor: pointer; font-weight: bold;
        }
        #chat-btn:hover { background: #444; }

        /* OPPONENTS (Top) */
        .opponents-area {
            position: absolute; top: 0; left: 0; width: 100%;
            height: 160px;
            display: flex; justify-content: center; align-items: flex-start;
            padding-top: 20px; gap: 60px;
            z-index: 10;
        }

        .player-node {
            display: flex; flex-direction: column; align-items: center;
            position: relative; width: 90px;
            transition: opacity 0.3s;
        }
        .player-node.inactive { opacity: 0.5; }
        
        .ava-wrap { position: relative; width: 64px; height: 64px; }
        .ava-img {
            width: 100%; height: 100%; border-radius: 50%;
            object-fit: cover;
            border: 3px solid #222; /* Fallback */
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        
        /* SVG Timer Ring */
        .timer-svg {
            position: absolute; top: -5px; left: -5px; width: 74px; height: 74px;
            transform: rotate(-90deg); pointer-events: none;
        }
        .timer-circle {
            fill: none; stroke: var(--gold); stroke-width: 3;
            stroke-dasharray: 200; stroke-dashoffset: 200;
            transition: stroke-dashoffset 1s linear;
        }

        .p-name {
            margin-top: 8px; font-weight: bold; font-size: 14px;
            text-shadow: 0 2px 4px black; color: #ccc;
        }
        .p-cards-cnt {
            margin-top: 2px; font-size: 11px; color: var(--gold);
            display: flex; gap: 2px;
        }
        .mini-card-icon {
            width: 10px; height: 14px; background: #ddd; border-radius: 1px;
            box-shadow: 1px 1px 2px black;
        }

        /* TABLE */
        .table-center {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -60%);
            width: 100%; max-width: 800px; height: 200px;
            z-index: 5;
            display: flex; justify-content: center; align-items: center;
        }

        /* DECK & BITO */
        .deck-area {
            position: absolute; left: 40px; top: 50%; transform: translateY(-50%);
            width: var(--card-w); height: var(--card-h);
        }
        .bito-area {
            position: absolute; right: 40px; top: 50%; transform: translateY(-50%);
            width: var(--card-w); height: var(--card-h);
        }
        .bito-label {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.1); font-weight: 900; font-size: 24px; pointer-events: none;
        }

        .card-stack-item {
            position: absolute; width: 100%; height: 100%;
            background-color: #fff; border-radius: var(--radius);
            box-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            /* SVG Pattern Back */
            background-image: url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h20v20H0z' fill='%231a283a'/%3E%3Cpath d='M10 0l10 10-10 10L0 10z' fill='%23c5a059' fill-opacity='0.15'/%3E%3C/svg%3E");
            border: 1px solid #333;
        }
        .trump-card {
            position: absolute; top: 10px; left: -20px;
            transform: rotate(90deg); z-index: -1;
        }
        .deck-counter {
            position: absolute; bottom: -30px; width: 100%; text-align: center;
            font-size: 14px; color: #888; font-family: 'Playfair Display', serif;
        }

        /* BATTLE SLOTS */
        .slots-row {
            display: flex; gap: 20px; align-items: center; justify-content: center;
            height: 100%; perspective: 1000px;
        }
        .slot {
            width: var(--card-w); height: var(--card-h);
            position: relative;
            border-radius: var(--radius);
            background: rgba(0,0,0,0.1);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
            transition: box-shadow 0.2s;
        }
        .slot.active-target { box-shadow: inset 0 0 15px var(--gold); cursor: pointer; }

        /* CARDS */
        .card {
            position: absolute;
            width: var(--card-w); height: var(--card-h);
            border-radius: var(--radius);
            background-color: #fff;
            background-size: 100% 100%;
            background-repeat: no-repeat;
            box-shadow: var(--shadow-soft);
            transition: transform 0.2s, box-shadow 0.2s;
            transform-origin: center center;
            z-index: 10;
        }
        .card:hover { z-index: 100; }
        .card.att { top: 0; left: 0; }
        .card.def { top: 20px; left: 20px; z-index: 20; transform: rotate(10deg); }

        /* MY HAND (Bottom) */
        .my-zone {
            position: absolute; bottom: 0; left: 0; width: 100%;
            height: 180px;
            display: flex; justify-content: center; align-items: flex-end;
            padding-bottom: 20px;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
        }
        .my-hand {
            display: flex; align-items: flex-end;
            height: 150px;
        }
        .my-card-wrap {
            width: 45px; height: var(--card-h);
            position: relative;
            transition: width 0.3s, transform 0.3s;
            cursor: pointer;
        }
        .my-card-wrap:last-child { width: var(--card-w); }
        .my-card-wrap:hover { width: 70px; transform: translateY(-15px); }
        .my-card-wrap:last-child:hover { width: var(--card-w); }

        .my-card-wrap .card {
            position: absolute; bottom: 0; left: 0;
            transform: none !important;
            transition: bottom 0.2s;
        }
        .my-card-wrap.selected .card {
            bottom: 30px;
            box-shadow: 0 0 0 3px var(--gold), 0 10px 20px black;
        }

        /* ACTIONS */
        .actions-panel {
            position: absolute; right: 30px; bottom: 200px;
            display: flex; flex-direction: column; align-items: flex-end; gap: 15px;
        }
        .status-pill {
            background: #111; color: white;
            padding: 10px 20px; border-left: 4px solid #555;
            font-family: 'Playfair Display', serif; font-size: 18px;
            box-shadow: 0 5px 15px black;
            margin-bottom: 10px;
        }

        /* FLYING ANIMATION LAYER */
        #anim-layer {
            position: absolute; top:0; left:0; width:100%; height:100%;
            pointer-events: none; z-index: 9999; overflow: hidden;
        }
        .flying-card {
            position: absolute;
            transition: transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
            box-shadow: 0 15px 30px rgba(0,0,0,0.5);
        }

        /* RESPONSIVE */
        @media (max-width: 800px) {
            :root { --card-w: 70px; --card-h: 100px; }
            .opponents-area { gap: 10px; height: 130px; }
            .ava-wrap { width: 50px; height: 50px; }
            .timer-svg { width: 60px; height: 60px; left:-5px; top:-5px; }
            .timer-circle { stroke-width: 3; }
            .my-zone { height: 140px; }
            .chat-container { width: 200px; bottom: 120px; left: 10px; }
            .actions-panel { bottom: 150px; right: 10px; }
            .deck-area { left: 10px; }
            .bito-area { right: 10px; }
            .slots-row { gap: 8px; }
            .btn { padding: 10px 16px; font-size: 14px; }
        }
    </style>
</head>
<body>

    <!-- LOBBY -->
    <div id="lobby">
        <div class="panel" id="panel-create">
            <h1>DURAK ELITE</h1>
            <div style="color:#aaa; font-size:14px; margin-bottom:10px;">ВЫБЕРИТЕ АВАТАР</div>
            <div class="avatar-grid" id="ava-list"></div>
            
            <input type="text" id="p-name" class="inp" placeholder="Ваше Имя" maxlength="10">

            <div class="radio-group">
                <label><input type="radio" name="mode" value="2" checked> 2 Игрока</label>
                <label><input type="radio" name="mode" value="3"> 3 Игрока</label>
            </div>
            <div class="radio-group" style="margin-top:0;">
                <label><input type="checkbox" id="chk-transfer"> Переводной</label>
            </div>

            <div style="display:flex; gap:10px; margin-top:20px;">
                <button class="btn" style="flex:1;" onclick="UI.createGame()">Создать Стол</button>
            </div>
            
            <div style="margin:20px 0; border-top:1px solid #444; position:relative;">
                <span style="position:absolute; top:-10px; left:50%; transform:translateX(-50%); background:#242424; padding:0 10px; color:#777; font-size:12px;">ИЛИ ВОЙТИ</span>
            </div>

            <div style="display:flex; gap:10px;">
                <input type="text" id="join-id" class="inp" placeholder="ID Комнаты" style="flex:1;">
                <button class="btn btn-sec" onclick="UI.joinGame()">Войти</button>
            </div>
        </div>

        <div class="panel hidden" id="panel-wait">
            <h2>Ожидание Игроков</h2>
            <p style="color:#888;">Скопируйте ID и отправьте другу:</p>
            <input type="text" id="host-id" class="inp" readonly onclick="this.select()" style="cursor:pointer; color:#fff;">
            <h3 id="wait-count" style="color:var(--gold); font-size:40px; margin:20px 0;">1/2</h3>
            <div style="color:#555;">Ожидание подключения...</div>
        </div>
    </div>

    <!-- GAME -->
    <div id="game">
        <div id="anim-layer"></div>

        <!-- Chat -->
        <div class="chat-container">
            <div class="chat-log" id="chat-log"></div>
            <div class="chat-input-wrap">
                <input type="text" id="chat-in" placeholder="Чат..." autocomplete="off" maxlength="30">
                <button id="chat-btn" onclick="Game.sendChat()">></button>
            </div>
        </div>

        <!-- Opponents -->
        <div class="opponents-area" id="opponents-container"></div>

        <!-- Table -->
        <div class="table-center">
            <div class="deck-area">
                <div id="deck-stack"></div>
                <div class="deck-counter" id="deck-count">36</div>
            </div>

            <div class="slots-row" id="slots-container"></div>

            <div class="bito-area">
                <div class="bito-label">БИТО</div>
                <div id="bito-stack"></div>
            </div>
        </div>

        <!-- Actions -->
        <div class="actions-panel">
            <div class="status-pill" id="status-text">Ожидание...</div>
            <button class="btn hidden" id="btn-action" onclick="Game.doAction()"></button>
        </div>

        <!-- My Hand -->
        <div class="my-zone">
            <div class="my-hand" id="my-hand"></div>
        </div>
    </div>

    <script>
        /* --- UTILS --- */
        const $ = id => document.getElementById(id);
        const CARD_BACK_SVG = "data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h20v20H0z' fill='%231a283a'/%3E%3Cpath d='M10 0l10 10-10 10L0 10z' fill='%23c5a059' fill-opacity='0.15'/%3E%3C/svg%3E";
        
        // Card Image API Helper
        const getCardUrl = (r, s) => `https://deckofcardsapi.com/static/img/${r}${s}.png`;
        const SUITS = ['S','C','H','D']; 
        const RANKS = ['6','7','8','9','0','J','Q','K','A'];

        /* --- ENGINE (GAME LOGIC) --- */
        class Engine {
            constructor(hostName, hostAva, mode, transfer) {
                this.mode = mode;
                this.transfer = transfer;
                this.players = [{id:'host', name:hostName, ava:hostAva, hand:[]}];
                this.deck = [];
                this.trump = null;
                this.field = []; // {att, def, fromIdx}
                this.turn = 0; // attacker index
                this.bitoCount = 0;
                this.state = 'lobby';
                this.win = null;
                this.turnStart = 0;
            }

            addPlayer(id, name, ava) {
                if(this.players.length >= this.mode) return false;
                this.players.push({id, name, ava, hand:[]});
                return true;
            }

            start() {
                this.deck = [];
                SUITS.forEach(s => RANKS.forEach(r => this.deck.push({r, s})));
                this.deck.sort(() => Math.random() - 0.5);
                
                // Deal
                this.players.forEach(p => p.hand = this.deck.splice(0,6));
                this.trump = this.deck.pop();
                this.deck.unshift(this.trump); // Trump is at index 0 (bottom)

                // Find first attacker (lowest trump)
                let minRank=100, firstP=0;
                this.players.forEach((p,i) => {
                    p.hand.forEach(c => {
                        if(c.s===this.trump.s && RANKS.indexOf(c.r)<minRank) {
                            minRank = RANKS.indexOf(c.r); firstP=i;
                        }
                    });
                });
                this.turn = firstP;
                this.state = 'game';
                this.turnStart = Date.now();
            }

            nextP(off=1) { return (this.turn + off) % this.mode; }
            
            beat(att, def) {
                if(att.s === def.s) return RANKS.indexOf(def.r) > RANKS.indexOf(att.r);
                return def.s === this.trump.s;
            }

            move(pidx, type, data) {
                if(this.state !== 'game') return false;
                const p = this.players[pidx];
                const defIdx = this.nextP();
                const defP = this.players[defIdx];

                // ATTACK
                if(type === 'ATTACK') {
                    // Check if legitimate attacker
                    const isMainAtt = (pidx === this.turn);
                    const isThrowIn = (pidx !== this.turn && pidx !== defIdx); // In 3 player, 3rd can throw in
                    
                    if(!isMainAtt && !isThrowIn) return false;
                    
                    // Transfer logic
                    const isTransfer = (this.transfer && pidx === defIdx && this.field.length > 0 && this.field.every(s => !s.def));
                    if(pidx === defIdx && !isTransfer) return false; // Defender can't attack unless transfer

                    const c = p.hand[data.idx];
                    if(!c) return false;

                    // Rank Check if field not empty
                    if(this.field.length > 0) {
                        const allRanks = new Set(this.field.flatMap(x => [x.att.r, x.def?.r].filter(Boolean)));
                        if(!allRanks.has(c.r)) return false;
                    }

                    // Limit check
                    const maxCards = 6; // Standard limit
                    const defenderHandSize = defP.hand.length;
                    const freeSlots = this.field.filter(x => !x.def).length;
                    
                    // If transfer, target becomes next
                    let targetHand = defenderHandSize;
                    if(isTransfer) {
                        const nextGuy = this.players[(pidx+1)%this.mode];
                        targetHand = nextGuy.hand.length;
                    }

                    if(!isTransfer && (freeSlots + 1 > targetHand || this.field.length >= 6)) return false;
                    
                    // Execute
                    p.hand.splice(data.idx, 1);
                    this.field.push({att: c, def: null, from: pidx});
                    
                    if(isTransfer) {
                        this.turn = pidx; // Current defender becomes attacker against next
                        this.turnStart = Date.now();
                    }
                    return true;
                }

                // DEFEND
                if(type === 'DEFEND') {
                    if(pidx !== defIdx) return false;
                    const slot = this.field[data.slot];
                    if(!slot || slot.def) return false;
                    const c = p.hand[data.idx];
                    
                    if(this.beat(slot.att, c)) {
                        p.hand.splice(data.idx, 1);
                        slot.def = c;
                        return true;
                    }
                }

                // BITO
                if(type === 'BITO') {
                    if(pidx !== this.turn) return false; // Only main attacker says bito first usually, simplified here
                    if(this.field.length===0 || this.field.some(x=>!x.def)) return false;
                    
                    this.bitoCount += this.field.length;
                    this.field = [];
                    this.refillHands();
                    this.turn = this.nextP();
                    this.turnStart = Date.now();
                    return true;
                }

                // TAKE
                if(type === 'TAKE') {
                    if(pidx !== defIdx) return false;
                    this.field.forEach(s => {
                        p.hand.push(s.att);
                        if(s.def) p.hand.push(s.def);
                    });
                    this.field = [];
                    this.refillHands(true); // Skip defender refill
                    let next = this.nextP(2); // Skip defender turn
                    if(this.mode===2) next = this.nextP(1); // In 2p, attacker goes again
                    this.turn = next;
                    this.turnStart = Date.now();
                    return true;
                }
                return false;
            }

            refillHands(skipDefender=false) {
                const order = [];
                for(let i=0; i<this.mode; i++) order.push((this.turn + i) % this.mode);
                
                order.forEach(idx => {
                    if(skipDefender && idx === this.nextP()) return;
                    const p = this.players[idx];
                    while(p.hand.length < 6 && this.deck.length > 0) {
                        p.hand.push(this.deck.pop());
                    }
                });

                // Win Check
                this.players.forEach(p => {
                    if(p.hand.length===0 && this.deck.length===0 && !this.win) this.win = p.name;
                });
            }

            getState() {
                return {
                    dCount: this.deck.length,
                    trump: this.trump,
                    field: this.field,
                    turn: this.turn,
                    bito: this.bitoCount,
                    ts: this.turnStart,
                    win: this.win,
                    players: this.players.map(p => ({
                        id: p.id, name: p.name, ava: p.ava, cards: p.hand.length
                    }))
                };
            }
        }

        /* --- ANIMATION MANAGER --- */
        const Animator = {
            fly(cardObj, fromRect, toRect, delay=0) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        const el = document.createElement('div');
                        el.className = 'card flying-card';
                        el.style.backgroundImage = `url(${getCardUrl(cardObj.r, cardObj.s)})`;
                        el.style.width = getComputedStyle(document.documentElement).getPropertyValue('--card-w');
                        el.style.height = getComputedStyle(document.documentElement).getPropertyValue('--card-h');
                        
                        // Set start position
                        el.style.left = fromRect.left + 'px';
                        el.style.top = fromRect.top + 'px';
                        $('anim-layer').appendChild(el);

                        // Force reflow
                        el.getBoundingClientRect();

                        // Animate to end
                        el.style.transform = `translate(${toRect.left - fromRect.left}px, ${toRect.top - fromRect.top}px)`;

                        // Cleanup
                        setTimeout(() => {
                            el.remove();
                            resolve();
                        }, 600); // match css transition
                    }, delay);
                });
            },

            // Generate random rotation for Bito pile
            getBitoTransform() {
                const r = Math.random() * 40 - 20;
                const x = Math.random() * 10 - 5;
                const y = Math.random() * 10 - 5;
                return `translate(${x}px, ${y}px) rotate(${r}deg)`;
            }
        };

        /* --- GAME CONTROLLER --- */
        const Game = {
            role: null,
            eng: null, // Host only
            peer: null,
            conns: [], // Host
            conn: null, // Client
            myId: null,
            state: null,
            hand: [],
            sel: null,
            lastBito: 0,

            initHost(name, ava, mode, tr) {
                this.role = 'host';
                this.eng = new Engine(name, ava, mode, tr);
                this.peer = new Peer();
                
                this.peer.on('open', id => {
                    $('panel-create').classList.add('hidden');
                    $('panel-wait').classList.remove('hidden');
                    $('host-id').value = id;
                });

                this.peer.on('connection', c => {
                    c.on('open', () => {
                        this.conns.push(c);
                        this.broadcastState(); // Send immediate state so they know phase
                    });
                    c.on('data', d => this.handleData(d, c.peer));
                    c.on('close', () => location.reload()); // Simple disconnect handling
                });
            },

            initClient(name, ava, hostId) {
                this.role = 'client';
                this.peer = new Peer();
                this.peer.on('open', myPeerId => {
                    this.conn = this.peer.connect(hostId);
                    this.conn.on('open', () => {
                        this.conn.send({t:'JOIN', n:name, a:ava});
                        $('panel-create').classList.add('hidden');
                        $('panel-wait').classList.remove('hidden');
                        $('panel-wait').innerHTML = '<h2 style="margin-top:50px;">Подключение...</h2>';
                    });
                    this.conn.on('data', d => this.handleData(d));
                    this.conn.on('close', () => alert('Host Disconnected'));
                });
            },

            handleData(d, senderId) {
                // HOST LOGIC
                if(this.role === 'host') {
                    if(d.t === 'JOIN') {
                        if(this.eng.addPlayer(senderId, d.n, d.a)) {
                            $('wait-count').innerText = `${this.eng.players.length}/${this.eng.mode}`;
                            
                            // Send Chat System Msg
                            const msg = {t:'CHAT', n:'INFO', m:`${d.n} joined`, sys:true};
                            UI.addChat(msg);
                            this.broadcast(msg);

                            if(this.eng.players.length === this.eng.mode) {
                                this.eng.start();
                                $('lobby').style.display = 'none';
                                $('game').style.display = 'block';
                                this.broadcastState();
                            }
                        }
                    }
                    if(d.t === 'ACT') {
                        const pIdx = this.eng.players.findIndex(p=>p.id===senderId);
                        if(pIdx !== -1) {
                            if(this.eng.move(pIdx, d.a, d.d)) {
                                // Action Successful - Animation Trigger?
                                // For simplicity, we just sync state. 
                                // Advanced: Send 'ANIM' event before state.
                                this.broadcastState();
                            }
                        }
                    }
                    if(d.t === 'CHAT') {
                        // Re-broadcast
                        const p = this.eng.players.find(x=>x.id===senderId);
                        const msg = {t:'CHAT', n:p?p.name:'?', m:d.m, id:senderId};
                        UI.addChat(msg);
                        this.broadcast(msg);
                    }
                } 
                // CLIENT LOGIC
                else {
                    if(d.t === 'STATE') {
                        $('lobby').style.display = 'none';
                        $('game').style.display = 'block';
                        this.state = d.s;
                        this.hand = d.h;
                        this.myId = d.mid;
                        UI.render(this.state);
                    }
                    if(d.t === 'CHAT') UI.addChat(d);
                }
            },

            broadcastState() {
                const s = this.eng.getState();
                // Set host state locally
                this.state = s;
                this.hand = this.eng.players[0].hand;
                this.myId = 'host';
                UI.render(s);

                // Send to clients (filtered hand)
                this.conns.forEach(c => {
                    const p = this.eng.players.find(x=>x.id===c.peer);
                    c.send({t:'STATE', s:s, h:p?p.hand:[], mid:c.peer});
                });
            },

            broadcast(msg) {
                this.conns.forEach(c => c.send(msg));
            },

            // Actions
            act(type, data={}) {
                if(this.role === 'host') {
                    if(this.eng.move(0, type, data)) this.broadcastState();
                } else {
                    this.conn.send({t:'ACT', a:type, d:data});
                }
            },

            doAction() {
                const s = this.state;
                if(!s) return;
                const myIdx = s.players.findIndex(p=>p.id===this.myId);
                const isAttacker = (s.turn === myIdx);
                const isDefender = ((s.turn+1)%s.players.length === myIdx);
                
                // Logic to determine button function
                if(isAttacker) {
                    // Bito
                    this.act('BITO');
                } else {
                    // Take
                    this.act('TAKE');
                }
            },

            sendChat() {
                const el = $('chat-in');
                const txt = el.value.trim();
                if(!txt) return;
                
                if(this.role==='host') {
                    const me = this.eng.players[0];
                    const msg = {t:'CHAT', n:me.name, m:txt, id:'host'};
                    UI.addChat(msg); // Add locally
                    this.broadcast(msg); // Send to others (NO DUPE)
                } else {
                    this.conn.send({t:'CHAT', m:txt});
                }
                el.value = '';
            }
        };

        /* --- UI RENDERER --- */
        const UI = {
            prevFieldLen: 0,
            
            createGame() {
                const name = $('p-name').value || 'Host';
                const ava = document.querySelector('.ava-opt.selected')?.dataset.id || 1;
                const mode = parseInt(document.querySelector('input[name="mode"]:checked').value);
                const tr = $('chk-transfer').checked;
                Game.initHost(name, ava, mode, tr);
            },

            joinGame() {
                const name = $('p-name').value || 'Player';
                const ava = document.querySelector('.ava-opt.selected')?.dataset.id || 1;
                const id = $('join-id').value;
                if(id) Game.initClient(name, ava, id);
            },

            addChat(d) {
                const log = $('chat-log');
                const div = document.createElement('div');
                const isMe = (d.id === Game.myId);
                div.className = `chat-msg ${d.sys?'sys':''} ${isMe?'me':''}`;
                
                if(d.sys) div.innerHTML = d.m;
                else div.innerHTML = `<b>${d.n}:</b> ${d.m}`;
                
                log.appendChild(div);
                if(log.childElementCount > 5) {
                    log.removeChild(log.firstChild);
                }
            },

            render(s) {
                if(s.win) {
                    alert(`Победитель: ${s.win}`);
                    location.reload();
                    return;
                }

                // 1. Calculate relative indices
                const players = s.players;
                let myIdx = players.findIndex(p => p.id === Game.myId);
                if(myIdx === -1) myIdx = 0; // Fallback

                // 2. Opponents (Top Row)
                const oppCont = $('opponents-container');
                oppCont.innerHTML = '';
                
                // Iterate others
                for(let i=1; i<players.length; i++) {
                    const idx = (myIdx + i) % players.length;
                    const p = players[idx];
                    const isTurn = (s.turn === idx);

                    const node = document.createElement('div');
                    node.className = `player-node ${s.win ? 'inactive' : ''}`;
                    node.id = `pl-node-${idx}`; // For animation coords
                    
                    // Card pips
                    let pips = '';
                    for(let k=0; k<Math.min(p.cards, 6); k++) pips += '<div class="mini-card-icon"></div>';
                    if(p.cards>6) pips += `<span style="font-size:10px;">+${p.cards-6}</span>`;

                    node.innerHTML = `
                        <div class="ava-wrap">
                            <img src="https://robohash.org/${p.ava}.png?set=set4" class="ava-img">
                            <svg class="timer-svg" style="opacity:${isTurn?1:0}">
                                <circle class="timer-circle" cx="37" cy="37" r="32"></circle>
                            </svg>
                        </div>
                        <div class="p-name" style="color:${isTurn?'var(--gold)':'#ccc'}">${p.name}</div>
                        <div class="p-cards-cnt">${pips}</div>
                    `;
                    
                    if(isTurn) this.runTimer(node.querySelector('.timer-circle'), s.ts);
                    oppCont.appendChild(node);
                }

                // 3. Deck & Trump
                $('deck-count').innerText = `${s.dCount} Карт`;
                const deckStack = $('deck-stack');
                deckStack.innerHTML = '';
                if(s.dCount > 0) {
                    // Trump
                    if(s.trump) {
                        const tr = document.createElement('div');
                        tr.className = 'card trump-card';
                        tr.style.backgroundImage = `url(${getCardUrl(s.trump.r, s.trump.s)})`;
                        deckStack.appendChild(tr);
                    }
                    // Stack visual
                    for(let i=0; i<Math.min(s.dCount, 5); i++) {
                        const c = document.createElement('div');
                        c.className = 'card-stack-item';
                        c.style.top = `${-i*2}px`; c.style.left = `${-i}px`;
                        deckStack.appendChild(c);
                    }
                }

                // 4. Bito (Discard) - Only add new cards visually to prevent flickering pile
                // In a real sophisticated engine we'd track IDs. Here, we just refill if count changes drastically
                const bitoStack = $('bito-stack');
                // Simple visual logic: if bito count grew, add visual cards
                // We don't clear bitoStack to keep rotation. Only clear on new game.
                const currentVis = bitoStack.childElementCount;
                if(s.bito > 0 && currentVis < Math.min(s.bito, 10)) {
                    // Add some debris
                    for(let i=currentVis; i<Math.min(s.bito, 10); i++) {
                        const c = document.createElement('div');
                        c.className = 'card-stack-item';
                        c.style.transform = Animator.getBitoTransform();
                        bitoStack.appendChild(c);
                    }
                }
                if(s.bito === 0) bitoStack.innerHTML = ''; // New round

                // 5. Field Slots
                const slotCont = $('slots-container');
                slotCont.innerHTML = '';
                
                s.field.forEach((slot, si) => {
                    const d = document.createElement('div');
                    d.className = 'slot';
                    d.id = `slot-${si}`;

                    // Attack Card
                    if(slot.att) {
                        const c = document.createElement('div');
                        c.className = 'card att';
                        c.style.backgroundImage = `url(${getCardUrl(slot.att.r, slot.att.s)})`;
                        d.appendChild(c);
                    }

                    // Defense Card
                    if(slot.def) {
                        const c = document.createElement('div');
                        c.className = 'card def';
                        c.style.backgroundImage = `url(${getCardUrl(slot.def.r, slot.def.s)})`;
                        d.appendChild(c);
                    } else {
                        // Interaction: If I am defender and selected a card
                        const isDef = ((s.turn+1)%players.length === myIdx);
                        if(isDef && Game.sel !== null) {
                            d.classList.add('active-target');
                            d.onclick = () => {
                                Game.act('DEFEND', {idx: Game.sel, slot: si});
                                Game.sel = null;
                            };
                        }
                    }
                    slotCont.appendChild(d);
                });

                // 6. My Hand
                const handCont = $('my-hand');
                handCont.innerHTML = '';
                const isMyTurn = (s.turn === myIdx);
                const defIdx = (s.turn + 1) % players.length;
                const isDefender = (defIdx === myIdx);
                const canTransfer = (isDefender && s.field.length > 0 && s.field.every(x=>!x.def));
                
                Game.hand.forEach((c, i) => {
                    const wrap = document.createElement('div');
                    wrap.className = 'my-card-wrap' + (Game.sel===i ? ' selected' : '');
                    wrap.innerHTML = `<div class="card" style="background-image:url('${getCardUrl(c.r,c.s)}')"></div>`;
                    
                    wrap.onclick = () => {
                        if(isMyTurn) {
                            Game.act('ATTACK', {idx: i});
                        } else if(canTransfer) {
                             Game.act('ATTACK', {idx: i}); // Transfer is technically an attack on next player
                        } else if(isDefender) {
                            // Select for defense
                            Game.sel = (Game.sel===i ? null : i);
                            UI.render(s); // Re-render to show selection/targets
                        }
                    };
                    handCont.appendChild(wrap);
                });

                // 7. Status & Buttons
                const statusTxt = $('status-text');
                const btn = $('btn-action');
                btn.classList.add('hidden');
                
                statusTxt.style.borderLeftColor = "#555";
                
                if(isMyTurn) {
                    statusTxt.innerText = "ВАШ ХОД";
                    statusTxt.style.borderLeftColor = "var(--gold)";
                    // Check if can Bito
                    if(s.field.length > 0 && s.field.every(x=>x.def)) {
                        btn.classList.remove('hidden');
                        btn.innerText = "БИТО";
                        btn.className = "btn"; 
                    }
                } else if (isDefender) {
                    statusTxt.innerText = canTransfer ? "ОТБЕЙ ИЛИ ПЕРЕВЕДИ" : "ОТБИВАЙТЕСЬ";
                    statusTxt.style.borderLeftColor = "#d32f2f";
                    if(s.field.some(x=>!x.def)) {
                        btn.classList.remove('hidden');
                        btn.innerText = "ВЗЯТЬ";
                        btn.className = "btn btn-sec";
                    }
                } else {
                    statusTxt.innerText = `Ходит: ${players[s.turn].name}`;
                }
            },

            runTimer(circle, startTs) {
                const duration = 30000;
                const tick = () => {
                    const elapsed = Date.now() - startTs;
                    const pct = Math.max(0, 1 - (elapsed / duration));
                    circle.style.strokeDashoffset = 200 * (1 - pct);
                    if(pct > 0) requestAnimationFrame(tick);
                };
                tick();
            }
        };

        /* --- INIT --- */
        // Avatar selection logic
        const avaList = $('ava-list');
        for(let i=1; i<=5; i++) {
            const d = document.createElement('div');
            d.className = 'ava-opt' + (i===1?' selected':'');
            d.dataset.id = i;
            d.style.backgroundImage = `url('https://robohash.org/${i}.png?set=set4')`;
            d.onclick = () => {
                document.querySelectorAll('.ava-opt').forEach(x => x.classList.remove('selected'));
                d.classList.add('selected');
            };
            avaList.appendChild(d);
        }

        $('chat-in').addEventListener('keypress', e => { if(e.key==='Enter') Game.sendChat(); });

    </script>
</body>
</html>
