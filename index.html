<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Дурак Онлайн</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700;900&display=swap');

        :root {
            --card-w: 110px;
            --card-h: 154px;
            --radius: 8px;
            --bg-dark: #0d1b2a;
            --bg-felt: #1b3a57; /* Глубокий синий */
            --accent: #ffc107;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; outline: none; }
        
        body {
            margin: 0;
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-dark);
            /* Текстура сукна */
            background-image: 
                radial-gradient(circle at center, #274b6e 0%, #0d1b2a 100%),
                url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.05'/%3E%3C/svg%3E");
            height: 100vh;
            overflow: hidden;
            display: flex; flex-direction: column;
            color: #fff;
        }

        /* --- UI LAYER --- */
        #lobby {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(13, 27, 42, 0.95);
            z-index: 9999;
            display: flex; align-items: center; justify-content: center;
            backdrop-filter: blur(10px);
        }
        .panel {
            background: #fff; color: #222;
            padding: 30px; border-radius: 16px;
            width: 90%; max-width: 400px; text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }
        .panel h1 { margin: 0 0 20px; font-weight: 900; color: #1b3a57; text-transform: uppercase; }
        
        .inp {
            width: 100%; padding: 12px; margin: 10px 0;
            border: 2px solid #ddd; border-radius: 8px;
            font-size: 16px; font-weight: bold; text-align: center;
        }
        .btn {
            width: 100%; padding: 14px; border: none; margin-top: 10px;
            font-size: 16px; font-weight: 900; text-transform: uppercase;
            cursor: pointer; border-radius: 8px; color: white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .btn-create { background: #2e7d32; }
        .btn-join { background: #1565c0; }

        .avatars { display: flex; gap: 10px; justify-content: center; margin-bottom: 20px; }
        .ava-opt {
            width: 50px; height: 50px; border: 2px solid #eee; cursor: pointer;
            background-size: cover; border-radius: 12px; /* Скругленный квадрат */
            background-color: #ddd; transition: 0.2s;
        }
        .ava-opt.selected { border-color: var(--accent); transform: scale(1.1); box-shadow: 0 0 0 2px var(--accent); }

        /* --- GAME FIELD --- */
        #game { display: none; flex-direction: column; height: 100%; position: relative; }

        /* Top Bar: Opponents */
        .opponents-row {
            height: 140px; width: 100%;
            display: flex; justify-content: center; align-items: flex-start;
            padding-top: 10px; gap: 20px; z-index: 50;
        }
        .player-wrap { position: relative; width: 80px; display: flex; flex-direction: column; align-items: center; }
        .p-name { 
            font-size: 12px; font-weight: bold; 
            background: rgba(0,0,0,0.6); padding: 2px 8px; border-radius: 4px; 
            margin-bottom: 4px; max-width: 90px; overflow: hidden; text-overflow: ellipsis; 
            white-space: nowrap;
        }
        .avatar-box { position: relative; width: 54px; height: 54px; }
        .avatar { 
            width: 100%; height: 100%; background: #333; 
            border: 2px solid #ccc; border-radius: 12px; /* Квадрат */
            object-fit: cover; box-shadow: 0 4px 8px rgba(0,0,0,0.5); 
        }
        .avatar.turn { border-color: #4caf50; box-shadow: 0 0 0 3px #4caf50; }
        
        .card-count-badge {
            position: absolute; bottom: -10px; right: -5px;
            background: #333; color: white; font-size: 11px; font-weight: bold;
            padding: 2px 6px; border-radius: 10px; border: 1px solid #777; z-index: 20;
        }

        /* Center Table */
        .table-area { 
            flex: 1; position: relative; width: 100%; 
            /* Зона для дропа карт */
        }
        
        .deck-pos { position: absolute; left: 20px; top: 50%; transform: translateY(-50%); width: var(--card-w); height: var(--card-h); }
        .trump-card { 
            position: absolute; top: 15px; left: 30px; width: 100%; height: 100%; 
            transform: rotate(90deg); border-radius: var(--radius); 
            box-shadow: 2px 2px 10px rgba(0,0,0,0.3); background-size: cover; 
        }
        .deck-top { 
            position: absolute; top:0; left:0; width: 100%; height: 100%; 
            background: url('https://deckofcardsapi.com/static/img/back.png') center/cover; 
            border-radius: var(--radius); border: 1px solid #aaa; 
            box-shadow: 4px 4px 15px rgba(0,0,0,0.6); 
        }
        .deck-count { 
            position: absolute; top: -25px; left: 0; width: 100%; 
            text-align: center; font-weight: bold; font-size: 16px; opacity: 0.8; 
        }

        .bito-pos { 
            position: absolute; right: 20px; top: 50%; transform: translateY(-50%); 
            width: var(--card-w); height: var(--card-h); 
            border: 2px dashed rgba(255,255,255,0.15); border-radius: var(--radius); 
            display: flex; align-items: center; justify-content: center; 
            color: rgba(255,255,255,0.2); font-weight: bold; letter-spacing: 2px; font-size: 14px;
        }

        /* Slots for Played Cards */
        .slots-wrap {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            flex-wrap: wrap; align-content: center; pointer-events: none;
        }
        .slot-pair { 
            position: relative; width: var(--card-w); height: var(--card-h); margin: 0 10px; 
            pointer-events: auto; /* Чтобы можно было бросить защиту */
        }
        .card-face { 
            width: 100%; height: 100%; position: absolute; border-radius: var(--radius); 
            background-color: #fff; background-size: 100% 100%; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.4); 
        }
        /* Небольшой рандом поворота для реализма */
        .card-att { transform: rotate(-2deg); z-index: 5; }
        .card-def { transform: rotate(5deg) translate(15px, 15px); z-index: 6; }

        /* --- MY HAND (THE FAN) --- */
        .my-zone {
            height: 180px; width: 100%;
            position: relative; z-index: 100;
            display: flex; justify-content: center;
            /* Важно: не скрываем вылеты */
            overflow: visible;
        }
        
        .hand-container {
            position: absolute; bottom: -20px; /* Чуть ниже экрана, чтобы карты торчали */
            width: 100%; height: 200px;
            display: flex; justify-content: center; align-items: flex-end;
        }

        .my-card-wrap {
            position: absolute;
            width: var(--card-w); height: var(--card-h);
            transform-origin: 50% 200%; /* Точка вращения далеко внизу, чтобы был веер */
            bottom: 40px; /* Базовая позиция */
            transition: transform 0.1s ease-out;
            cursor: grab;
            box-shadow: 0 -5px 10px rgba(0,0,0,0.3);
            border-radius: var(--radius);
        }

        /* Ховер эффект: карта всплывает */
        .my-card-wrap:hover {
            z-index: 1000 !important;
            /* Перебиваем transform через JS, но добавляем сдвиг вверх */
            transform: translateX(var(--tx)) rotate(var(--rot)) translateY(-30px) scale(1.1) !important;
        }
        
        .my-card-wrap.dragging {
            z-index: 9999 !important;
            transition: none;
            cursor: grabbing;
            transform: scale(1.1) !important; /* Позиция задается JS */
            box-shadow: 0 20px 50px rgba(0,0,0,0.6);
            pointer-events: none; /* Чтобы событие пролетало сквозь карту на стол */
        }

        /* Chat */
        .chat-container {
            position: absolute; bottom: 10px; left: 10px; width: 250px; z-index: 200;
        }
        .chat-log { 
            height: 150px; overflow-y: auto; display: flex; flex-direction: column; 
            justify-content: flex-end; margin-bottom: 5px; 
            mask-image: linear-gradient(to top, black 80%, transparent 100%);
        }
        .chat-msg { 
            background: rgba(0,0,0,0.5); color: #fff; padding: 4px 8px; 
            margin-top: 4px; border-radius: 4px; font-size: 13px; align-self: flex-start;
        }
        #chat-in { width: 75%; background: rgba(0,0,0,0.5); border: 1px solid #555; color: white; padding: 5px; border-radius: 4px; }
        #chat-btn { width: 20%; background: var(--accent); border: none; border-radius: 4px; cursor: pointer; font-weight: bold; }

        /* Controls */
        .controls { position: absolute; right: 20px; bottom: 200px; z-index: 150; display: flex; flex-direction: column; align-items: flex-end; gap: 10px; }
        .status-badge { background: rgba(0,0,0,0.8); padding: 8px 16px; border-radius: 6px; font-weight: bold; border: 1px solid rgba(255,255,255,0.2); }
        .act-btn { 
            padding: 12px 24px; font-size: 18px; font-weight: 900; text-transform: uppercase; 
            border: none; border-radius: 30px; cursor: pointer; color: white; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); display: none;
        }
        .btn-bito { background: #d32f2f; }
        .btn-take { background: #f57c00; }

        .toast { position: fixed; top: 15%; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); color: white; padding: 10px 20px; border-radius: 20px; z-index: 5000; animation: fade 2s forwards; }
        @keyframes fade { 0%{opacity:0;transform:translate(-50%,20px);} 10%{opacity:1;transform:translate(-50%,0);} 80%{opacity:1;} 100%{opacity:0;} }

        @media (max-width: 700px) {
            :root { --card-w: 80px; --card-h: 112px; }
            .opponents-row { height: 120px; gap: 10px; }
            .chat-container { bottom: 180px; left: 10px; width: 180px; opacity: 0.8; }
            .controls { bottom: 180px; right: 10px; }
            .my-zone { height: 160px; }
        }
    </style>
</head>
<body>
    <div id="lobby">
        <div class="panel" id="p-setup">
            <h1>Дурак Онлайн</h1>
            <div class="avatars" id="ava-list"></div>
            <input type="text" id="p-name" class="inp" placeholder="Ваше Имя" value="Игрок" maxlength="10">
            <div style="margin:15px 0; color:#555;">
                <label><input type="radio" name="mode" value="2" checked> 2 Игрока</label>
                <label><input type="radio" name="mode" value="3"> 3 Игрока</label>
                <label><input type="checkbox" id="chk-transfer" checked style="margin-left:15px;"> Переводной</label>
            </div>
            <button class="btn btn-create" onclick="Lobby.create()">Создать стол</button>
            <div style="margin:10px; font-size:12px; font-weight:bold; color:#777;">ИЛИ</div>
            <input type="text" id="join-id" class="inp" placeholder="ID Комнаты">
            <button class="btn btn-join" onclick="Lobby.join()">Войти</button>
        </div>
        <div class="panel" id="p-wait" style="display:none;">
            <h2>Ждем игроков</h2>
            <input type="text" id="host-id" class="inp" style="background:#eee;" readonly onclick="this.select()">
            <p id="wait-msg" style="font-size:24px; font-weight:bold; color:#1565c0;">1/2</p>
        </div>
    </div>

    <div id="game">
        <div class="opponents-row" id="opponents-area"></div>
        
        <div class="table-area" id="table-drop-zone">
            <div class="deck-pos">
                <div class="deck-count" id="deck-n">36</div>
                <div id="trump-slot"></div>
                <div class="deck-top" id="deck-visual"></div>
            </div>
            <div class="bito-pos">БИТО</div>
            <div class="slots-wrap" id="slots-area"></div>
        </div>

        <div class="controls">
            <div class="status-badge" id="status-txt">...</div>
            <button class="act-btn btn-bito" id="btn-bito" onclick="Game.act('BITO')">Бито</button>
            <button class="act-btn btn-take" id="btn-take" onclick="Game.act('TAKE')">Взять</button>
        </div>

        <div class="chat-container">
            <div class="chat-log" id="chat-log"></div>
            <div style="display:flex; gap:5px;">
                <input id="chat-in" placeholder="Чат...">
                <button id="chat-btn" onclick="Game.sendChat()">➜</button>
            </div>
        </div>

        <div class="my-zone">
            <div class="hand-container" id="my-hand"></div>
        </div>
    </div>

    <script>
        const IMG = (r,s) => `https://deckofcardsapi.com/static/img/${r}${s}.png`;
        const SUITS = ['S','C','H','D'];
        const RANKS = ['6','7','8','9','0','J','Q','K','A'];

        // Sounds
        const Snd = {
            play(t) {
                const s = {
                    'click': 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGl2Y29kZXIgMS4wLjAA//uQZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAZAAACcQADBQoPEhQWGBwfIiQmKCsuMDM2ODs9QEJFRkdJS0xPUFJTVlleYWNlZmhqbG9xdHZ5fH6Ag4WHiYuOkJOVmJqcn6Gkp6qsrrG0tru+wMPEyMvO0NPU1tjc3+Lj5ufq7O/x9Pf5+//uQZAAABp1vXf0wAAjbrWv/pAAAEckm08w01Ikek218w01MAAAp5nJp8/7l63//+5at///5yab///85NMAAAAAAklN/////p5yab//+nmcmn//p5nJp//6ecmm//p5nJpgAAAAACS///+nnJpv//6ecmm//p5yab/+nnJpv/6ecmmAAAAAAJL///6ecmm//p5yab/+nnJpv/6ecmm//p5yacAAABFADwAAAAAAAAA//uQZAAACW0vW/zBwAk2pWu/mDgAAAAAiAAADAAA//uQZAAACW0vW/zBwAk2pWu/mDgAAAAAiAAADAAA//uQZAAACW0vW/zBwAk2pWu/mDgAAAAAiAAADAAA//uQZAAACW0vW/zBwAk2pWu/mDgAAAAAiAAADAAA//uQZAAACW0vW/zBwAk2pWu/mDgAAAAAiAAADAAA//uQZAAACW0vW/zBwAk2pWu/mDgAAAAAiAAADAAA//uQZAAACW0vW/zBwAk2pWu/mDgAAAAAiAAADAAA//uQZAAACW0vW/zBwAk2pWu/mDgAAAAAiAAADAAA//uQZAAACW0vW/zBwAk2pWu/mDgAAAAAiAAADAAA',
                    'card': 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGl2Y29kZXIgMS4wLjAA//uQZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAZAAABsQAFBwoNEhcaHR8jKC0wNTo9QkVJTlFXYWZobG9zdnl9goaLjZKXnZ+iqK6xtri8wcfLztLX29/j5+vv8/f7//uQZAAABllvX/0wAAjLrWv/pAAAEckm08w01Ikek218w01MAAAp5nJp8/7l63//+5at///5yab///85NMAAAAAAklN/////p5yab//+nmcmn//p5nJp//6ecmm//p5yabAAAAAAJL///6ecmm//p5yab/+nnJpv/6ecmm//p5yabAAAAAAJL///6ecmm//p5yab/+nnJpv/6ecmm//p5yacAAABFADwAAAAAAAAA//uQZAAACVEvW/zBwAkyJWv/mDgAAAAAiAAADAAA//uQZAAACVEvW/zBwAkyJWv/mDgAAAAAiAAADAAA//uQZAAACVEvW/zBwAkyJWv/mDgAAAAAiAAADAAA//uQZAAACVEvW/zBwAkyJWv/mDgAAAAAiAAADAAA//uQZAAACVEvW/zBwAkyJWv/mDgAAAAAiAAADAAA//uQZAAACVEvW/zBwAkyJWv/mDgAAAAAiAAADAAA//uQZAAACVEvW/zBwAkyJWv/mDgAAAAAiAAADAAA//uQZAAACVEvW/zBwAkyJWv/mDgAAAAAiAAADAAA//uQZAAACVEvW/zBwAkyJWv/mDgAAAAAiAAADAAA'
                };
                if(s[t]) new Audio(s[t]).play().catch(()=>{});
            }
        };

        // --- LOGIC ENGINE ---
        class Engine {
            constructor(name, ava, mode, trans) {
                this.mode = parseInt(mode);
                this.trans = trans;
                this.players = [{id:'host', name, ava, hand:[]}];
                this.deck = []; this.trump = null; this.field = [];
                this.att = 0; this.def = 1; this.firstBout = true;
                this.state = 'lobby'; this.win = []; this.la = null;
            }
            add(id, name, ava) {
                if(this.players.length >= this.mode) return false;
                this.players.push({id, name, ava, hand:[]});
                return true;
            }
            start() {
                SUITS.forEach(s=>RANKS.forEach(r=>this.deck.push({r,s})));
                this.deck.sort(()=>Math.random()-0.5);
                this.players.forEach(p=>p.hand=this.deck.splice(0,6));
                this.trump = this.deck.pop(); this.deck.unshift(this.trump);
                
                // Find start
                let min=100, f=0;
                this.players.forEach((p,i)=>{
                    p.hand.forEach(c=>{ if(c.s===this.trump.s && RANKS.indexOf(c.r)<min){min=RANKS.indexOf(c.r); f=i;} });
                });
                this.att=f; this.def=(f+1)%this.players.length;
                this.state='game'; this.la={t:'START'};
            }
            move(pi, type, d) {
                if(this.state!=='game') return {ok:false};
                const p = this.players[pi];
                
                if(type==='ATT') {
                    const c = p.hand[d.i];
                    // Attack
                    if(this.field.length===0) {
                        if(pi!==this.att) return {ok:false, r:'Не ваш ход'};
                        p.hand.splice(d.i,1); this.field.push({a:c, d:null, from:pi});
                        this.la={t:'ATT',p:pi}; return {ok:true};
                    }
                    // Throw in / Transfer
                    if(pi===this.def && this.trans && !this.firstBout && this.field.every(x=>!x.d) && this.field[0].a.r===c.r) {
                        // Transfer
                        const next = (this.def+1)%this.players.length;
                        if(this.players[next].hand.length < this.field.length+1) return {ok:false, r:'Мало карт'};
                        p.hand.splice(d.i,1); this.field.push({a:c, d:null, from:pi});
                        this.att=this.def; this.def=next;
                        this.la={t:'TRANS',p:pi}; return {ok:true};
                    }
                    if(pi===this.def) return {ok:false, r:'Себе нельзя'};
                    
                    const ranks = new Set(this.field.flatMap(x=>[x.a.r, x.d?.r].filter(Boolean)));
                    if(!ranks.has(c.r)) return {ok:false, r:'Нет такой карты'};
                    if(this.field.length >= (this.firstBout?5:6)) return {ok:false, r:'Куча полна'};
                    if(this.field.filter(x=>!x.d).length >= this.players[this.def].hand.length) return {ok:false, r:'У него нет карт'};
                    
                    p.hand.splice(d.i,1); this.field.push({a:c, d:null, from:pi});
                    this.la={t:'ATT',p:pi}; return {ok:true};
                }
                if(type==='DEF') {
                    if(pi!==this.def) return {ok:false};
                    const s = this.field[d.si];
                    if(!s || s.d) return {ok:false};
                    const c = p.hand[d.i];
                    let win = (c.s===s.a.s && RANKS.indexOf(c.r)>RANKS.indexOf(s.a.r)) || (c.s===this.trump.s && s.a.s!==this.trump.s);
                    if(!win) return {ok:false, r:'Слабо', bad:true};
                    p.hand.splice(d.i,1); s.d=c;
                    this.la={t:'DEF',p:pi}; return {ok:true};
                }
                if(type==='BITO') {
                    if(pi===this.def || this.field.some(x=>!x.d)) return {ok:false};
                    this.field=[]; this.refill(); this.att=this.def; this.def=(this.att+1)%this.players.length; this.firstBout=false;
                    this.la={t:'BITO',p:pi}; return {ok:true};
                }
                if(type==='TAKE') {
                    if(pi!==this.def) return {ok:false};
                    this.field.forEach(x=>{ p.hand.push(x.a); if(x.d) p.hand.push(x.d); });
                    this.field=[]; this.refill(); this.att=(this.def+1)%this.players.length; this.def=(this.att+1)%this.players.length; this.firstBout=false;
                    this.la={t:'TAKE',p:pi}; return {ok:true};
                }
            }
            refill() {
                for(let i=0;i<this.players.length;i++) {
                    const p = this.players[(this.att+i)%this.players.length];
                    while(p.hand.length<6 && this.deck.length>0) p.hand.push(this.deck.pop());
                }
                this.players.forEach(p=>{ if(!p.hand.length && !this.deck.length && !this.win.includes(p.name)) this.win.push(p.name); });
                if(this.win.length >= this.players.length-1) this.state='end';
            }
            dump() {
                return {
                    dk: this.deck.length, tr: this.trump, f: this.field, 
                    att: this.att, def: this.def, win: this.win, la: this.la,
                    ps: this.players.map(p=>({id:p.id, n:p.name, a:p.ava, c:p.hand.length}))
                };
            }
        }

        // --- CLIENT ---
        const Lobby = {
            ava: 1,
            init() {
                const l = document.getElementById('ava-list');
                [1,2,3,4,5].forEach(i=>{
                    const d=document.createElement('div'); d.className='ava-opt'+(i===1?' selected':'');
                    d.style.backgroundImage=`url('https://robohash.org/${i}.png?set=set4')`;
                    d.onclick=()=>{this.ava=i; Snd.play('click'); document.querySelectorAll('.ava-opt').forEach(x=>x.classList.remove('selected')); d.classList.add('selected');};
                    l.appendChild(d);
                });
            },
            create() {
                Snd.play('click');
                const n = document.getElementById('p-name').value || 'Host';
                const m = document.querySelector('input[name="mode"]:checked').value;
                const tr = document.getElementById('chk-transfer').checked;
                Game.host(n, this.ava, m, tr);
            },
            join() {
                Snd.play('click');
                const n = document.getElementById('p-name').value || 'Guest';
                const id = document.getElementById('join-id').value;
                if(id) Game.client(n, this.ava, id);
            }
        };

        const Game = {
            r: null, eng: null, peer: null, conn: null, conns: [], myId: null, st: null, hand: [], dragging: null,
            
            host(n, a, m, t) {
                this.r = 'host';
                this.eng = new Engine(n, a, m, t);
                this.peer = new Peer();
                this.peer.on('open', id=>{
                    document.getElementById('p-setup').style.display='none';
                    document.getElementById('p-wait').style.display='block';
                    document.getElementById('host-id').value=id;
                });
                this.peer.on('connection', c=>{
                    c.on('open', ()=>{ this.conns.push(c); });
                    c.on('data', d=>this.hD(c,d));
                });
            },
            client(n, a, id) {
                this.r = 'client';
                this.peer = new Peer();
                this.peer.on('open', ()=>{
                    this.conn = this.peer.connect(id);
                    this.conn.on('open', ()=>{ 
                        this.conn.send({t:'J', n, a}); 
                        document.getElementById('p-setup').style.display='none';
                        document.getElementById('p-wait').style.display='block';
                        document.getElementById('wait-msg').innerText = "Ожидание хоста...";
                    });
                    this.conn.on('data', d=>this.hD(null,d));
                });
            },
            hD(c, d) { // Handle Data
                if(this.r==='host') {
                    if(d.t==='J') {
                        if(this.eng.add(c.peer, d.n, d.a)) {
                            document.getElementById('wait-msg').innerText = `${this.eng.players.length}/${this.eng.mode}`;
                            if(this.eng.players.length == this.eng.mode) {
                                this.eng.start(); this.sync();
                            }
                        }
                    }
                    if(d.t==='ACT') {
                        const pi = this.eng.players.findIndex(p=>p.id===c.peer);
                        const res = this.eng.move(pi, d.a, d.d);
                        if(res.ok) this.sync();
                        else if(res.bad) c.send({t:'BAD', i:d.d.i});
                        else c.send({t:'MSG', m:res.r});
                    }
                    if(d.t==='CHAT') this.bc(d, c.peer);
                }
                // Common
                if(d.t==='SYNC') {
                    this.st = d.s; this.hand = d.h; this.myId = d.mid;
                    document.getElementById('lobby').style.display='none';
                    document.getElementById('game').style.display='flex';
                    this.draw();
                    if(d.s.la && d.s.la.t==='ATT') Snd.play('card');
                    if(d.s.la && d.s.la.t==='BITO') Snd.play('card');
                }
                if(d.t==='BAD') {
                     const el = document.querySelectorAll('.my-card-wrap')[d.i];
                     if(el) { el.classList.remove('shake'); void el.offsetWidth; el.classList.add('shake'); }
                }
                if(d.t==='MSG') this.toast(d.m);
                if(d.t==='CHAT') this.addChat(d.n, d.m);
            },
            bc(d, skip) {
                if(this.r==='host') {
                    if(d.t==='CHAT') this.addChat(d.n, d.m);
                    this.conns.forEach(c=>{ if(c.peer!==skip) c.send(d); });
                }
            },
            sync() {
                const s = this.eng.dump();
                this.st = s; this.hand = this.eng.players[0].hand; this.myId = 'host';
                this.draw();
                this.conns.forEach(c=>{
                    const p = this.eng.players.find(x=>x.id===c.peer);
                    c.send({t:'SYNC', s, h:p?p.hand:[], mid:c.peer});
                });
            },
            act(type, d={}) {
                if(this.r==='host') {
                    const res = this.eng.move(0, type, d);
                    if(res.ok) this.sync();
                    else if(res.bad) { 
                        const el = document.querySelectorAll('.my-card-wrap')[d.i];
                        if(el) { el.classList.remove('shake'); void el.offsetWidth; el.classList.add('shake'); }
                    } else this.toast(res.r);
                } else this.conn.send({t:'ACT', a:type, d});
            },
            
            // --- DRAWING ---
            draw() {
                const s = this.st;
                const myIdx = s.ps.findIndex(p=>p.id===this.myId) > -1 ? s.ps.findIndex(p=>p.id===this.myId) : 0;
                
                // Opponents
                const oppDiv = document.getElementById('opponents-area');
                oppDiv.innerHTML = '';
                for(let i=1; i<s.ps.length; i++) {
                    const idx = (myIdx+i)%s.ps.length;
                    const p = s.ps[idx];
                    const isTurn = (s.att===idx || s.def===idx);
                    oppDiv.innerHTML += `
                        <div class="player-wrap">
                            <div class="p-name">${p.n}</div>
                            <div class="avatar-box">
                                <img src="https://robohash.org/${p.a}.png?set=set4" class="avatar ${s.att===idx?'turn':''}" style="border-color:${s.def===idx?'#ff9800':''}">
                                ${p.c>0 ? `<div class="card-count-badge">${p.c}</div>` : ''}
                            </div>
                        </div>`;
                }

                // Table Info
                document.getElementById('deck-n').innerText = s.dk;
                document.getElementById('deck-visual').style.display = s.dk>0?'block':'none';
                const ts = document.getElementById('trump-slot');
                ts.innerHTML = (s.tr && s.dk>0) ? `<div class="trump-card" style="background-image:url('${IMG(s.tr.r, s.tr.s)}')"></div>` : 
                    (s.tr ? `<div style="opacity:0.3; font-size:40px; margin-top:10px; color:white;">${{'S':'♠','C':'♣','H':'♥','D':'♦'}[s.tr.s]}</div>` : '');

                // Slots
                const sl = document.getElementById('slots-area');
                sl.innerHTML = '';
                s.f.forEach((x, i) => {
                    const d = document.createElement('div'); d.className='slot-pair';
                    d.dataset.si = i;
                    d.innerHTML = `<div class="card-face card-att" style="background-image:url('${IMG(x.a.r,x.a.s)}')"></div>`;
                    if(x.d) d.innerHTML += `<div class="card-face card-def" style="background-image:url('${IMG(x.d.r,x.d.s)}')"></div>`;
                    sl.appendChild(d);
                });

                // My Hand (Improved Fan)
                const hDiv = document.getElementById('my-hand');
                hDiv.innerHTML = '';
                const cnt = this.hand.length;
                
                // Рассчет веера
                const arc = 10; // градус между картами
                const totalArc = (cnt-1) * arc;
                const startDeg = -totalArc / 2;

                this.hand.forEach((c, i) => {
                    const w = document.createElement('div');
                    w.className = 'my-card-wrap';
                    
                    const rot = startDeg + (i * arc);
                    // Сдвиг по X зависит от вращения, чтобы края расходились
                    const tx = (i - (cnt-1)/2) * 25; 
                    
                    w.style.setProperty('--rot', rot+'deg');
                    w.style.setProperty('--tx', tx+'px');
                    
                    // Применяем изначальную трансформацию
                    w.style.transform = `translateX(${tx}px) rotate(${rot}deg)`;
                    
                    w.innerHTML = `<div class="card-face" style="background-image:url('${IMG(c.r,c.s)}')"></div>`;
                    
                    // Drag logic
                    w.onmousedown = w.ontouchstart = (e) => this.dragStart(e, w, i);
                    hDiv.appendChild(w);
                });

                // Buttons
                const bB = document.getElementById('btn-bito');
                const bT = document.getElementById('btn-take');
                const st = document.getElementById('status-txt');
                bB.style.display='none'; bT.style.display='none';
                
                if(s.win.length) { st.innerText = s.win[0]+' WIN!'; st.style.background='#ffd700'; st.style.color='#000'; }
                else if(s.att===myIdx) {
                    st.innerText = "ВАШ ХОД"; st.style.borderColor='#4caf50';
                    if(s.f.length && s.f.every(x=>x.d)) bB.style.display='block';
                } else if(s.def===myIdx) {
                    st.innerText = "ОТБИВАЙТЕСЬ"; st.style.borderColor='#ff9800';
                    if(s.f.some(x=>!x.d)) bT.style.display='block';
                } else st.innerText = "ЖДЕМ...";
            },

            // --- DRAG ---
            dragStart(e, el, i) {
                if(this.dragging) return;
                const t = e.touches ? e.touches[0] : e;
                this.dragging = { el, i, sx: t.clientX, sy: t.clientY };
                
                // Читаем текущие вычисленные значения, чтобы не сбросить позицию веера
                const style = window.getComputedStyle(el);
                const matrix = new DOMMatrix(style.transform);
                this.dragging.initialX = matrix.m41; // TranslateX
                this.dragging.initialY = matrix.m42; // TranslateY
                this.dragging.initialRot = el.style.getPropertyValue('--rot');

                el.classList.add('dragging');

                const move = (ev) => {
                    ev.preventDefault();
                    const tt = ev.touches ? ev.touches[0] : ev;
                    const dx = tt.clientX - this.dragging.sx;
                    const dy = tt.clientY - this.dragging.sy;
                    
                    // Сохраняем начальный поворот и позицию X, добавляем смещение мыши
                    el.style.transform = `translate(${this.dragging.initialX + dx}px, ${this.dragging.initialY + dy}px) rotate(${this.dragging.initialRot})`;
                };
                const end = (ev) => {
                    window.removeEventListener('mousemove', move); window.removeEventListener('touchmove', move);
                    window.removeEventListener('mouseup', end); window.removeEventListener('touchend', end);
                    
                    el.classList.remove('dragging');
                    el.style.transform = `translateX(${this.dragging.initialX}px) rotate(${this.dragging.initialRot})`; // Reset
                    
                    // Check Drop
                    const tt = ev.changedTouches ? ev.changedTouches[0] : ev;
                    const drop = document.getElementById('table-drop-zone').getBoundingClientRect();
                    
                    if(tt.clientY < drop.bottom && tt.clientY > drop.top) {
                        const s = this.st;
                        const myIdx = s.ps.findIndex(p=>p.id===this.myId)>-1?s.ps.findIndex(p=>p.id===this.myId):0;
                        if(myIdx===s.def) {
                            // Target specific slot?
                            const slots = document.querySelectorAll('.slot-pair');
                            let si = -1;
                            slots.forEach(sl => {
                                const r = sl.getBoundingClientRect();
                                if(tt.clientX>r.left && tt.clientX<r.right) si = parseInt(sl.dataset.si);
                            });
                            if(si>-1) this.act('DEF', {i, si});
                            else this.act('ATT', {i}); // Try transfer
                        } else {
                            this.act('ATT', {i});
                        }
                    }
                    this.dragging = null;
                };
                window.addEventListener('mousemove', move); window.addEventListener('touchmove', move, {passive:false});
                window.addEventListener('mouseup', end); window.addEventListener('touchend', end);
            },

            sendChat() {
                const i = document.getElementById('chat-in');
                const m = i.value.trim();
                if(!m) return;
                let n = this.r==='host' ? this.eng.players[0].name : 'Я';
                if(this.r==='host') { this.addChat(n,m); this.bc({t:'CHAT', n, m}); }
                else this.conn.send({t:'CHAT', n:this.st.ps.find(p=>p.id===this.myId).n, m});
                i.value='';
            },
            addChat(n,m) {
                const l = document.getElementById('chat-log');
                const d = document.createElement('div'); d.className='chat-msg';
                d.innerHTML = `<b>${n}:</b> ${m}`;
                l.appendChild(d); l.scrollTop = l.scrollHeight;
            },
            toast(m) {
                const d = document.createElement('div'); d.className='toast'; d.innerText=m;
                document.body.appendChild(d); setTimeout(()=>d.remove(),2000);
            }
        };
        Lobby.init();
    </script>
</body>
</html>
