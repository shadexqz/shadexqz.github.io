<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Durak Pro: Immersive Edition</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@700&family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #1a1c20;
            --table-color: #2e4035;
            --accent: #ffb700;
            --text: #ffffff;
            --error: #ff4444;
            --card-w: 110px;
            --card-h: 160px;
            --card-w-sm: 60px;
            --card-h-sm: 85px;
            --radius-ava: 12px; /* SQUARE AVATARS FIX */
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0; padding: 0;
            background: radial-gradient(circle at center, #3a5045 0%, #18201b 100%);
            height: 100vh; overflow: hidden;
            font-family: 'Roboto', sans-serif;
            color: var(--text);
        }

        /* --- UI HELPERS --- */
        .hidden { display: none !important; }
        .btn {
            background: var(--accent); color: #000; border: none;
            padding: 12px 30px; font-size: 18px; font-weight: bold;
            border-radius: 6px; cursor: pointer; text-transform: uppercase;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.95); }
        .btn-red { background: var(--error); color: white; }

        /* --- LOBBY --- */
        #lobby {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.9); z-index: 2000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .panel { 
            background: #222; padding: 30px; border-radius: 12px; 
            text-align: center; border: 1px solid #444; width: 90%; max-width: 400px;
        }
        .inp {
            width: 100%; padding: 12px; margin: 10px 0;
            background: #111; border: 1px solid #444; color: white;
            font-size: 16px; border-radius: 4px; text-align: center;
        }

        /* --- GAME AREA --- */
        #game-layer { width: 100%; height: 100%; position: relative; }

        /* OPPONENTS (Top) */
        .opponents-row {
            display: flex; justify-content: center; gap: 40px;
            padding-top: 20px;
        }
        .player-node {
            position: relative; display: flex; flex-direction: column; align-items: center;
            width: 100px;
        }
        .avatar {
            width: 80px; height: 80px;
            border-radius: var(--radius-ava); /* SQUARE FIX */
            border: 3px solid #444;
            background-size: cover; background-position: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            transition: border-color 0.3s;
            position: relative;
            z-index: 2;
        }
        .avatar.active-turn { border-color: var(--accent); box-shadow: 0 0 20px var(--accent); }
        
        .bubble {
            position: absolute; top: -40px; left: 50%; transform: translateX(-50%);
            background: white; color: black; padding: 5px 12px;
            border-radius: 20px; font-weight: bold; font-size: 14px;
            white-space: nowrap; opacity: 0; pointer-events: none;
            transition: opacity 0.3s, transform 0.3s;
            z-index: 10;
        }
        .bubble.show { opacity: 1; transform: translateX(-50%) translateY(-10px); }
        .bubble::after {
            content: ''; position: absolute; bottom: -6px; left: 50%; transform: translateX(-50%);
            border-width: 6px 6px 0; border-style: solid; border-color: white transparent transparent transparent;
        }

        /* Opponent Hand (Visible Backs) */
        .opp-hand-counter {
            display: flex; margin-top: -15px; z-index: 1;
        }
        .card-back-icon {
            width: 20px; height: 30px; background: #333; border: 1px solid #fff;
            border-radius: 3px; margin-left: -12px;
            background-image: repeating-linear-gradient(45deg, #606dbc 0, #606dbc 2px, #465298 0, #465298 4px);
            box-shadow: 1px 1px 4px black;
        }
        .card-back-icon:first-child { margin-left: 0; }
        .counter-badge {
            background: var(--accent); color: black; font-size: 12px; font-weight: bold;
            padding: 2px 6px; border-radius: 10px; margin-left: 5px; margin-top: 5px;
        }

        /* CENTER TABLE */
        .table-area {
            position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%);
            width: 100%; max-width: 900px; height: 220px;
            display: flex; justify-content: center; align-items: center;
        }
        
        /* Deck & Bito */
        .deck-slot { position: absolute; left: 20px; width: var(--card-w-sm); height: var(--card-h-sm); }
        .bito-slot { position: absolute; right: 20px; width: var(--card-w-sm); height: var(--card-h-sm); border: 2px dashed rgba(255,255,255,0.2); border-radius: 6px; }
        .bito-text { position: absolute; top:50%; left:50%; transform: translate(-50%,-50%); opacity: 0.3; font-weight: bold; }

        .deck-card {
            position: absolute; width: 100%; height: 100%;
            background-image: url('https://deckofcardsapi.com/static/img/back.png');
            background-size: cover; border-radius: 5px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }
        .trump-card {
            position: absolute; width: 100%; height: 100%;
            background-size: cover; border-radius: 5px;
            transform: rotate(90deg) translateX(20px); z-index: -1;
        }

        /* Battle Slots */
        .slots-container {
            display: flex; gap: 15px; perspective: 1000px;
        }
        .slot {
            width: var(--card-w); height: var(--card-h);
            background: rgba(0,0,0,0.2); border-radius: 8px;
            position: relative;
        }
        
        /* CARDS */
        .card {
            width: var(--card-w); height: var(--card-h);
            position: absolute;
            background-size: 100% 100%; background-repeat: no-repeat;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.2s;
        }
        /* Overlap Fix */
        .card.atk { top: 0; left: 0; z-index: 5; }
        .card.def { 
            top: 15px; left: 15px; z-index: 10; 
            transform: rotate(8deg); /* Visual Overlap */
        }
        .slot.highlight { box-shadow: 0 0 15px var(--accent); cursor: pointer; }

        /* PLAYER HAND (My Cards) - FIXED: Large & Bottom */
        .my-hand-container {
            position: absolute; bottom: -20px; left: 0; width: 100%;
            height: 180px;
            display: flex; justify-content: center; align-items: flex-end;
            overflow: visible; z-index: 100;
        }
        .hand-card-wrap {
            width: 60px; height: 100%; position: relative;
            transition: width 0.3s, transform 0.3s;
            cursor: pointer;
        }
        .hand-card-wrap:hover { width: 120px; transform: translateY(-30px); z-index: 1000; }
        .hand-card-wrap .card {
            width: 140px; height: 200px; /* HUGE CARDS */
            top: auto; bottom: 0; left: 50%; transform: translateX(-50%);
            box-shadow: -5px 0 15px rgba(0,0,0,0.5);
        }
        .hand-card-wrap.selected .card {
            bottom: 40px; box-shadow: 0 0 0 4px var(--accent);
        }

        /* ANIMATION LAYER */
        #anim-layer {
            position: fixed; top:0; left:0; width:100%; height:100%; 
            pointer-events: none; z-index: 9999;
        }
        .flying-card {
            position: absolute; width: var(--card-w); height: var(--card-h);
            background-size: cover; border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transition: transform 0.6s cubic-bezier(0.25, 1, 0.5, 1);
        }

        /* TOAST */
        #toast {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.8);
            background: rgba(0,0,0,0.85); color: white; padding: 20px 40px;
            border-radius: 50px; font-size: 24px; font-weight: bold; pointer-events: none;
            opacity: 0; transition: 0.3s; z-index: 5000;
        }
        #toast.shake { animation: shake 0.4s ease-in-out; border: 2px solid var(--error); color: var(--error); }
        @keyframes shake { 0%,100%{transform:translate(-50%,-50%) translateX(0);} 25%{transform:translate(-50%,-50%) translateX(-10px);} 75%{transform:translate(-50%,-50%) translateX(10px);} }

        /* ACTION BUTTONS */
        .actions {
            position: absolute; bottom: 220px; right: 20px;
            display: flex; flex-direction: column; gap: 10px; align-items: flex-end;
        }

        /* Responsive */
        @media(max-width: 600px) {
            :root { --card-w: 70px; --card-h: 100px; }
            .opponents-row { gap: 15px; }
            .avatar { width: 50px; height: 50px; }
            .slots-container { gap: 5px; }
            .hand-card-wrap .card { width: 90px; height: 130px; }
            .hand-card-wrap { width: 35px; }
            .hand-card-wrap:hover { width: 70px; transform: translateY(-20px); }
            .table-area { width: 100%; top: 40%; }
        }
    </style>
</head>
<body>

    <!-- LOBBY -->
    <div id="lobby">
        <div class="panel" id="panel-start">
            <h1 style="color:var(--accent); margin:0 0 20px;">DURAK ELITE</h1>
            <input id="p-name" class="inp" placeholder="Enter Name" maxlength="10" value="Player">
            <div style="margin: 20px 0;">
                <button class="btn" onclick="Game.host()">Create Table</button>
            </div>
            <div style="border-top: 1px solid #444; padding-top:20px;">
                <input id="join-id" class="inp" placeholder="Room ID">
                <button class="btn" style="background:#555; color:white;" onclick="Game.join()">Join Table</button>
            </div>
        </div>
        <div class="panel hidden" id="panel-wait">
            <h2>Waiting for Players...</h2>
            <p style="color:#aaa">Share this ID:</p>
            <input id="host-id-disp" class="inp" readonly onclick="this.select()" style="font-family:monospace; font-size:20px; color:var(--accent);">
            <p id="wait-status">1/2 Players</p>
        </div>
    </div>

    <!-- GAME UI -->
    <div id="game-layer" class="hidden">
        <div class="opponents-row" id="opponents">
            <!-- Opponent Nodes Render Here -->
        </div>

        <div class="table-area">
            <div class="deck-slot">
                <div class="trump-card" id="trump-visual"></div>
                <div class="deck-card"></div>
                <div style="position:absolute; bottom:-25px; width:100%; text-align:center; color:#888;" id="deck-count">36</div>
            </div>
            
            <div class="slots-container" id="slots">
                <!-- Battle Slots -->
            </div>

            <div class="bito-slot" id="bito-area">
                <span class="bito-text">BITO</span>
            </div>
        </div>

        <div class="actions">
            <button id="btn-action" class="btn hidden" onclick="Game.doAction()">Action</button>
        </div>

        <div class="my-hand-container" id="my-hand">
            <!-- My Cards -->
        </div>

        <div id="toast">Invalid Move</div>
        <div id="anim-layer"></div>
    </div>

    <script>
        // --- CONSTANTS & HELPERS ---
        const $ = id => document.getElementById(id);
        const SUITS = ['H', 'D', 'C', 'S'];
        const RANKS = ['6', '7', '8', '9', '0', 'J', 'Q', 'K', 'A'];
        const RANK_VAL = { '6':6, '7':7, '8':8, '9':9, '0':10, 'J':11, 'Q':12, 'K':13, 'A':14 };
        
        const getCardImg = (r, s) => `https://deckofcardsapi.com/static/img/${r}${s}.png`;
        const getBackImg = () => `https://deckofcardsapi.com/static/img/back.png`;

        // --- ANIMATION ENGINE ---
        const Anim = {
            fly: (fromRect, toRect, imgUrl, delay=0) => {
                return new Promise(resolve => {
                    setTimeout(() => {
                        const el = document.createElement('div');
                        el.className = 'flying-card';
                        el.style.backgroundImage = `url(${imgUrl})`;
                        // Set Start
                        el.style.left = fromRect.left + 'px';
                        el.style.top = fromRect.top + 'px';
                        el.style.width = fromRect.width + 'px';
                        el.style.height = fromRect.height + 'px';
                        $('anim-layer').appendChild(el);

                        // Force Reflow
                        el.getBoundingClientRect();

                        // Set End
                        el.style.transform = `translate(${toRect.left - fromRect.left}px, ${toRect.top - fromRect.top}px)`;
                        // Match size of target if needed, but for now fixed size is safer for flight
                        
                        setTimeout(() => {
                            el.remove();
                            resolve();
                        }, 600);
                    }, delay);
                });
            },
            
            toast: (msg, isError=false) => {
                const t = $('toast');
                t.innerText = msg;
                t.style.opacity = '1';
                t.style.transform = 'translate(-50%, -50%) scale(1)';
                if(isError) t.classList.add('shake');
                else t.classList.remove('shake');
                
                setTimeout(() => {
                    t.style.opacity = '0';
                    t.style.transform = 'translate(-50%, -50%) scale(0.8)';
                    t.classList.remove('shake');
                }, 1500);
            },

            bubble: (pIndex, text) => {
                const node = document.getElementById(`p-node-${pIndex}`);
                if(!node) return;
                const b = node.querySelector('.bubble');
                b.innerText = text;
                b.classList.add('show');
                setTimeout(() => b.classList.remove('show'), 2000);
            }
        };

        // --- GAME LOGIC ---
        class DurakEngine {
            constructor() {
                this.deck = [];
                this.players = []; // {id, name, hand: []}
                this.trump = null;
                this.field = []; // {atk: card, def: card, atkId: id}
                this.turn = 0; // Index of attacker
                this.gameState = 'LOBBY';
            }

            initGame(playerList) {
                // Build Deck
                this.deck = [];
                SUITS.forEach(s => RANKS.forEach(r => this.deck.push({r,s})));
                this.deck.sort(() => Math.random() - 0.5);

                this.players = playerList.map(p => ({...p, hand:[]}));
                
                // Deal 6
                this.players.forEach(p => {
                    p.hand = this.deck.splice(0, 6);
                });

                // Trump
                this.trump = this.deck.pop();
                this.deck.unshift(this.trump); // Put at bottom

                // Determine first attacker (lowest trump)
                let minVal = 20;
                let startIdx = 0;
                const trSuit = this.trump.s;
                
                this.players.forEach((p, i) => {
                    p.hand.forEach(c => {
                        if(c.s === trSuit && RANK_VAL[c.r] < minVal) {
                            minVal = RANK_VAL[c.r];
                            startIdx = i;
                        }
                    });
                });

                this.turn = startIdx;
                this.gameState = 'PLAYING';
            }

            get defIdx() { return (this.turn + 1) % this.players.length; }

            canAttack(card, playerId) {
                // If field empty, any card
                if(this.field.length === 0) return true;
                // Else, rank must exist on field
                const ranks = new Set();
                this.field.forEach(s => {
                    ranks.add(s.atk.r);
                    if(s.def) ranks.add(s.def.r);
                });
                return ranks.has(card.r) && this.field.length < 6;
            }

            canDefend(atkCard, defCard) {
                if(atkCard.s === defCard.s) return RANK_VAL[defCard.r] > RANK_VAL[atkCard.r];
                return defCard.s === this.trump.s; // Trump beats non-trump
            }

            processAction(pid, action, data) {
                const pIdx = this.players.findIndex(p => p.id === pid);
                const p = this.players[pIdx];

                if(action === 'ATTACK') {
                    const card = p.hand[data.idx];
                    
                    // Validation
                    const isAttacker = (pIdx === this.turn);
                    const isThrowIn = (pIdx !== this.defIdx); // Simplified throw-in logic for 2p/3p
                    
                    if(!isAttacker && !isThrowIn) return {valid:false};
                    if(!this.canAttack(card, pid)) return {valid:false};
                    if(this.field.filter(x=>!x.def).length >= this.players[this.defIdx].hand.length) return {valid:false}; // Can't attack more than defender has

                    // Execute
                    p.hand.splice(data.idx, 1);
                    this.field.push({atk: card, def: null, atkId: pid});
                    return {valid: true, type: 'ATTACK', card: card, from: pIdx};
                }

                if(action === 'DEFEND') {
                    if(pIdx !== this.defIdx) return {valid:false};
                    const slot = this.field[data.slotIdx];
                    const card = p.hand[data.cardIdx];

                    if(slot.def) return {valid:false}; // Already defended
                    if(!this.canDefend(slot.atk, card)) return {valid:false};

                    // Execute
                    p.hand.splice(data.cardIdx, 1);
                    slot.def = card;
                    return {valid: true, type: 'DEFEND', card: card, slot: data.slotIdx, from: pIdx};
                }

                if(action === 'BITO') {
                    if(pIdx !== this.turn) return {valid:false};
                    if(this.field.some(x => !x.def)) return {valid:false}; // Not all beaten

                    // Clear field
                    this.field = [];
                    this.refillHands();
                    this.turn = (this.turn + 1) % this.players.length; // Defender becomes attacker
                    return {valid: true, type: 'BITO', from: pIdx};
                }

                if(action === 'TAKE') {
                    if(pIdx !== this.defIdx) return {valid:false};

                    // Collect
                    this.field.forEach(s => {
                        p.hand.push(s.atk);
                        if(s.def) p.hand.push(s.def);
                    });
                    this.field = [];
                    this.refillHands(); // Others refill
                    this.turn = (this.turn + 2) % this.players.length; // Skip defender turn
                    return {valid: true, type: 'TAKE', from: pIdx};
                }
                
                return {valid: false};
            }

            refillHands() {
                // Order: Attacker, then others
                const indices = [];
                for(let i=0; i<this.players.length; i++) indices.push((this.turn + i)%this.players.length);
                
                indices.forEach(i => {
                    const p = this.players[i];
                    while(p.hand.length < 6 && this.deck.length > 0) {
                        p.hand.push(this.deck.pop());
                    }
                });
            }

            getState() {
                return {
                    players: this.players.map(p => ({id: p.id, name: p.name, handCount: p.hand.length})),
                    trump: this.trump,
                    field: this.field,
                    deckCount: this.deck.length,
                    turn: this.turn
                };
            }
            
            // For sending private hand data
            getHand(pid) {
                return this.players.find(p=>p.id===pid)?.hand || [];
            }
        }

        // --- CONTROLLER & NETWORK ---
        const Game = {
            peer: null,
            conn: null,
            conns: [], // Host stores connections
            myId: null,
            isHost: false,
            engine: new DurakEngine(),
            state: null,
            myHand: [],
            selection: null, // {idx: 0}

            host: () => {
                Game.isHost = true;
                const name = $('p-name').value;
                Game.peer = new Peer();
                Game.peer.on('open', id => {
                    Game.myId = id;
                    $('panel-start').classList.add('hidden');
                    $('panel-wait').classList.remove('hidden');
                    $('host-id-disp').value = id;
                    Game.engine.players = [{id, name}]; // Add host
                    Game.updateLobbyUI();
                });
                Game.peer.on('connection', c => {
                    Game.conns.push(c);
                    c.on('data', d => Game.handleData(d));
                    c.on('open', () => {
                        // Ask for name
                        c.send({type: 'WELCOME'});
                    });
                });
            },

            join: () => {
                const name = $('p-name').value;
                const hostId = $('join-id').value;
                if(!hostId) return alert("Enter ID");
                
                Game.peer = new Peer();
                Game.peer.on('open', id => {
                    Game.myId = id;
                    Game.conn = Game.peer.connect(hostId);
                    Game.conn.on('open', () => {
                        Game.conn.send({type: 'JOIN', name});
                        $('panel-start').classList.add('hidden');
                        Anim.toast("Connecting...");
                    });
                    Game.conn.on('data', d => Game.handleData(d));
                });
            },

            handleData: (d) => {
                // HOST LOGIC
                if(Game.isHost) {
                    if(d.type === 'JOIN') {
                        Game.engine.players.push({id: Game.conn?.peer || Game.conns.find(c=>c.open)?.peer /* Simplified for demo */, name: d.name}); 
                        // Actually in robust code we map connection to ID properly
                        // For this demo, assuming 2nd player is the new connection
                        const p2 = Game.engine.players[Game.engine.players.length-1];
                        p2.id = d.senderId || p2.id; // Assign ID
                        
                        Game.updateLobbyUI();
                        if(Game.engine.players.length === 2) {
                            Game.engine.initGame(Game.engine.players);
                            Game.broadcastState();
                        }
                    }
                    if(d.type === 'ACTION') {
                        const res = Game.engine.processAction(d.pid, d.act, d.data);
                        if(res.valid) {
                            Game.broadcastState(res); // Send action result for animation
                        } else {
                            // Tell client invalid
                            const conn = Game.conns.find(c=>c.peer === d.pid);
                            if(conn) conn.send({type:'ERROR', msg:'Invalid Move'});
                        }
                    }
                } 
                // CLIENT LOGIC
                else {
                    if(d.type === 'STATE') {
                        Game.state = d.state;
                        Game.myHand = d.hand;
                        if(d.lastAction) Game.handleAnimation(d.lastAction);
                        UI.render();
                        $('lobby').classList.add('hidden');
                        $('game-layer').classList.remove('hidden');
                    }
                    if(d.type === 'ERROR') Anim.toast(d.msg, true);
                }
            },

            broadcastState: (lastAction = null) => {
                // Update local Host
                Game.state = Game.engine.getState();
                Game.myHand = Game.engine.getHand(Game.myId);
                
                if(lastAction) Game.handleAnimation(lastAction);
                UI.render();
                $('lobby').classList.add('hidden');
                $('game-layer').classList.remove('hidden');

                // Send to clients
                Game.conns.forEach(c => {
                    const pHand = Game.engine.getHand(c.peer);
                    c.send({
                        type: 'STATE',
                        state: Game.state,
                        hand: pHand,
                        lastAction
                    });
                });
            },

            updateLobbyUI: () => {
                $('wait-status').innerText = `${Game.engine.players.length}/2 Players`;
            },

            // --- ANIMATION HANDLER ---
            handleAnimation: (act) => {
                if(act.type === 'ATTACK') {
                    // Fly from attacker avatar to table
                    // Determine Source: Me or Opponent?
                    let startEl;
                    if(act.from === Game.state.players.findIndex(p=>p.id === Game.myId)) {
                        // It was me, animation already handled or unnecessary (instant feedback)
                        // But for polish, let's assume we want to see it
                        // We will rely on render updates, but specific "Fly" calls are better
                        Anim.bubble(act.from, "Attack!");
                    } else {
                        startEl = $(`p-node-${act.from}`); // Opponent
                        Anim.bubble(act.from, "Attack!");
                        if(startEl) {
                            const rect = startEl.getBoundingClientRect();
                            const slot = $(`slot-${Game.state.field.length-1}`); // Last slot
                             // Wait for render to exist?
                             // Simple hack: Fly to center of screen if slot not ready
                             const target = slot ? slot.getBoundingClientRect() : {top: window.innerHeight/2, left: window.innerWidth/2};
                             Anim.fly(rect, target, getCardImg(act.card.r, act.card.s));
                        }
                    }
                }
                if(act.type === 'BITO') {
                    Anim.bubble(act.from, "Bito!");
                    // Animate all table cards to Bito Slot
                    document.querySelectorAll('.card').forEach(c => {
                        const r = c.getBoundingClientRect();
                        const bito = $('bito-area').getBoundingClientRect();
                        Anim.fly(r, bito, getBackImg());
                    });
                }
                if(act.type === 'TAKE') {
                    Anim.bubble(act.from, "I'll Take.");
                    // Animate to player
                    const pIdx = act.from;
                    const isMe = (Game.state.players[pIdx].id === Game.myId);
                    const targetEl = isMe ? $('my-hand') : $(`p-node-${pIdx}`);
                    
                    document.querySelectorAll('.slots-container .card').forEach(c => {
                        Anim.fly(c.getBoundingClientRect(), targetEl.getBoundingClientRect(), getBackImg());
                    });
                }
            },

            // --- USER INPUT ---
            act: (type, data={}) => {
                if(Game.isHost) {
                    const res = Game.engine.processAction(Game.myId, type, data);
                    if(res.valid) {
                        Game.broadcastState(res);
                    } else {
                        Anim.toast("Invalid Move", true);
                    }
                } else {
                    Game.conn.send({type: 'ACTION', pid: Game.myId, act: type, data});
                }
            },

            doAction: () => {
                const s = Game.state;
                if(!s) return;
                const myIdx = s.players.findIndex(p=>p.id===Game.myId);
                const amAttacker = (s.turn === myIdx);
                
                if(amAttacker) Game.act('BITO');
                else Game.act('TAKE');
            }
        };

        // --- UI RENDERER ---
        const UI = {
            render: () => {
                const s = Game.state;
                const myIdx = s.players.findIndex(p => p.id === Game.myId);
                
                // 1. OPPONENTS
                const oppContainer = $('opponents');
                oppContainer.innerHTML = '';
                
                s.players.forEach((p, i) => {
                    if(p.id === Game.myId) return; // Skip me
                    
                    const isTurn = (s.turn === i);
                    const node = document.createElement('div');
                    node.className = 'player-node';
                    node.id = `p-node-${i}`;
                    node.innerHTML = `
                        <div class="bubble"></div>
                        <div class="avatar ${isTurn ? 'active-turn' : ''}" style="background-image:url('https://robohash.org/${p.name}.png?set=set4')"></div>
                        <div style="margin-top:5px; font-weight:bold; font-size:14px; color:${isTurn? 'var(--accent)':'#aaa'}">${p.name}</div>
                        <div class="opp-hand-counter">
                             ${ Array(Math.min(p.handCount, 6)).fill('<div class="card-back-icon"></div>').join('') }
                             <div class="counter-badge">${p.handCount}</div>
                        </div>
                    `;
                    oppContainer.appendChild(node);
                });

                // 2. TABLE
                const slotContainer = $('slots');
                slotContainer.innerHTML = '';
                $('deck-count').innerText = s.deckCount;
                if(s.trump) $('trump-visual').style.backgroundImage = `url(${getCardImg(s.trump.r, s.trump.s)})`;
                
                s.field.forEach((slot, idx) => {
                    const el = document.createElement('div');
                    el.className = 'slot';
                    el.id = `slot-${idx}`;
                    
                    // Attack Card
                    const atk = document.createElement('div');
                    atk.className = 'card atk';
                    atk.style.backgroundImage = `url(${getCardImg(slot.atk.r, slot.atk.s)})`;
                    el.appendChild(atk);

                    // Defense Card
                    if(slot.def) {
                        const def = document.createElement('div');
                        def.className = 'card def';
                        def.style.backgroundImage = `url(${getCardImg(slot.def.r, slot.def.s)})`;
                        el.appendChild(def);
                    } else if(myIdx === (s.turn+1)%s.players.length && Game.selection !== null) {
                        // Highlight valid targets for defender
                        el.classList.add('highlight');
                        el.onclick = () => {
                            Game.act('DEFEND', {slotIdx: idx, cardIdx: Game.selection});
                            Game.selection = null;
                        };
                    }
                    slotContainer.appendChild(el);
                });

                // 3. MY HAND
                const handContainer = $('my-hand');
                handContainer.innerHTML = '';
                const amAttacker = (s.turn === myIdx);
                const amDefender = ((s.turn + 1) % s.players.length === myIdx);

                Game.myHand.forEach((c, i) => {
                    const wrap = document.createElement('div');
                    wrap.className = 'hand-card-wrap' + (Game.selection === i ? ' selected' : '');
                    wrap.innerHTML = `<div class="card" style="background-image: url('${getCardImg(c.r, c.s)}')"></div>`;
                    
                    wrap.onclick = () => {
                        if(amAttacker) {
                            Game.act('ATTACK', {idx: i});
                        } else if(amDefender) {
                            Game.selection = (Game.selection === i ? null : i);
                            UI.render(); // Re-render to show highlights
                        } else {
                            // Throw-in logic could go here
                            Anim.toast("Not your turn");
                        }
                    };
                    handContainer.appendChild(wrap);
                });

                // 4. BUTTONS
                const btn = $('btn-action');
                if(amAttacker) {
                    const allBeaten = s.field.length > 0 && s.field.every(x => x.def);
                    if(allBeaten) {
                        btn.classList.remove('hidden');
                        btn.innerText = "BITO (End Turn)";
                        btn.className = "btn";
                    } else {
                        btn.classList.add('hidden');
                    }
                } else if(amDefender) {
                    if(s.field.some(x => !x.def)) {
                        btn.classList.remove('hidden');
                        btn.innerText = "TAKE";
                        btn.className = "btn btn-red";
                    } else {
                        btn.classList.add('hidden');
                    }
                } else {
                    btn.classList.add('hidden');
                }
            }
        };

        // Modify Host ID display logic slightly for the demo
        // For real PeerJS we need unique IDs, handled by library.
    </script>
</body>
</html>
