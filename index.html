<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>DDNet Pro Clone</title>
    <style>
        body { margin: 0; overflow: hidden; background: #5691c8; font-family: 'Arial', sans-serif; }
        canvas { display: block; }
        #overlay { position: absolute; top: 10px; left: 10px; color: white; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); pointer-events: none; }
    </style>
</head>
<body>
    <div id="overlay">
        <h2>DDNet JS Web</h2>
        <p>A, D - Движение | Space - Прыжок | ЛКМ - Хук | Мышь - Прицел</p>
    </div>
    <canvas id="game"></canvas>

<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script>
const socket = io('https://ТВОЙ-ПРОЕКТ.onrender.com'); // ВСТАВЬ СВОЮ ССЫЛКУ
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// --- ГЛОБАЛЬНЫЕ ПАРАМЕТРЫ ---
const TILE_SIZE = 64;
const GRAVITY = 0.5;
const ACCEL = 1.2;
const FRICTION = 0.88;
const JUMP_FORCE = 13;
const HOOK_FORCE = 0.9;
const TEE_RADIUS = 24;

let myId = null;
let players = {};
const keys = {};
const mouse = { x: 0, y: 0, left: false };

// --- КАРТА (0-пусто, 1-блок, 2-платформа) ---
const map = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1],
    [1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1],
    [1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
];

class Player {
    constructor(id, data) {
        this.id = id;
        this.x = data.x || 200;
        this.y = data.y || 200;
        this.vx = 0;
        this.vy = 0;
        this.color = data.color || '#ff5e5e';
        this.angle = 0;
        this.grounded = false;
        this.walkAnim = 0;
        this.hook = { active: false, x: 0, y: 0, length: 0 };
    }

    update() {
        if (this.id !== myId) return;

        // Ввод
        if (keys['KeyA']) { this.vx -= ACCEL; this.walkAnim += 0.15; }
        if (keys['KeyD']) { this.vx += ACCEL; this.walkAnim += 0.15; }
        if (keys['Space'] && this.grounded) { this.vy = -JUMP_FORCE; this.grounded = false; }

        // Физика
        this.vy += GRAVITY;
        this.vx *= FRICTION;

        // Механика хука
        if (mouse.left) {
            if (!this.hook.active) this.shootHook();
            if (this.hook.active) {
                let dx = this.hook.x - this.x;
                let dy = this.hook.y - this.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                this.vx += (dx / dist) * HOOK_FORCE;
                this.vy += (dy / dist) * HOOK_FORCE;
            }
        } else {
            this.hook.active = false;
        }

        // Коллизии (X)
        this.x += this.vx;
        this.resolveCollisions(true);
        // Коллизии (Y)
        this.y += this.vy;
        this.resolveCollisions(false);

        this.angle = Math.atan2(mouse.y - (this.y - camera.y), mouse.x - (this.x - camera.x));

        // Отправка на сервер
        socket.emit('update', { x: this.x, y: this.y, angle: this.angle, hook: this.hook, color: this.color });
    }

    shootHook() {
        let dx = Math.cos(this.angle);
        let dy = Math.sin(this.angle);
        for (let i = 0; i < 600; i += 10) {
            let tx = this.x + dx * i;
            let ty = this.y + dy * i;
            let col = Math.floor(tx / TILE_SIZE);
            let row = Math.floor(ty / TILE_SIZE);
            if (map[row] && map[row][col] === 1) {
                this.hook = { active: true, x: tx, y: ty };
                break;
            }
        }
    }

    resolveCollisions(isX) {
        let col = Math.floor(this.x / TILE_SIZE);
        let row = Math.floor(this.y / TILE_SIZE);

        for (let r = row - 1; r <= row + 1; r++) {
            for (let c = col - 1; c <= col + 1; c++) {
                if (map[r] && map[r][c] === 1) {
                    let bx = c * TILE_SIZE;
                    let by = r * TILE_SIZE;

                    if (this.x + TEE_RADIUS > bx && this.x - TEE_RADIUS < bx + TILE_SIZE &&
                        this.y + TEE_RADIUS > by && this.y - TEE_RADIUS < by + TILE_SIZE) {
                        
                        if (isX) {
                            if (this.vx > 0) this.x = bx - TEE_RADIUS;
                            else if (this.vx < 0) this.x = bx + TILE_SIZE + TEE_RADIUS;
                            this.vx = 0;
                        } else {
                            if (this.vy > 0) {
                                this.y = by - TEE_RADIUS;
                                this.grounded = true;
                            } else if (this.vy < 0) {
                                this.y = by + TILE_SIZE + TEE_RADIUS;
                            }
                            this.vy = 0;
                        }
                    }
                }
            }
        }
    }

    draw() {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;

        // Рисуем хук (цепь)
        if (this.hook.active) {
            ctx.strokeStyle = '#d1d1d1';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(screenX, screenY);
            ctx.lineTo(this.hook.x - camera.x, this.hook.y - camera.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // НОГИ (анимация)
        ctx.fillStyle = this.color;
        const footY = screenY + 15;
        const moveOffset = Math.sin(this.walkAnim) * 10;
        
        // Левая нога
        ctx.beginPath();
        ctx.ellipse(screenX - 12 + moveOffset, footY + (this.grounded?0:-5), 10, 6, 0, 0, Math.PI*2);
        ctx.fill(); ctx.stroke();
        // Правая нога
        ctx.beginPath();
        ctx.ellipse(screenX + 12 - moveOffset, footY + (this.grounded?0:-5), 10, 6, 0, 0, Math.PI*2);
        ctx.fill(); ctx.stroke();

        // ТЕЛО (Tee)
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(screenX, screenY, TEE_RADIUS, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.stroke();

        // ГЛАЗА
        const eyeX = screenX + Math.cos(this.angle) * 10;
        const eyeY = screenY + Math.sin(this.angle) * 8;
        ctx.fillStyle = 'white';
        ctx.beginPath(); ctx.arc(eyeX - 7, eyeY, 6, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.arc(eyeX + 7, eyeY, 6, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        
        ctx.fillStyle = 'black';
        ctx.beginPath(); ctx.arc(eyeX - 7 + Math.cos(this.angle)*3, eyeY + Math.sin(this.angle)*3, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(eyeX + 7 + Math.cos(this.angle)*3, eyeY + Math.sin(this.angle)*3, 2.5, 0, Math.PI*2); ctx.fill();
    }
}

const camera = { x: 0, y: 0 };
function updateCamera() {
    if (players[myId]) {
        camera.x += (players[myId].x - canvas.width / 2 - camera.x) * 0.1;
        camera.y += (players[myId].y - canvas.height / 2 - camera.y) * 0.1;
    }
}

function drawMap() {
    ctx.fillStyle = '#4a76a8'; // Цвет блоков
    for (let r = 0; r < map.length; r++) {
        for (let c = 0; c < map[r].length; c++) {
            if (map[r][c] === 1) {
                const x = c * TILE_SIZE - camera.x;
                const y = r * TILE_SIZE - camera.y;
                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                ctx.strokeStyle = '#355375';
                ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
                
                // Трава сверху
                ctx.fillStyle = '#71bc4b';
                ctx.fillRect(x, y, TILE_SIZE, 8);
                ctx.fillStyle = '#4a76a8';
            }
        }
    }
}

function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Фон (небо)
    const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grad.addColorStop(0, '#74b9ff');
    grad.addColorStop(1, '#a29bfe');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    updateCamera();
    drawMap();

    for (let id in players) {
        players[id].update();
        players[id].draw();
    }

    requestAnimationFrame(loop);
}

// Сетевые события
socket.on('init', (data) => {
    myId = data.id;
    for (let id in data.players) players[id] = new Player(id, data.players[id]);
});
socket.on('newPlayer', (data) => players[data.id] = new Player(data.id, data.player));
socket.on('playerUpdated', (data) => {
    if (players[data.id]) Object.assign(players[data.id], data);
});
socket.on('playerLeave', (id) => delete players[id]);

// Ввод
window.onkeydown = (e) => keys[e.code] = true;
window.onkeyup = (e) => keys[e.code] = false;
window.onmousemove = (e) => { mouse.x = e.clientX; mouse.y = e.clientY; };
window.onmousedown = () => mouse.left = true;
window.onmouseup = () => mouse.left = false;
window.onresize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
window.onresize();

loop();
</script>
</body>
</html>
