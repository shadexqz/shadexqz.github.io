<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Durak P2P</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg-dark: #0f172a;
            --bg-table: #1e293b;
            --accent: #38bdf8;
            --accent-glow: rgba(56, 189, 248, 0.4);
            --glass: rgba(30, 41, 59, 0.7);
            --border: rgba(255, 255, 255, 0.1);
            --text-main: #e2e8f0;
            --card-w: 80px;
            --card-h: 120px;
            --danger: #f43f5e;
            --success: #22c55e;
        }

        @media (max-width: 600px) {
            :root { --card-w: 60px; --card-h: 90px; }
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0;
            padding: 0;
            background: var(--bg-dark);
            color: var(--text-main);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- LOBBY SCREEN --- */
        #lobby-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            transition: opacity 0.5s;
        }

        .hidden { opacity: 0; pointer-events: none; display: none !important; }

        h1 {
            font-size: 3rem;
            margin: 0;
            background: linear-gradient(45deg, #38bdf8, #818cf8);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px var(--accent-glow);
        }

        .lobby-box {
            background: var(--glass);
            padding: 30px;
            border-radius: 16px;
            border: 1px solid var(--border);
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 90%;
            width: 400px;
        }

        input {
            width: 100%;
            padding: 12px;
            margin: 10px 0;
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: white;
            font-size: 1rem;
            text-align: center;
        }

        button {
            background: linear-gradient(90deg, #38bdf8, #6366f1);
            border: none;
            padding: 12px 24px;
            color: white;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: transform 0.1s, box-shadow 0.2s;
            width: 100%;
            margin-top: 10px;
        }

        button:active { transform: scale(0.98); }
        button:disabled { opacity: 0.5; cursor: wait; }
        
        .btn-outline {
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
        }

        /* --- GAME UI --- */
        #game-screen {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
            position: relative;
        }

        .top-bar {
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid var(--border);
        }

        .status-badge {
            padding: 5px 12px;
            border-radius: 20px;
            background: var(--glass);
            font-size: 0.9rem;
            border: 1px solid var(--border);
        }

        /* Hand Areas */
        .hand-area {
            height: 140px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .hand-area.opponent { margin-top: -30px; transform: scale(0.8); }

        /* Table / Battle */
        .table-area {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            perspective: 1000px;
            position: relative;
        }

        .deck-area {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .battle-zone {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 0 60px; /* Space for deck */
        }

        .bout {
            position: relative;
            width: var(--card-w);
            height: var(--card-h);
        }

        /* Cards */
        .card {
            width: var(--card-w);
            height: var(--card-h);
            background: #e2e8f0;
            border-radius: 8px;
            position: relative;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px;
            color: #1e293b;
            font-weight: bold;
            font-size: 14px;
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
        }

        .card[data-color="red"] { color: #ef4444; }
        .card[data-color="black"] { color: #1e293b; }

        .card.back {
            background: linear-gradient(135deg, #1e293b 25%, #334155 25%, #334155 50%, #1e293b 50%, #1e293b 75%, #334155 75%, #334155 100%);
            background-size: 20px 20px;
            border: 2px solid #475569;
        }
        .card.back * { display: none; }

        .card:hover { transform: translateY(-10px); z-index: 10; }
        .card.selected { border: 3px solid var(--accent); transform: translateY(-15px); }
        .card.defense { 
            position: absolute; 
            top: 15px; left: 15px; 
            transform: rotate(10deg); 
            z-index: 2; 
            box-shadow: 2px 2px 5px rgba(0,0,0,0.4);
        }
        .card.defense:hover { transform: rotate(10deg) scale(1.1); }

        .center-suit { 
            position: absolute; 
            top: 50%; left: 50%; 
            transform: translate(-50%, -50%); 
            font-size: 2rem; 
            opacity: 0.8; 
        }

        .trump-indicator {
            transform: rotate(90deg) translateX(30px);
            margin-bottom: -40px;
            z-index: 0;
        }
        
        /* Action Bar */
        .action-bar {
            position: absolute;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 100;
        }

        /* Chat */
        #chat-container {
            position: fixed;
            bottom: 20px; right: 20px;
            width: 300px;
            height: 200px;
            background: var(--glass);
            border-radius: 12px;
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            pointer-events: none; /* Let clicks pass through when idle */
        }
        
        #chat-container.active { pointer-events: auto; background: rgba(15, 23, 42, 0.95); }
        
        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 0.8rem;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .chat-msg { padding: 4px 8px; border-radius: 4px; background: rgba(255,255,255,0.1); width: fit-content; }
        .chat-msg.me { align-self: flex-end; background: var(--accent-glow); }
        
        #chat-input {
            width: 100%;
            border: none;
            background: rgba(0,0,0,0.3);
            color: white;
            padding: 8px;
            border-top: 1px solid var(--border);
            pointer-events: auto;
        }

        /* Animations */
        @keyframes deal { from { opacity: 0; transform: scale(0.5); } to { opacity: 1; transform: scale(1); } }
        .anim-deal { animation: deal 0.3s ease-out; }
    </style>
</head>
<body>

    <!-- LOBBY -->
    <div id="lobby-screen">
        <h1>NEON DURAK</h1>
        <div class="lobby-box" id="lobby-menu">
            <p>Peer-to-Peer Card Game</p>
            <button onclick="net.createGame()">Create New Game</button>
            <div style="margin: 10px 0; opacity: 0.5;">- OR -</div>
            <input type="text" id="join-id" placeholder="Paste Game ID / URL here">
            <button class="btn-outline" onclick="net.joinGameInput()">Join Game</button>
        </div>
        
        <div class="lobby-box hidden" id="lobby-waiting">
            <p>Waiting for opponent...</p>
            <input type="text" id="share-link" readonly onclick="this.select()">
            <button onclick="ui.copyLink()">Copy Invite Link</button>
            <p style="font-size: 0.8rem; opacity: 0.7;">Send this link to your friend</p>
        </div>
    </div>

    <!-- GAME -->
    <div id="game-screen" class="hidden">
        <div class="top-bar">
            <div id="status-text">Connecting...</div>
            <div class="status-badge" id="role-badge">Spectator</div>
        </div>

        <!-- Opponent Hand (Backs) -->
        <div class="hand-area opponent" id="opp-hand"></div>

        <!-- Table -->
        <div class="table-area">
            <div class="deck-area">
                <div id="deck-count" style="font-size:0.8rem; margin-bottom:5px;">36</div>
                <div id="deck-pile"></div>
            </div>
            <div class="battle-zone" id="battle-field"></div>
        </div>

        <!-- Controls -->
        <div class="action-bar" id="action-bar">
            <!-- Buttons injected by JS -->
        </div>

        <!-- My Hand -->
        <div class="hand-area" id="my-hand"></div>
    </div>

    <!-- CHAT -->
    <div id="chat-container">
        <div id="chat-messages"></div>
        <input type="text" id="chat-input" placeholder="Type to chat..." onkeypress="ui.handleChatKey(event)">
    </div>

<script>
/**
 * UTILITIES
 */
const SUITS = ['♠', '♥', '♦', '♣'];
const RANKS = ['6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
const VALUES = { '6':6, '7':7, '8':8, '9':9, '10':10, 'J':11, 'Q':12, 'K':13, 'A':14 };
const COLORS = { '♠':'black', '♣':'black', '♥':'red', '♦':'red' };

class Card {
    constructor(rank, suit) {
        this.rank = rank;
        this.suit = suit;
        this.value = VALUES[rank];
        this.color = COLORS[suit];
        this.id = rank + suit;
    }
}

/**
 * GAME ENGINE (Host Only)
 * Manages the authoritative state of the game.
 */
class DurakEngine {
    constructor() {
        this.reset();
    }

    reset() {
        this.deck = [];
        this.hands = { host: [], client: [] };
        this.table = []; // Array of {attack: Card, defense: Card|null}
        this.trumpCard = null;
        this.turn = null; // 'host' or 'client'
        this.phase = 'attack'; // 'attack' or 'defense'
        this.gameOver = false;
        this.winner = null;
    }

    initGame() {
        // Create Deck
        this.deck = [];
        for(let s of SUITS) for(let r of RANKS) this.deck.push(new Card(r,s));
        
        // Shuffle
        for (let i = this.deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
        }

        // Trump (last card)
        this.trumpCard = this.deck[0]; // Logic uses index 0 as bottom
        
        // Deal 6 cards
        for(let i=0; i<6; i++) {
            this.hands.host.push(this.deck.pop());
            this.hands.client.push(this.deck.pop());
        }

        // Determine First Player
        const hLow = this._getLowestTrump(this.hands.host);
        const cLow = this._getLowestTrump(this.hands.client);
        
        if(!hLow && !cLow) this.turn = 'host';
        else if(hLow && !cLow) this.turn = 'host';
        else if(!hLow && cLow) this.turn = 'client';
        else this.turn = hLow.value < cLow.value ? 'host' : 'client';

        this.broadcast();
    }

    _getLowestTrump(hand) {
        let trumps = hand.filter(c => c.suit === this.trumpCard.suit);
        if(trumps.length === 0) return null;
        return trumps.sort((a,b) => a.value - b.value)[0];
    }

    // Process Action from Network
    handleAction(role, action, data) {
        if(this.gameOver) return;

        // Attacking
        if(action === 'ATTACK' && role === this.turn && this.phase === 'attack') {
            const card = this.hands[role][data.index];
            if(this._isValidAttack(card)) {
                this.hands[role].splice(data.index, 1);
                this.table.push({ attack: card, defense: null });
                this.phase = 'defense';
                this.broadcast();
            }
        }
        
        // Defending
        else if(action === 'DEFEND' && role !== this.turn && this.phase === 'defense') {
            const card = this.hands[role][data.index];
            const boutIndex = this.table.findIndex(b => b.defense === null);
            if(boutIndex !== -1 && this._canBeat(this.table[boutIndex].attack, card)) {
                this.hands[role].splice(data.index, 1);
                this.table[boutIndex].defense = card;
                
                // If all defended, check if attacker wants to add more
                if(this.table.every(b => b.defense !== null)) {
                    this.phase = 'attack'; // Back to attacker to add cards or pass
                }
                this.broadcast();
            }
        }

        // Add Card (Podkidnoy) - Attacker adds card to defended table
        else if(action === 'ADD' && role === this.turn && this.phase === 'attack') {
            const card = this.hands[role][data.index];
            if(this._isValidAdd(card)) {
                 this.hands[role].splice(data.index, 1);
                 this.table.push({ attack: card, defense: null });
                 this.phase = 'defense';
                 this.broadcast();
            }
        }

        // Pass / Bito (Attacker gives up turn)
        else if(action === 'PASS' && role === this.turn) {
            // Can only pass if table is not empty and all defended (or attacker gives up adding)
            if(this.table.length > 0) {
                // If there are undefended cards, attacker can't just 'pass' to clear them, 
                // but in Podkidnoy, "Pass" usually means "I'm done adding". 
                // If everything is defended -> Bito -> Turn Swap.
                // If not everything is defended -> Actually attacker can't pass, he waits for defender.
                // Simplified: If all defended, Bito.
                if(this.table.every(b => b.defense !== null)) {
                    this.table = []; // Discard
                    this._replenishHands();
                    this._swapTurn();
                    this.phase = 'attack';
                    this.broadcast();
                }
            }
        }

        // Take (Defender takes cards)
        else if(action === 'TAKE' && role !== this.turn) {
            // Defender picks up everything
            const allCards = [];
            this.table.forEach(b => {
                allCards.push(b.attack);
                if(b.defense) allCards.push(b.defense);
            });
            this.table = [];
            this.hands[role].push(...allCards);
            this._replenishHands(); // Only attacker replenishes
            // Turn does NOT swap (attacker goes again), but we need to reset phase
            this.phase = 'attack';
            this.broadcast();
        }
    }

    _isValidAttack(card) {
        if(this.table.length === 0) return true;
        if(this.table.length >= 6) return false;
        return this._isValidAdd(card);
    }

    _isValidAdd(card) {
        // Rank must exist on table
        const ranks = new Set();
        this.table.forEach(b => {
            ranks.add(b.attack.rank);
            if(b.defense) ranks.add(b.defense.rank);
        });
        return ranks.has(card.rank);
    }

    _canBeat(attack, defense) {
        if(defense.suit === attack.suit) return defense.value > attack.value;
        if(defense.suit === this.trumpCard.suit && attack.suit !== this.trumpCard.suit) return true;
        return false;
    }

    _replenishHands() {
        // Attacker draws first
        const attacker = this.turn;
        const defender = this.turn === 'host' ? 'client' : 'host';

        while(this.deck.length > 0 && this.hands[attacker].length < 6) this.hands[attacker].push(this.deck.pop());
        while(this.deck.length > 0 && this.hands[defender].length < 6) this.hands[defender].push(this.deck.pop());

        if(this.deck.length === 0) {
            if(this.hands.host.length === 0) { this.gameOver = true; this.winner = 'Host'; }
            if(this.hands.client.length === 0) { this.gameOver = true; this.winner = 'Client'; }
        }
    }

    _swapTurn() {
        this.turn = this.turn === 'host' ? 'client' : 'host';
    }

    // Send state to both players
    broadcast() {
        const state = {
            table: this.table,
            trumpCard: this.trumpCard,
            deckCount: this.deck.length,
            turn: this.turn,
            phase: this.phase,
            gameOver: this.gameOver,
            winner: this.winner
        };

        // Send Host View
        net.sendLocal({ ...state, myHand: this.hands.host, oppHandCount: this.hands.client.length, role: 'host' });
        
        // Send Client View (Scrub host cards)
        net.sendToPeer({ ...state, myHand: this.hands.client, oppHandCount: this.hands.host.length, role: 'client' });
    }
}

/**
 * NETWORK MANAGER
 * Handles PeerJS connections.
 */
class NetworkManager {
    constructor() {
        this.peer = null;
        this.conn = null;
        this.role = null; // 'host' or 'client'
        this.gameId = null;
    }

    init() {
        // Check URL for game ID
        const params = new URLSearchParams(window.location.search);
        const gameParam = params.get('game');

        if(gameParam) {
            this.joinGame(gameParam);
        }
    }

    createGame() {
        this.role = 'host';
        // Open Peer
        this.peer = new Peer(null, { debug: 2 });
        
        this.peer.on('open', (id) => {
            this.gameId = id;
            document.getElementById('lobby-menu').classList.add('hidden');
            document.getElementById('lobby-waiting').classList.remove('hidden');
            
            const link = `${window.location.origin}${window.location.pathname}?game=${id}`;
            document.getElementById('share-link').value = link;
        });

        this.peer.on('connection', (conn) => {
            this.conn = conn;
            this._setupConnection();
            ui.showGame();
            gameEngine.initGame();
        });

        this.peer.on('error', (err) => alert("Connection Error: " + err));
    }

    joinGameInput() {
        let id = document.getElementById('join-id').value;
        if(id.includes('game=')) id = id.split('game=')[1];
        if(!id) return;
        this.joinGame(id);
    }

    joinGame(hostId) {
        this.role = 'client';
        document.getElementById('lobby-screen').classList.add('hidden'); // Show loader?
        
        this.peer = new Peer(null, { debug: 2 });
        this.peer.on('open', () => {
            this.conn = this.peer.connect(hostId);
            this._setupConnection();
        });
        this.peer.on('error', err => alert("Failed to connect to host."));
    }

    _setupConnection() {
        this.conn.on('open', () => {
            console.log("Connected!");
            ui.showGame();
        });

        this.conn.on('data', (data) => {
            if(data.type === 'STATE') {
                ui.render(data.payload);
            } else if (data.type === 'ACTION') {
                if(this.role === 'host') {
                    gameEngine.handleAction('client', data.action, data.payload);
                }
            } else if (data.type === 'CHAT') {
                ui.addChatMessage(data.msg, false);
            }
        });
        
        this.conn.on('close', () => alert("Peer disconnected"));
    }

    // Host calls this to update local UI
    sendLocal(state) {
        if(this.role === 'host') ui.render(state);
    }

    // Host calls this to update Peer
    sendToPeer(state) {
        if(this.conn && this.conn.open) {
            this.conn.send({ type: 'STATE', payload: state });
        }
    }

    // Client calls this to act
    sendAction(action, payload = {}) {
        if(this.role === 'client') {
            this.conn.send({ type: 'ACTION', action, payload });
        } else {
            // Host acting locally
            gameEngine.handleAction('host', action, payload);
        }
    }

    sendChat(msg) {
        if(this.conn && this.conn.open) {
            this.conn.send({ type: 'CHAT', msg });
            ui.addChatMessage(msg, true);
        }
    }
}

/**
 * UI MANAGER
 */
class UIManager {
    constructor() {
        this.app = document.getElementById('game-screen');
        this.lobby = document.getElementById('lobby-screen');
        this.myHandEl = document.getElementById('my-hand');
        this.oppHandEl = document.getElementById('opp-hand');
        this.tableEl = document.getElementById('battle-field');
        this.deckPileEl = document.getElementById('deck-pile');
        this.statusEl = document.getElementById('status-text');
        this.roleBadge = document.getElementById('role-badge');
        this.actionBar = document.getElementById('action-bar');
        
        this.currentState = null;
        this.selectedCardIdx = -1;
    }

    showGame() {
        this.lobby.classList.add('hidden');
        this.app.classList.remove('hidden');
    }

    copyLink() {
        const copyText = document.getElementById("share-link");
        copyText.select();
        document.execCommand("copy");
        alert("Link copied! Send it to player 2.");
    }

    render(state) {
        this.currentState = state;
        this.selectedCardIdx = -1;
        
        // Role Badge
        this.roleBadge.textContent = state.role === 'host' ? "Host (You)" : "Client (You)";
        
        // Status Text
        let status = "";
        const isMyTurn = state.turn === state.role;
        
        if(state.gameOver) status = `Game Over! Winner: ${state.winner}`;
        else if(isMyTurn) status = state.phase === 'attack' ? "Your Turn: Attack" : "Your Turn: Defend";
        else status = `Opponent's Turn (${state.phase})`;
        
        this.statusEl.textContent = status;
        this.statusEl.style.color = isMyTurn ? "var(--success)" : "var(--accent)";

        // Render My Hand
        this.myHandEl.innerHTML = '';
        state.myHand.forEach((card, idx) => {
            const el = this.createCardEl(card);
            el.onclick = () => this.onCardClick(idx);
            this.myHandEl.appendChild(el);
        });

        // Render Opponent Hand
        this.oppHandEl.innerHTML = '';
        for(let i=0; i<state.oppHandCount; i++) {
            const back = document.createElement('div');
            back.className = 'card back';
            back.style.marginLeft = "-40px";
            this.oppHandEl.appendChild(back);
        }

        // Render Table
        this.tableEl.innerHTML = '';
        state.table.forEach(bout => {
            const boutEl = document.createElement('div');
            boutEl.className = 'bout';
            
            // Attack Card
            const aEl = this.createCardEl(bout.attack);
            boutEl.appendChild(aEl);

            // Defense Card
            if(bout.defense) {
                const dEl = this.createCardEl(bout.defense);
                dEl.classList.add('defense');
                boutEl.appendChild(dEl);
            }
            this.tableEl.appendChild(boutEl);
        });

        // Render Deck & Trump
        this.deckPileEl.innerHTML = '';
        document.getElementById('deck-count').innerText = state.deckCount + " cards";
        
        if(state.deckCount > 0 && state.trumpCard) {
            // Trump under the deck
            const trumpEl = this.createCardEl(state.trumpCard);
            trumpEl.classList.add('trump-indicator');
            this.deckPileEl.appendChild(trumpEl);
            
            if(state.deckCount > 1) {
                const deckBack = document.createElement('div');
                deckBack.className = 'card back';
                deckBack.style.position = 'absolute';
                deckBack.style.zIndex = '1';
                this.deckPileEl.appendChild(deckBack);
            }
        } else if (state.trumpCard) {
            // Last card (trump)
             const trumpEl = this.createCardEl(state.trumpCard);
             trumpEl.style.opacity = '0.5';
             this.deckPileEl.appendChild(trumpEl);
        }

        // Action Buttons
        this.actionBar.innerHTML = '';
        if(!state.gameOver && isMyTurn) {
            if(state.phase === 'attack') {
                // If table has cards, can pass (Bito)
                if(state.table.length > 0) {
                    const btn = document.createElement('button');
                    btn.innerText = "Pass / Bito";
                    btn.onclick = () => net.sendAction('PASS');
                    this.actionBar.appendChild(btn);
                }
            } else {
                // Defending - can Take
                const btn = document.createElement('button');
                btn.innerText = "Take Cards";
                btn.style.background = "var(--danger)";
                btn.onclick = () => net.sendAction('TAKE');
                this.actionBar.appendChild(btn);
            }
        } else if (state.gameOver) {
             const btn = document.createElement('button');
             btn.innerText = "Reload to Rematch";
             btn.onclick = () => location.reload();
             this.actionBar.appendChild(btn);
        }
    }

    createCardEl(card) {
        const el = document.createElement('div');
        el.className = 'card anim-deal';
        el.dataset.color = card.color;
        el.innerHTML = `
            <div style="font-size:1rem;">${card.rank}</div>
            <div style="font-size:0.8rem;">${card.suit}</div>
            <div class="center-suit">${card.suit}</div>
            <div style="transform: rotate(180deg); text-align:center;">
                <div style="font-size:1rem;">${card.rank}</div>
                <div style="font-size:0.8rem;">${card.suit}</div>
            </div>
        `;
        return el;
    }

    onCardClick(index) {
        const state = this.currentState;
        if(!state || state.gameOver) return;
        if(state.turn !== state.role) return; // Not my turn

        // Logic
        if(state.phase === 'attack') {
             // Try to play as attack or add
             if(state.table.length === 0) {
                 net.sendAction('ATTACK', { index });
             } else {
                 net.sendAction('ADD', { index });
             }
        } else {
            // Defend
            net.sendAction('DEFEND', { index });
        }
    }

    handleChatKey(e) {
        if(e.key === 'Enter') {
            const input = document.getElementById('chat-input');
            const msg = input.value.trim();
            if(msg) {
                net.sendChat(msg);
                input.value = '';
            }
        }
    }

    addChatMessage(msg, isMe) {
        const box = document.getElementById('chat-messages');
        const div = document.createElement('div');
        div.className = `chat-msg ${isMe ? 'me' : ''}`;
        div.innerText = msg;
        box.appendChild(div);
        box.scrollTop = box.scrollHeight;
    }
}

// --- INIT ---
const gameEngine = new DurakEngine();
const ui = new UIManager();
const net = new NetworkManager();

net.init(); // Checks for URL params

</script>
</body>
</html>
