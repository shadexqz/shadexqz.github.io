<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Durak Elite 3P</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        /* --- ШРИФТЫ И БАЗА --- */
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap');

        :root {
            --bg-color: #355c7d; /* То самое синее сукно */
            --bg-gradient: radial-gradient(circle at center, #355c7d 0%, #1e3c50 100%);
            --card-w: 120px;
            --card-h: 175px;
            --radius: 8px;
            --primary: #f8b195;
            --accent: #c06c84;
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0;
            font-family: 'Montserrat', sans-serif;
            background: var(--bg-gradient);
            color: white;
            height: 100vh;
            overflow: hidden;
            display: flex; flex-direction: column;
        }

        /* --- КАРТЫ --- */
        .card {
            width: var(--card-w); height: var(--card-h);
            border-radius: var(--radius);
            background-color: #fff;
            background-size: 100% 100%;
            background-repeat: no-repeat;
            position: relative;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1), box-shadow 0.3s;
            transform-origin: center bottom;
        }
        
        .card:hover {
            transform: translateY(-25px) scale(1.05);
            box-shadow: 0 15px 30px rgba(0,0,0,0.6);
            z-index: 100 !important;
        }

        .card.selected {
            transform: translateY(-40px) scale(1.05);
            box-shadow: 0 0 0 4px #ffeb3b;
            z-index: 101 !important;
        }

        .card-back { background-image: url('https://deckofcardsapi.com/static/img/back.png'); }

        /* Маленькие карты (для соперников) */
        .card-mini {
            width: 45px; height: 65px;
            border-radius: 4px;
            background-image: url('https://deckofcardsapi.com/static/img/back.png');
            background-size: cover;
            border: 1px solid #fff;
            box-shadow: -2px 2px 5px rgba(0,0,0,0.3);
        }

        /* --- ЛОББИ --- */
        #lobby {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 9999;
            display: flex; align-items: center; justify-content: center;
        }
        .panel {
            background: #fff; color: #333;
            padding: 30px; border-radius: 20px;
            width: 90%; max-width: 450px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }
        .avatar-grid {
            display: flex; justify-content: center; gap: 10px; margin: 15px 0;
        }
        .ava-option {
            width: 50px; height: 50px; border-radius: 50%;
            cursor: pointer; border: 3px solid transparent;
            transition: 0.2s;
        }
        .ava-option:hover { transform: scale(1.1); }
        .ava-option.active { border-color: var(--accent); transform: scale(1.15); }
        
        .mode-select {
            display: flex; gap: 10px; margin-bottom: 15px;
        }
        .mode-btn {
            flex: 1; padding: 10px; border: 2px solid #ddd;
            background: #f9f9f9; cursor: pointer; border-radius: 8px; font-weight: bold;
        }
        .mode-btn.active { border-color: var(--bg-color); background: #e3f2fd; color: var(--bg-color); }

        .inp { width: 100%; padding: 12px; margin-bottom: 10px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px; text-align: center;}
        .btn { width: 100%; padding: 14px; border: none; font-size: 16px; font-weight: bold; color: white; border-radius: 8px; cursor: pointer; transition: 0.2s; margin-top: 5px;}
        .btn-create { background: var(--accent); }
        .btn-join { background: #355c7d; }

        /* --- ИГРОВОЕ ПОЛЕ --- */
        #game { display: none; flex-direction: column; height: 100%; position: relative; }

        /* ВЕРХНЯЯ ЗОНА (Соперники) */
        .top-zone {
            height: 140px;
            display: flex; justify-content: space-between; align-items: flex-start;
            padding: 10px 20px;
        }
        .opponent {
            display: flex; flex-direction: column; align-items: center;
            width: 120px; transition: opacity 0.3s;
        }
        .opponent.inactive { opacity: 0.4; }
        .opp-ava { width: 50px; height: 50px; border-radius: 50%; border: 2px solid #fff; box-shadow: 0 4px 5px rgba(0,0,0,0.3); }
        .opp-hand { display: flex; justify-content: center; margin-top: 5px; height: 40px; }
        .opp-hand .card-mini { margin-left: -30px; }
        .opp-hand .card-mini:first-child { margin-left: 0; }
        .opp-name { font-size: 12px; font-weight: bold; margin-top: 4px; text-shadow: 1px 1px 2px black; }

        /* ЦЕНТР (Стол) */
        .table-zone {
            flex: 1; position: relative;
            display: flex; justify-content: center; align-items: center;
        }

        /* Колода */
        .deck-area {
            position: absolute; left: 20px; top: 50%; transform: translateY(-50%);
            width: var(--card-w); height: var(--card-h);
        }
        .trump-card {
            position: absolute; left: 15px; top: 0;
            transform: rotate(90deg) translateX(20px); z-index: 1;
        }
        .deck-stack { position: absolute; z-index: 2; top:0; left:0; }
        .deck-badge {
            position: absolute; top: -20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.6); padding: 4px 10px; border-radius: 10px; font-size: 12px;
        }

        /* Слоты карт на столе */
        .slots-container {
            display: flex; gap: 15px; padding: 0 20px;
            align-items: center;
            perspective: 1000px;
        }
        .slot {
            width: var(--card-w); height: var(--card-h);
            position: relative;
        }
        .slot-att { position: absolute; top: 0; left: 0; z-index: 10; cursor: default; }
        .slot-def { position: absolute; top: 20px; left: 15px; z-index: 20; transform: rotate(8deg); cursor: default; }
        
        /* НИЗ (Я) */
        .player-zone {
            height: 220px;
            display: flex; flex-direction: column; justify-content: flex-end; align-items: center;
            padding-bottom: 10px; position: relative;
            background: linear-gradient(to top, rgba(0,0,0,0.3), transparent);
        }
        .my-hand {
            display: flex; justify-content: center; align-items: flex-end;
            margin-bottom: 10px;
        }
        .my-card-wrap {
            width: 50px; /* Сжатие карт */
            height: var(--card-h);
            position: relative;
            transition: width 0.3s;
        }
        .my-card-wrap:hover { width: 70px; } /* Раздвигаем при наведении */
        .my-card-wrap:last-child { width: var(--card-w); }
        .my-card-wrap .card { position: absolute; bottom: 0; left: 0; cursor: pointer; }

        .my-info {
            position: absolute; bottom: 20px; left: 20px;
            display: flex; align-items: center; gap: 10px;
        }
        .my-ava { width: 60px; height: 60px; border-radius: 50%; border: 3px solid #ffeb3b; }

        /* УПРАВЛЕНИЕ */
        .controls {
            position: absolute; right: 20px; bottom: 240px;
            display: flex; flex-direction: column; align-items: flex-end; gap: 10px;
        }
        .status-msg {
            background: rgba(255,255,255,0.1); backdrop-filter: blur(5px);
            padding: 10px 20px; border-radius: 8px; font-weight: bold;
            border-left: 4px solid white; text-align: right; margin-bottom: 5px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .act-btn {
            border: none; padding: 15px 40px; border-radius: 50px;
            font-size: 18px; font-weight: bold; color: white; cursor: pointer;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            text-transform: uppercase; letter-spacing: 1px;
            transition: transform 0.1s; display: none;
        }
        .act-btn:active { transform: scale(0.95); }
        .btn-take { background: linear-gradient(45deg, #ff9800, #f57c00); }
        .btn-bito { background: linear-gradient(45deg, #f44336, #d32f2f); }

        /* ЧАТ */
        .chat-container {
            position: absolute; top: 10px; right: 10px; width: 300px; height: 200px;
            display: flex; flex-direction: column; pointer-events: none; z-index: 500;
        }
        .chat-log {
            flex: 1; overflow-y: auto; display: flex; flex-direction: column; justify-content: flex-end;
            margin-bottom: 5px; padding: 5px; text-shadow: 1px 1px 1px rgba(0,0,0,0.8);
        }
        .chat-msg {
            background: rgba(0,0,0,0.5); color: white; padding: 5px 10px;
            border-radius: 6px; margin-bottom: 4px; font-size: 13px;
            align-self: flex-start; max-width: 90%; word-break: break-word; pointer-events: auto;
        }
        .chat-msg.me { align-self: flex-end; background: rgba(53, 92, 125, 0.8); }
        .chat-msg b { color: #f8b195; }
        
        .chat-input-row {
            display: flex; pointer-events: auto; background: rgba(255,255,255,0.1);
            backdrop-filter: blur(5px); border-radius: 20px; padding: 2px;
        }
        #chat-in {
            flex: 1; background: transparent; border: none; color: white; padding: 8px 15px; outline: none;
        }
        #chat-btn {
            background: transparent; border: none; color: #fff; font-size: 18px; padding: 0 15px; cursor: pointer;
        }

        /* АДАПТИВ */
        @media (max-width: 700px) {
            :root { --card-w: 80px; --card-h: 116px; }
            .top-zone { height: 100px; padding: 5px 10px; }
            .player-zone { height: 160px; }
            .controls { bottom: 180px; }
            .act-btn { padding: 12px 25px; font-size: 14px; }
            .chat-container { width: 220px; height: 150px; }
            .my-card-wrap { width: 35px; }
            .my-card-wrap:hover { width: 50px; }
            .deck-area { left: 10px; }
            .slots-container { gap: 5px; padding: 0 5px; }
        }
    </style>
</head>
<body>

    <!-- ЛОББИ -->
    <div id="lobby">
        <div class="panel" id="panel-setup">
            <h2 style="color: #355c7d; margin-top:0;">DURAK ELITE</h2>
            
            <label>Выбери аватар:</label>
            <div class="avatar-grid" id="ava-select">
                <!-- JS Generated -->
            </div>

            <input type="text" id="p-name" class="inp" placeholder="Твое имя" value="Player">

            <label>Режим игры:</label>
            <div class="mode-select">
                <div class="mode-btn active" onclick="Lobby.setMode(2)">1 vs 1</div>
                <div class="mode-btn" onclick="Lobby.setMode(3)">1 vs 1 vs 1</div>
            </div>

            <button class="btn btn-create" onclick="Lobby.create()">СОЗДАТЬ СТОЛ</button>
            <div style="margin:10px; color:#999;">— или —</div>
            <input type="text" id="join-code" class="inp" placeholder="Код стола">
            <button class="btn btn-join" onclick="Lobby.join()">ПРИСОЕДИНИТЬСЯ</button>
        </div>

        <div class="panel" id="panel-wait" style="display:none;">
            <h3>Ожидание игроков...</h3>
            <p>Код для друзей:</p>
            <input type="text" id="host-id-disp" class="inp" style="background:#eee; font-weight:bold;" readonly onclick="this.select()">
            <div id="wait-status" style="margin-top:10px; color:var(--accent);">0/2 подключено</div>
            <div style="font-size:30px; margin-top:15px; animation: spin 2s infinite;">⌛</div>
        </div>
    </div>

    <!-- ИГРА -->
    <div id="game">
        <div class="chat-container">
            <div class="chat-log" id="chat-log"></div>
            <div class="chat-input-row">
                <input type="text" id="chat-in" placeholder="Чат..." autocomplete="off">
                <button id="chat-btn" onclick="Game.sendChat()">➤</button>
            </div>
        </div>

        <!-- Верх: Соперники (до 2х) -->
        <div class="top-zone" id="top-opponents"></div>

        <!-- Центр: Стол -->
        <div class="table-zone">
            <div class="deck-area">
                <div class="deck-badge" id="deck-num">36</div>
                <div id="trump-ph"></div>
                <div id="deck-ph" class="card card-back deck-stack"></div>
            </div>

            <div class="slots-container" id="table-slots"></div>

            <div class="controls">
                <div class="status-msg" id="game-status">Загрузка...</div>
                <button class="act-btn btn-bito" id="btn-bito" onclick="Game.act('BITO')">БИТО</button>
                <button class="act-btn btn-take" id="btn-take" onclick="Game.act('TAKE')">ВЗЯТЬ</button>
            </div>
        </div>

        <!-- Низ: Я -->
        <div class="player-zone">
            <div class="my-hand" id="my-hand"></div>
            <div class="my-info">
                <img id="my-ava-img" class="my-ava" src="">
                <div style="font-weight:bold; text-shadow:1px 1px 2px black;">Вы</div>
            </div>
        </div>
    </div>

    <script>
        // --- ДАННЫЕ ---
        const SUITS = ['S', 'C', 'H', 'D'];
        const RANKS = ['6', '7', '8', '9', '0', 'J', 'Q', 'K', 'A'];
        const IMG_API = (r,s) => `https://deckofcardsapi.com/static/img/${r}${s}.png`;
        const AVATARS = [1, 2, 3, 4, 5]; // RoboHash sets

        // --- ЛОГИКА ИГРЫ (SERVER-SIDE MOCK) ---
        class Engine {
            constructor(hostName, hostAva, mode) {
                this.mode = mode; // 2 or 3
                this.players = [{ id: 'host', name: hostName, ava: hostAva, hand: [] }];
                this.deck = [];
                this.trump = null;
                this.field = [];
                this.turnIdx = 0; // Кто ходит
                this.state = 'lobby';
                this.winner = null;
            }

            addPlayer(id, name, ava) {
                if (this.players.length >= this.mode) return false;
                this.players.push({ id, name, ava, hand: [] });
                return true;
            }

            start() {
                if (this.players.length !== this.mode) return false;
                
                // Deck Gen
                this.deck = [];
                SUITS.forEach(s => RANKS.forEach(r => this.deck.push({r, s})));
                this.deck.sort(() => Math.random() - 0.5);

                // Deal 6
                this.players.forEach(p => {
                    p.hand = this.deck.splice(0, 6);
                });

                // Trump
                this.trump = this.deck.pop();
                this.deck.unshift(this.trump);

                // First Turn logic (min trump)
                let minVal = 100;
                let firstP = 0;
                const getVal = r => RANKS.indexOf(r);
                
                this.players.forEach((p, idx) => {
                    p.hand.forEach(c => {
                        if(c.s === this.trump.s && getVal(c.r) < minVal) {
                            minVal = getVal(c.r);
                            firstP = idx;
                        }
                    });
                });
                
                this.turnIdx = firstP;
                this.state = 'game';
                return true;
            }

            // Utils
            getNextP(offset = 1) { return (this.turnIdx + offset) % this.mode; }
            canBeat(att, def) {
                if(att.s === def.s) return RANKS.indexOf(def.r) > RANKS.indexOf(att.r);
                return def.s === this.trump.s;
            }

            // Actions
            move(pIndex, type, data) {
                if (this.state !== 'game') return;
                const p = this.players[pIndex];

                if (type === 'ATTACK') {
                    if (pIndex !== this.turnIdx) return; // Only attacker
                    // Logic: Podkidnoy logic (rank match) or empty field
                    const card = p.hand[data.idx];
                    if (this.field.length > 0) {
                        const ranks = new Set(this.field.flatMap(s => [s.att.r, s.def?.r].filter(Boolean)));
                        if (!ranks.has(card.r)) return;
                    }
                    
                    // Limits
                    const defenderIdx = this.getNextP();
                    const defender = this.players[defenderIdx];
                    const openSlots = this.field.filter(s => !s.def).length;
                    if (openSlots >= defender.hand.length) return; // Cannot attack more than defender has
                    if (this.field.length >= 6) return;

                    // Execute
                    p.hand.splice(data.idx, 1);
                    this.field.push({ att: card, def: null });
                    return true;
                }

                if (type === 'DEFEND') {
                    if (pIndex !== this.getNextP()) return; // Only defender
                    const slot = this.field[data.slot];
                    if (!slot || slot.def) return;
                    
                    const card = p.hand[data.idx];
                    if (this.canBeat(slot.att, card)) {
                        p.hand.splice(data.idx, 1);
                        slot.def = card;
                        return true;
                    }
                }

                if (type === 'BITO') {
                    if (pIndex !== this.turnIdx) return; // Attacker decides Bito
                    if (this.field.length === 0 || this.field.some(s => !s.def)) return;
                    
                    this.field = [];
                    this.drawCards();
                    this.turnIdx = this.getNextP(); // Turn passes to defender (who successfully defended)
                    return true;
                }

                if (type === 'TAKE') {
                    if (pIndex !== this.getNextP()) return; // Defender takes
                    
                    // Collect all
                    this.field.forEach(s => {
                        p.hand.push(s.att);
                        if(s.def) p.hand.push(s.def);
                    });
                    this.field = [];
                    this.drawCards(true); // Attacker draws, Defender (p) doesn't
                    
                    this.turnIdx = this.getNextP(2); // Turn skips defender who took
                    if(this.mode === 2) this.turnIdx = this.getNextP(1); // In 2p, attacker goes again? No, usually next player. If 2p, next is Attacker.
                    // Correct Durak rules: If defender takes, next player (attacker) goes. In 2p, that's the same attacker.
                    // My logic `getNextP(2)` implies skipping.
                    // 2P: 0 attacks 1. 1 takes. Next turn: 0. (0+2)%2 = 0. Correct.
                    // 3P: 0 attacks 1. 1 takes. Next turn: 2. (0+2)%3 = 2. Correct.
                    return true;
                }
            }

            drawCards(skipDefender = false) {
                // Order: Attacker, then others, finally Defender (if didn't take)
                // Simply fill everyone in order starting from Attacker
                const order = [];
                for(let i=0; i<this.mode; i++) order.push((this.turnIdx + i) % this.mode);
                
                order.forEach(pIdx => {
                    if(skipDefender && pIdx === this.getNextP()) return; // Logic implies turnIdx hasn't changed yet
                    const p = this.players[pIdx];
                    while(p.hand.length < 6 && this.deck.length > 0) {
                        p.hand.push(this.deck.pop());
                    }
                });
                
                // Check Win
                if(this.deck.length === 0) {
                    this.players.forEach(p => {
                        if(p.hand.length === 0 && !this.winner) this.winner = p.name;
                    });
                }
            }

            getSnapshot() {
                return {
                    deck: this.deck.length,
                    trump: this.trump,
                    field: this.field,
                    turn: this.turnIdx,
                    players: this.players.map(p => ({ name: p.name, ava: p.ava, cards: p.hand.length, id: p.id })),
                    winner: this.winner
                };
            }
        }

        // --- КЛИЕНТ ---
        const Lobby = {
            ava: 1,
            mode: 2,
            init() {
                const c = document.getElementById('ava-select');
                AVATARS.forEach(i => {
                    const d = document.createElement('div');
                    d.className = 'ava-option' + (i===1?' active':'');
                    d.style.backgroundImage = `url('https://robohash.org/${i}.png?set=set2')`;
                    d.style.backgroundSize = 'cover';
                    d.onclick = () => {
                        this.ava = i;
                        document.querySelectorAll('.ava-option').forEach(e=>e.classList.remove('active'));
                        d.classList.add('active');
                    };
                    c.appendChild(d);
                });
            },
            setMode(n) {
                this.mode = n;
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                event.target.classList.add('active');
            },
            create() {
                const name = document.getElementById('p-name').value || "Host";
                Game.initHost(name, this.ava, this.mode);
            },
            join() {
                const name = document.getElementById('p-name').value || "Guest";
                const id = document.getElementById('join-code').value;
                if(!id) return alert("Введите код");
                Game.initClient(name, this.ava, id);
            }
        };

        const Game = {
            peer: null,
            conns: [], // For host: list of connections
            conn: null, // For client: connection to host
            role: null, // 'host' or 'client'
            engine: null, // Host only
            
            myId: null,
            state: null,
            myHand: [],
            selIdx: null,

            // HOST START
            initHost(name, ava, mode) {
                this.role = 'host';
                this.engine = new Engine(name, ava, mode);
                this.peer = new Peer();
                
                this.peer.on('open', id => {
                    document.getElementById('panel-setup').style.display = 'none';
                    document.getElementById('panel-wait').style.display = 'block';
                    document.getElementById('host-id-disp').value = id;
                });

                this.peer.on('connection', conn => {
                    conn.on('open', () => {
                        this.conns.push(conn);
                        // Handshake wait
                    });
                    conn.on('data', data => {
                        if (data.t === 'JOIN') {
                            const added = this.engine.addPlayer(conn.peer, data.name, data.ava);
                            if(added) {
                                this.broadcast({ t: 'CHAT', msg: `Игрок ${data.name} подключился`, sys: true });
                                this.updateWaitStatus();
                                if (this.engine.players.length === this.engine.mode) {
                                    this.engine.start();
                                    this.syncAll();
                                }
                            } else {
                                conn.close(); // Room full
                            }
                        }
                        if (data.t === 'ACT') {
                            // Find player index
                            const pIdx = this.engine.players.findIndex(p => p.id === conn.peer);
                            if (pIdx > -1) {
                                if(this.engine.move(pIdx, data.act, data.d)) this.syncAll();
                            }
                        }
                        if (data.t === 'CHAT') {
                            this.broadcast(data); // Re-broadcast
                        }
                    });
                });
            },

            updateWaitStatus() {
                document.getElementById('wait-status').innerText = `${this.conns.length}/${this.engine.mode - 1} подключено`;
            },

            // CLIENT START
            initClient(name, ava, hostId) {
                this.role = 'client';
                this.peer = new Peer();
                this.peer.on('open', id => {
                    this.conn = this.peer.connect(hostId);
                    this.conn.on('open', () => {
                        this.conn.send({ t: 'JOIN', name, ava });
                        document.getElementById('lobby').style.display = 'none'; // Wait for sync
                        document.getElementById('game-status').innerText = "Подключение...";
                    });
                    this.conn.on('data', data => this.handleData(data));
                });
            },

            // SYNC LOGIC
            syncAll() {
                if (this.role !== 'host') return;
                const snap = this.engine.getSnapshot();
                
                // 1. Host UI update
                this.state = snap;
                this.myHand = this.engine.players[0].hand;
                this.myId = 'host'; // internal ID
                this.render();

                // 2. Send to clients
                this.conns.forEach(c => {
                    const pIdx = this.engine.players.findIndex(p => p.id === c.peer);
                    c.send({
                        t: 'SYNC',
                        snap: snap,
                        hand: this.engine.players[pIdx].hand,
                        pid: c.peer
                    });
                });
            },

            handleData(data) {
                if (data.t === 'SYNC') {
                    document.getElementById('lobby').style.display = 'none';
                    document.getElementById('game').style.display = 'flex';
                    this.state = data.snap;
                    this.myHand = data.hand;
                    this.myId = data.pid;
                    this.render();
                }
                if (data.t === 'CHAT') {
                    this.renderChat(data);
                }
            },

            // ACTIONS
            act(type, pl = {}) {
                if (this.role === 'host') {
                    if (this.engine.move(0, type, pl)) this.syncAll();
                } else {
                    this.conn.send({ t: 'ACT', act: type, d: pl });
                }
            },

            sendChat() {
                const inp = document.getElementById('chat-in');
                const txt = inp.value.trim();
                if(!txt) return;
                
                const myName = this.role==='host' ? this.engine.players[0].name : 'Me'; // Name handled by broadcast
                // Actually easier to just send to host, host fills name
                
                if (this.role === 'host') {
                    const msg = { t: 'CHAT', name: this.engine.players[0].name, msg: txt };
                    this.renderChat(msg);
                    this.broadcast(msg);
                } else {
                    this.conn.send({ t: 'CHAT', name: "PLACEHOLDER", msg: txt }); // Host uses stored name map if implemented, or passes client name
                }
                inp.value = '';
            },

            broadcast(data) {
                this.conns.forEach(c => c.send(data));
                if(data.t === 'CHAT') this.renderChat(data); // Host renders own broadcast
            },

            // RENDERER
            render() {
                const s = this.state;
                if (!s) return;

                if (s.winner) {
                    alert(`Победил ${s.winner}!`);
                    location.reload();
                    return;
                }

                // 1. Determine My Index
                let myIdx = s.players.findIndex(p => p.id === this.myId);
                if (myIdx === -1 && this.role === 'host') myIdx = 0;

                // 2. Render Opponents (Relative)
                const oppContainer = document.getElementById('top-opponents');
                oppContainer.innerHTML = '';
                
                const count = s.players.length;
                // Loop through other players
                for(let i = 1; i < count; i++) {
                    const oppIdx = (myIdx + i) % count;
                    const p = s.players[oppIdx];
                    const isTurn = (s.turn === oppIdx);

                    const div = document.createElement('div');
                    div.className = 'opponent ' + (isTurn ? '' : 'inactive');
                    div.innerHTML = `
                        <img class="opp-ava" src="https://robohash.org/${p.ava}.png?set=set2" style="${isTurn ? 'border-color:#ffeb3b' : ''}">
                        <div class="opp-name">${p.name}</div>
                        <div class="opp-hand">
                            ${Array(p.cards).fill('<div class="card-mini"></div>').join('')}
                        </div>
                    `;
                    oppContainer.appendChild(div);
                }

                // 3. Deck & Trump
                const deckCount = document.getElementById('deck-num');
                deckCount.innerText = s.deck;
                const tPh = document.getElementById('trump-ph');
                const dPh = document.getElementById('deck-ph');
                tPh.innerHTML = '';
                
                if (s.deck > 0 || s.trump) {
                    const tr = document.createElement('div');
                    tr.className = 'card trump-card';
                    tr.style.backgroundImage = `url('${IMG_API(s.trump.r, s.trump.s)}')`;
                    tPh.appendChild(tr);
                }
                dPh.style.display = s.deck > 1 ? 'block' : 'none';

                // 4. Table
                const tbl = document.getElementById('table-slots');
                tbl.innerHTML = '';
                s.field.forEach((slot, slotIdx) => {
                    const d = document.createElement('div');
                    d.className = 'slot';
                    
                    const c1 = document.createElement('div');
                    c1.className = 'card slot-att';
                    c1.style.backgroundImage = `url('${IMG_API(slot.att.r, slot.att.s)}')`;
                    d.appendChild(c1);

                    if (slot.def) {
                        const c2 = document.createElement('div');
                        c2.className = 'card slot-def';
                        c2.style.backgroundImage = `url('${IMG_API(slot.def.r, slot.def.s)}')`;
                        d.appendChild(c2);
                    } else {
                        // Dropzone for defender
                        if (s.turn !== myIdx && this.selIdx !== null) {
                            // Logic check: Am I the defender?
                            const defenderIdx = (s.turn + 1) % count;
                            if (myIdx === defenderIdx) {
                                d.style.cursor = 'pointer';
                                d.style.boxShadow = 'inset 0 0 20px #ffeb3b';
                                d.onclick = () => {
                                    this.act('DEFEND', { idx: this.selIdx, slot: slotIdx });
                                    this.selIdx = null;
                                };
                            }
                        }
                    }
                    tbl.appendChild(d);
                });

                // 5. My Hand
                const handContainer = document.getElementById('my-hand');
                handContainer.innerHTML = '';
                const myInfo = s.players[myIdx];
                document.getElementById('my-ava-img').src = `https://robohash.org/${myInfo.ava}.png?set=set2`;
                if(s.turn === myIdx) document.getElementById('my-ava-img').style.borderColor = '#ffeb3b';
                else document.getElementById('my-ava-img').style.borderColor = 'transparent';

                this.myHand.forEach((c, i) => {
                    const wrap = document.createElement('div');
                    wrap.className = 'my-card-wrap';
                    const el = document.createElement('div');
                    el.className = 'card';
                    if (this.selIdx === i) el.classList.add('selected');
                    el.style.backgroundImage = `url('${IMG_API(c.r, c.s)}')`;
                    
                    el.onclick = () => {
                        if (s.turn === myIdx) {
                            this.act('ATTACK', { idx: i });
                        } else {
                            // Select
                            this.selIdx = (this.selIdx === i) ? null : i;
                            this.render();
                        }
                    };
                    wrap.appendChild(el);
                    handContainer.appendChild(wrap);
                });

                // 6. Controls
                const btnBito = document.getElementById('btn-bito');
                const btnTake = document.getElementById('btn-take');
                const msg = document.getElementById('game-status');
                
                btnBito.style.display = 'none';
                btnTake.style.display = 'none';

                if (s.turn === myIdx) {
                    msg.innerText = "ВАШ ХОД (Атака)";
                    msg.style.borderLeftColor = '#81c784';
                    // Check if can bito
                    const allDef = s.field.length > 0 && s.field.every(x => x.def);
                    if (allDef) btnBito.style.display = 'block';
                } else {
                    const defenderIdx = (s.turn + 1) % count;
                    if (myIdx === defenderIdx) {
                        msg.innerText = "ВАШ ХОД (Защита)";
                        msg.style.borderLeftColor = '#ffb74d';
                        if (s.field.some(x => !x.def)) btnTake.style.display = 'block';
                    } else {
                        msg.innerText = "Ожидание...";
                        msg.style.borderLeftColor = '#ccc';
                    }
                }
            },

            renderChat(data) {
                const log = document.getElementById('chat-log');
                const d = document.createElement('div');
                
                // --- FIX: Безопасная проверка "я ли это" ---
                let isMe = false;
                if (this.state && this.state.players) {
                     const myP = this.state.players.find(p => p.id === this.myId);
                     if (myP && data.name === myP.name) isMe = true;
                }
                
                d.className = 'chat-msg' + (isMe ? ' me' : '');
                if (data.sys) {
                    d.style.background = 'transparent';
                    d.style.fontStyle = 'italic';
                    d.innerHTML = data.msg;
                } else {
                    d.innerHTML = `<b>${data.name}:</b> ${data.msg}`;
                }
                log.appendChild(d);
                log.scrollTop = log.scrollHeight;
            }
        };

        // Key bindings
        document.getElementById('chat-in').addEventListener('keypress', e => {
            if(e.key === 'Enter') Game.sendChat();
        });

        Lobby.init();
    </script>
</body>
</html>
