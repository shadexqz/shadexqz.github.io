<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tweeyer | Secure P2P Messenger</title>
    
    <!-- Fonts: Inter for Swiss Design -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: { sans: ['Inter', 'sans-serif'] },
                    colors: {
                        brand: { light: '#007AFF', dark: '#0A84FF' },
                        slate: { 850: '#1C1C1E', 900: '#151516' }
                    }
                }
            }
        }
    </script>

    <!-- Vue 3 & PeerJS -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #CBD5E1; border-radius: 3px; }
        .dark ::-webkit-scrollbar-thumb { background: #475569; }
        
        /* Audio Player Styling */
        audio::-webkit-media-controls-panel { background-color: #f1f5f9; }
        .dark audio::-webkit-media-controls-panel { background-color: #334155; }
        
        /* Smooth Transitions */
        .fade-enter-active, .fade-leave-active { transition: opacity 0.3s ease; }
        .fade-enter-from, .fade-leave-to { opacity: 0; }
        
        /* Loader */
        .loader { border: 3px solid #f3f3f3; border-top: 3px solid #3498db; border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="antialiased text-slate-800 bg-white dark:bg-slate-850 dark:text-slate-200 transition-colors duration-300 overflow-hidden">

<div id="app" class="h-screen w-screen flex flex-col md:flex-row relative">

    <!-- ==================== ONBOARDING MODAL ==================== -->
    <div v-if="!user.setupComplete" class="absolute inset-0 z-50 bg-white dark:bg-slate-850 flex items-center justify-center p-4">
        <div class="max-w-md w-full bg-slate-50 dark:bg-[#2C2C2E] p-8 rounded-2xl shadow-xl border border-slate-200 dark:border-slate-700">
            <h1 class="text-2xl font-semibold mb-2">{{ t('welcome_title') }}</h1>
            <p class="text-slate-500 text-sm mb-6">{{ t('welcome_sub') }}</p>
            
            <!-- Avatar Upload -->
            <div class="flex justify-center mb-6 relative group cursor-pointer" @click="$refs.avatarInput.click()">
                <div class="w-24 h-24 rounded-full overflow-hidden border-2 border-slate-200 dark:border-slate-600 bg-slate-200 relative">
                    <img v-if="tempAvatar" :src="tempAvatar" class="w-full h-full object-cover">
                    <div v-else class="flex items-center justify-center h-full text-slate-400 text-3xl">
                        <i class="fa-solid fa-camera"></i>
                    </div>
                    <div class="absolute inset-0 bg-black/30 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                        <i class="fa-solid fa-pen text-white"></i>
                    </div>
                </div>
                <input type="file" ref="avatarInput" @change="handleAvatarUpload" accept="image/*" class="hidden">
            </div>

            <div class="space-y-4">
                <div>
                    <label class="block text-xs font-semibold uppercase text-slate-400 mb-1">{{ t('nickname') }}</label>
                    <input v-model="tempName" type="text" class="w-full px-4 py-3 rounded-xl bg-white dark:bg-black/20 border border-slate-200 dark:border-slate-600 focus:outline-none focus:border-brand-light transition-colors" placeholder="e.g. Alex Doe">
                </div>
                <button @click="finishSetup" :disabled="!tempName.trim()" class="w-full py-3 bg-brand-light hover:bg-blue-600 text-white font-medium rounded-xl transition-colors disabled:opacity-50 disabled:cursor-not-allowed">
                    {{ t('start_messaging') }}
                </button>
            </div>
        </div>
    </div>

    <!-- ==================== SIDEBAR ==================== -->
    <aside class="w-full md:w-80 flex-shrink-0 bg-slate-50 dark:bg-[#161618] border-r border-slate-200 dark:border-slate-700 flex flex-col h-full z-10" :class="{'hidden md:flex': mobileView === 'chat'}">
        
        <!-- My Profile Header -->
        <div class="p-4 border-b border-slate-200 dark:border-slate-700 flex items-center gap-3">
            <div class="w-10 h-10 rounded-full bg-slate-300 overflow-hidden cursor-pointer hover:opacity-80 transition" @click="ui.showEditProfile = true">
                <img :src="user.avatar || defaultAvatar" class="w-full h-full object-cover">
            </div>
            <div class="flex-1 min-w-0">
                <h3 class="font-semibold truncate">{{ user.name }}</h3>
                <div class="flex items-center gap-2 text-xs text-slate-500">
                    <span class="w-2 h-2 rounded-full" :class="isConnected ? 'bg-green-500' : 'bg-red-500'"></span>
                    {{ isConnected ? t('online') : t('offline') }}
                </div>
            </div>
            <button @click="toggleTheme" class="w-8 h-8 rounded-full flex items-center justify-center hover:bg-slate-200 dark:hover:bg-slate-700 transition">
                <i class="fa-solid" :class="settings.theme === 'dark' ? 'fa-sun' : 'fa-moon'"></i>
            </button>
        </div>

        <!-- Connection Panel -->
        <div class="p-4 flex-1 overflow-y-auto">
            
            <!-- My ID -->
            <div class="mb-6 p-4 bg-white dark:bg-[#2C2C2E] rounded-xl border border-slate-200 dark:border-slate-700 shadow-sm">
                <label class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-2 block">{{ t('my_id') }}</label>
                <div class="flex items-center gap-2 bg-slate-50 dark:bg-black/20 p-2 rounded-lg border border-slate-200 dark:border-slate-600">
                    <span class="text-sm font-mono flex-1 truncate select-all">{{ myPeerId || t('generating') }}</span>
                    <button @click="copyId" class="text-brand-light hover:text-brand-dark px-2">
                        <i class="fa-regular fa-copy"></i>
                    </button>
                </div>
            </div>

            <!-- Connect To -->
            <div class="mb-6">
                <label class="text-xs font-bold text-slate-400 uppercase tracking-wider mb-2 block">{{ t('connect_to') }}</label>
                <div class="flex gap-2">
                    <input v-model="targetId" type="text" :placeholder="t('enter_id')" class="flex-1 px-3 py-2 text-sm rounded-lg bg-white dark:bg-[#2C2C2E] border border-slate-200 dark:border-slate-600 focus:border-brand-light outline-none">
                    <button @click="connectToPeer" :disabled="!myPeerId || isConnected || !targetId" class="bg-slate-900 dark:bg-white text-white dark:text-black px-4 rounded-lg text-sm font-medium disabled:opacity-50">
                        <i class="fa-solid fa-link"></i>
                    </button>
                </div>
            </div>

            <div class="border-t border-slate-200 dark:border-slate-700 my-4"></div>

            <!-- Settings -->
            <div class="space-y-3">
                <button @click="toggleLang" class="flex items-center gap-3 w-full p-2 rounded-lg hover:bg-slate-200 dark:hover:bg-slate-700 transition">
                    <div class="w-8 h-8 rounded-full bg-brand-light/10 text-brand-light flex items-center justify-center">
                        <i class="fa-solid fa-globe"></i>
                    </div>
                    <span class="text-sm font-medium">{{ settings.lang === 'en' ? 'English' : 'Русский' }}</span>
                </button>
                
                <button @click="clearData" class="flex items-center gap-3 w-full p-2 rounded-lg hover:bg-red-50 dark:hover:bg-red-900/20 text-red-500 transition">
                    <div class="w-8 h-8 rounded-full bg-red-100 dark:bg-red-900/30 flex items-center justify-center">
                        <i class="fa-solid fa-trash"></i>
                    </div>
                    <span class="text-sm font-medium">{{ t('reset_app') }}</span>
                </button>
            </div>
        </div>
    </aside>

    <!-- ==================== CHAT AREA ==================== -->
    <main class="flex-1 flex flex-col bg-white dark:bg-[#000000] h-full" :class="{'hidden md:flex': mobileView === 'sidebar'}">
        
        <!-- Header -->
        <header class="h-16 flex-shrink-0 border-b border-slate-100 dark:border-slate-800 flex items-center justify-between px-4 md:px-6">
            <div class="flex items-center gap-3">
                <button @click="mobileView = 'sidebar'" class="md:hidden text-slate-500 mr-2">
                    <i class="fa-solid fa-arrow-left"></i>
                </button>
                
                <div v-if="isConnected" class="flex items-center gap-3">
                    <div class="w-10 h-10 rounded-full bg-slate-200 overflow-hidden">
                        <img :src="partner.avatar || defaultAvatar" class="w-full h-full object-cover">
                    </div>
                    <div>
                        <h2 class="font-semibold text-sm md:text-base">{{ partner.name || 'Unknown User' }}</h2>
                        <span class="text-xs text-green-500 font-medium">{{ t('connected_status') }}</span>
                    </div>
                </div>
                <div v-else class="flex items-center gap-3 opacity-50">
                    <div class="w-10 h-10 rounded-full bg-slate-200 dark:bg-slate-800 animate-pulse"></div>
                    <span class="text-sm font-medium">{{ t('waiting_connection') }}</span>
                </div>
            </div>
        </header>

        <!-- Messages List -->
        <div ref="chatContainer" class="flex-1 overflow-y-auto p-4 md:p-6 space-y-6">
            <div v-if="messages.length === 0" class="h-full flex flex-col items-center justify-center text-slate-300 dark:text-slate-700">
                <i class="fa-regular fa-comments text-6xl mb-4"></i>
                <p>{{ t('no_messages') }}</p>
            </div>

            <div v-for="(msg, idx) in messages" :key="idx" class="flex flex-col max-w-[85%] md:max-w-[70%]" :class="msg.sender === 'me' ? 'self-end items-end' : 'self-start items-start'">
                
                <!-- Bubble -->
                <div class="relative px-4 py-2 rounded-2xl shadow-sm overflow-hidden"
                     :class="msg.sender === 'me' 
                        ? 'bg-brand-light text-white rounded-br-none' 
                        : 'bg-slate-100 dark:bg-[#2C2C2E] text-slate-800 dark:text-slate-200 rounded-bl-none'">
                    
                    <!-- Text -->
                    <p v-if="msg.type === 'text'" class="text-sm md:text-base whitespace-pre-wrap">{{ msg.content }}</p>
                    
                    <!-- Image -->
                    <div v-if="msg.type === 'image'" class="rounded-lg overflow-hidden my-1">
                        <img :src="msg.content" class="max-w-full max-h-64 object-cover" @click="openImage(msg.content)">
                    </div>

                    <!-- Voice -->
                    <div v-if="msg.type === 'voice'" class="flex items-center gap-3 min-w-[200px]">
                        <button class="w-8 h-8 rounded-full bg-white/20 flex items-center justify-center hover:bg-white/30 transition">
                            <i class="fa-solid fa-play text-xs"></i>
                        </button>
                        <audio controls :src="msg.content" class="h-8 w-48 opacity-90"></audio>
                    </div>

                    <!-- File -->
                    <div v-if="msg.type === 'file'" class="flex items-center gap-3 p-1">
                        <div class="w-10 h-10 bg-white/20 rounded flex items-center justify-center text-xl">
                            <i class="fa-solid fa-file"></i>
                        </div>
                        <div class="overflow-hidden">
                            <p class="text-xs truncate font-medium w-32">{{ msg.meta.name }}</p>
                            <a :href="msg.content" :download="msg.meta.name" class="text-xs underline opacity-80 hover:opacity-100">{{ t('download') }}</a>
                        </div>
                    </div>

                    <!-- Timestamp -->
                    <div class="text-[10px] mt-1 opacity-60 text-right">
                        {{ formatTime(msg.timestamp) }}
                    </div>
                </div>
            </div>
        </div>

        <!-- Input Area -->
        <footer class="p-4 bg-white dark:bg-[#000000] border-t border-slate-100 dark:border-slate-800">
            <div v-if="!isConnected" class="text-center text-sm text-slate-400 py-2">
                {{ t('connect_first') }}
            </div>
            
            <div v-else class="flex items-end gap-2 relative">
                
                <!-- File Inputs (Hidden) -->
                <input type="file" ref="imageInput" accept="image/*" class="hidden" @change="e => sendFile(e, 'image')">
                <input type="file" ref="fileInput" class="hidden" @change="e => sendFile(e, 'file')">

                <!-- Attachment Menu -->
                <div class="relative">
                    <button @click="ui.showAttachments = !ui.showAttachments" class="w-10 h-10 rounded-full hover:bg-slate-100 dark:hover:bg-slate-800 text-slate-500 transition">
                        <i class="fa-solid fa-paperclip"></i>
                    </button>
                    <!-- Popover -->
                    <div v-if="ui.showAttachments" class="absolute bottom-12 left-0 bg-white dark:bg-[#2C2C2E] shadow-xl rounded-xl p-2 border border-slate-100 dark:border-slate-700 flex flex-col gap-1 w-32 z-20">
                        <button @click="$refs.imageInput.click(); ui.showAttachments = false" class="flex items-center gap-3 px-3 py-2 hover:bg-slate-100 dark:hover:bg-slate-700 rounded-lg text-sm">
                            <i class="fa-regular fa-image text-blue-500"></i> {{ t('photo') }}
                        </button>
                        <button @click="$refs.fileInput.click(); ui.showAttachments = false" class="flex items-center gap-3 px-3 py-2 hover:bg-slate-100 dark:hover:bg-slate-700 rounded-lg text-sm">
                            <i class="fa-regular fa-file text-orange-500"></i> {{ t('file') }}
                        </button>
                    </div>
                </div>

                <!-- Text Input -->
                <div class="flex-1 bg-slate-100 dark:bg-[#1C1C1E] rounded-2xl flex items-center min-h-[44px] border border-transparent focus-within:border-brand-light focus-within:bg-white dark:focus-within:bg-[#1C1C1E] transition-all">
                    <textarea 
                        v-model="inputMessage" 
                        @keydown.enter.prevent="sendMessage"
                        rows="1"
                        :placeholder="t('type_message')"
                        class="w-full bg-transparent px-4 py-3 max-h-32 text-sm focus:outline-none resize-none"
                        style="min-height: 44px;"
                    ></textarea>
                </div>

                <!-- Mic / Send Button -->
                <div v-if="inputMessage.trim()">
                    <button @click="sendMessage" class="w-10 h-10 rounded-full bg-brand-light text-white flex items-center justify-center hover:bg-blue-600 transition shadow-md shadow-blue-500/30">
                        <i class="fa-solid fa-paper-plane text-sm"></i>
                    </button>
                </div>
                <div v-else>
                    <button 
                        @mousedown="startRecording" 
                        @mouseup="stopRecording" 
                        @mouseleave="cancelRecording"
                        @touchstart.prevent="startRecording"
                        @touchend.prevent="stopRecording"
                        class="w-10 h-10 rounded-full flex items-center justify-center transition"
                        :class="ui.isRecording ? 'bg-red-500 text-white animate-pulse' : 'hover:bg-slate-100 dark:hover:bg-slate-800 text-slate-500'"
                    >
                        <i class="fa-solid" :class="ui.isRecording ? 'fa-stop' : 'fa-microphone'"></i>
                    </button>
                </div>

            </div>
            
            <!-- Recording Indicator -->
            <div v-if="ui.isRecording" class="absolute bottom-20 left-1/2 -translate-x-1/2 bg-red-500 text-white px-4 py-2 rounded-full shadow-lg text-xs font-bold animate-pulse">
                Recording... {{ ui.recordingTime }}s
            </div>
        </footer>

    </main>
    
    <!-- Image Modal -->
    <div v-if="ui.zoomedImage" @click="ui.zoomedImage = null" class="fixed inset-0 z-50 bg-black/90 flex items-center justify-center p-4">
        <img :src="ui.zoomedImage" class="max-w-full max-h-full rounded shadow-2xl">
    </div>

</div>

<script>
    const { createApp, ref, reactive, computed, onMounted, watch, nextTick } = Vue;

    createApp({
        setup() {
            // --- State ---
            const myPeerId = ref('');
            const targetId = ref('');
            const peer = ref(null);
            const connection = ref(null);
            const mobileView = ref('sidebar'); // sidebar | chat
            const inputMessage = ref('');
            const messages = ref([]);
            
            // Default avatar placeholder (SVG base64)
            const defaultAvatar = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23cbd5e1'%3E%3Cpath d='M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z'/%3E%3C/svg%3E";

            const user = reactive({
                name: '',
                avatar: '',
                setupComplete: false
            });

            const partner = reactive({
                id: '',
                name: '',
                avatar: ''
            });

            const settings = reactive({
                theme: 'light',
                lang: 'en'
            });

            const ui = reactive({
                showEditProfile: false,
                showAttachments: false,
                isRecording: false,
                recordingTime: 0,
                zoomedImage: null
            });

            // Onboarding Vars
            const tempName = ref('');
            const tempAvatar = ref('');
            const avatarInput = ref(null);

            // Audio Rec vars
            let mediaRecorder = null;
            let audioChunks = [];
            let recordInterval = null;

            // --- Translations ---
            const translations = {
                en: {
                    welcome_title: "Setup Profile",
                    welcome_sub: "Create your identity to start chatting securely.",
                    nickname: "Display Name",
                    start_messaging: "Start Messaging",
                    my_id: "My Secure ID",
                    generating: "Generating...",
                    connect_to: "Connect to Friend",
                    enter_id: "Paste ID here...",
                    online: "Online",
                    offline: "Offline",
                    reset_app: "Reset Application",
                    connected_status: "Securely Connected",
                    waiting_connection: "Waiting for connection...",
                    no_messages: "No messages yet",
                    type_message: "Type a message...",
                    connect_first: "Connect to a peer to start chatting",
                    photo: "Photo",
                    file: "File",
                    download: "Download",
                    edit_profile: "Edit Profile"
                },
                ru: {
                    welcome_title: "Настройка профиля",
                    welcome_sub: "Создайте профиль для начала общения.",
                    nickname: "Имя",
                    start_messaging: "Начать общение",
                    my_id: "Мой ID",
                    generating: "Генерация...",
                    connect_to: "Подключиться к другу",
                    enter_id: "Вставьте ID сюда...",
                    online: "В сети",
                    offline: "Не в сети",
                    reset_app: "Сбросить настройки",
                    connected_status: "Подключено",
                    waiting_connection: "Ожидание подключения...",
                    no_messages: "Нет сообщений",
                    type_message: "Введите сообщение...",
                    connect_first: "Подключитесь для начала чата",
                    photo: "Фото",
                    file: "Файл",
                    download: "Скачать",
                    edit_profile: "Ред. профиль"
                }
            };

            const t = (key) => translations[settings.lang][key];

            // --- Persistence ---
            const loadData = () => {
                const savedUser = localStorage.getItem('tweeyer_user');
                const savedSettings = localStorage.getItem('tweeyer_settings');
                
                if (savedUser) {
                    const u = JSON.parse(savedUser);
                    user.name = u.name;
                    user.avatar = u.avatar;
                    user.setupComplete = true;
                }
                
                if (savedSettings) {
                    const s = JSON.parse(savedSettings);
                    settings.theme = s.theme;
                    settings.lang = s.lang;
                    applyTheme();
                } else {
                    // Detect system preference
                    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                        settings.theme = 'dark';
                        applyTheme();
                    }
                }
            };

            const saveData = () => {
                localStorage.setItem('tweeyer_user', JSON.stringify(user));
                localStorage.setItem('tweeyer_settings', JSON.stringify(settings));
            };

            const clearData = () => {
                if(confirm('Reset all data and profile?')) {
                    localStorage.clear();
                    location.reload();
                }
            };

            // --- Theme & Setup ---
            const applyTheme = () => {
                if (settings.theme === 'dark') {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
            };

            const toggleTheme = () => {
                settings.theme = settings.theme === 'dark' ? 'light' : 'dark';
                applyTheme();
                saveData();
            };

            const toggleLang = () => {
                settings.lang = settings.lang === 'en' ? 'ru' : 'en';
                saveData();
            };

            const handleAvatarUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    tempAvatar.value = evt.target.result;
                    // If already setup (edit mode), save immediately
                    if(user.setupComplete) {
                        user.avatar = evt.target.result;
                        saveData();
                        sendInfo(); // Update partner
                    }
                };
                reader.readAsDataURL(file);
            };

            const finishSetup = () => {
                user.name = tempName.value;
                user.avatar = tempAvatar.value;
                user.setupComplete = true;
                saveData();
                initPeer();
            };

            // --- PeerJS Core ---
            const initPeer = () => {
                // We use default public cloud. 
                // Note: ID persistence on public cloud is not guaranteed without own server.
                // We will try to retrieve last ID, but usually we just get a new one.
                peer.value = new Peer(null, {
    debug: 2,
    config: {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' },
            { urls: 'stun:stun2.l.google.com:19302' }
        ]
    }
} 

                peer.value.on('open', (id) => {
                    myPeerId.value = id;
                });

                peer.value.on('connection', (conn) => {
                    handleConnection(conn);
                });

                peer.value.on('error', (err) => {
                    console.error("Peer Error:", err);
                    alert("Connection Error: " + err.type);
                });
            };

            const connectToPeer = () => {
                if (!targetId.value) return;
                const conn = peer.value.connect(targetId.value);
                handleConnection(conn);
            };

            const handleConnection = (conn) => {
                if (connection.value) connection.value.close();
                connection.value = conn;

                connection.value.on('open', () => {
                    // Send my profile info immediately
                    sendInfo();
                    mobileView.value = 'chat';
                });

                connection.value.on('data', (data) => {
                    handleIncomingData(data);
                });

                connection.value.on('close', () => {
                    connection.value = null;
                    partner.name = '';
                    partner.avatar = '';
                    alert('Peer disconnected');
                });
            };

            const sendInfo = () => {
                if (!connection.value) return;
                connection.value.send({
                    type: 'info',
                    payload: { name: user.name, avatar: user.avatar }
                });
            };

            const handleIncomingData = (data) => {
                if (data.type === 'info') {
                    partner.name = data.payload.name;
                    partner.avatar = data.payload.avatar;
                } else {
                    // Message
                    messages.value.push({
                        sender: 'partner',
                        type: data.type,
                        content: data.payload,
                        meta: data.meta,
                        timestamp: Date.now()
                    });
                    scrollToBottom();
                }
            };

            // --- Messaging Logic ---
            const sendMessage = () => {
                if (!inputMessage.value.trim() || !connection.value) return;
                
                const msg = {
                    type: 'text',
                    payload: inputMessage.value,
                    meta: {},
                    timestamp: Date.now()
                };

                connection.value.send(msg);
                messages.value.push({ ...msg, content: msg.payload, sender: 'me' }); // Local echo
                
                inputMessage.value = '';
                scrollToBottom();
            };

            const sendFile = (event, type) => {
                const file = event.target.files[0];
                if (!file || !connection.value) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const base64 = e.target.result;
                    const msg = {
                        type: type,
                        payload: base64,
                        meta: { name: file.name },
                        timestamp: Date.now()
                    };
                    connection.value.send(msg);
                    messages.value.push({ ...msg, content: base64, sender: 'me' });
                    scrollToBottom();
                };
                reader.readAsDataURL(file);
                // Reset input
                event.target.value = '';
            };

            // --- Voice Recording ---
            const startRecording = async () => {
                if(!navigator.mediaDevices) {
                    alert("Microphone access not supported in this environment (needs HTTPS or localhost)");
                    return;
                }
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    ui.isRecording = true;
                    ui.recordingTime = 0;

                    mediaRecorder.ondataavailable = event => {
                        audioChunks.push(event.data);
                    };

                    mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                        // Convert blob to base64 to send via JSON
                        const reader = new FileReader();
                        reader.readAsDataURL(audioBlob);
                        reader.onloadend = () => {
                            const base64data = reader.result;
                            const msg = {
                                type: 'voice',
                                payload: base64data,
                                meta: {},
                                timestamp: Date.now()
                            };
                            if (connection.value) {
                                connection.value.send(msg);
                                messages.value.push({ ...msg, content: base64data, sender: 'me' });
                                scrollToBottom();
                            }
                        };
                        
                        stream.getTracks().forEach(track => track.stop()); // Stop mic
                    };

                    mediaRecorder.start();
                    recordInterval = setInterval(() => { ui.recordingTime++ }, 1000);

                } catch (err) {
                    console.error("Mic Error", err);
                    alert("Microphone access denied.");
                }
            };

            const stopRecording = () => {
                if (mediaRecorder && ui.isRecording) {
                    mediaRecorder.stop();
                    clearInterval(recordInterval);
                    ui.isRecording = false;
                }
            };

            const cancelRecording = () => {
                if (mediaRecorder && ui.isRecording) {
                    // Stop but don't send
                    mediaRecorder.stop(); 
                    mediaRecorder.onstop = null; // Remove handler
                    clearInterval(recordInterval);
                    ui.isRecording = false;
                }
            };

            // --- Utils ---
            const chatContainer = ref(null);
            
            const scrollToBottom = async () => {
                await nextTick();
                if (chatContainer.value) {
                    chatContainer.value.scrollTop = chatContainer.value.scrollHeight;
                }
            };

            const copyId = () => {
                navigator.clipboard.writeText(myPeerId.value);
            };

            const formatTime = (ts) => {
                return new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            };
            
            const openImage = (src) => {
                ui.zoomedImage = src;
            };

            // --- Lifecycle ---
            onMounted(() => {
                loadData();
                if (user.setupComplete) {
                    initPeer();
                }
            });

            const isConnected = computed(() => connection.value && connection.value.open);

            return {
                user, partner, settings, ui, messages,
                myPeerId, targetId, inputMessage,
                mobileView, isConnected,
                tempName, tempAvatar,
                defaultAvatar,
                translations, t,
                toggleTheme, toggleLang,
                handleAvatarUpload, finishSetup,
                connectToPeer, copyId, clearData,
                sendMessage, sendFile,
                startRecording, stopRecording, cancelRecording,
                chatContainer, openImage, formatTime,
                // Refs
                avatarInput
            };
        }
    }).mount('#app');
</script>
</body>
</html>
