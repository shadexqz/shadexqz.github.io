<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tweeyer | Stable Build</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: { sans: ['Inter', 'sans-serif'] },
                    colors: {
                        tg: { blue: '#3390ec', chat: '#f4f4f5', self: '#eeffde' }
                    }
                }
            }
        };
    </script>
    <style>
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-thumb { background: #bbb; border-radius: 2px; }
        .dark ::-webkit-scrollbar-thumb { background: #444; }
    </style>
</head>
<body class="bg-white dark:bg-[#1a1a1a] text-gray-800 dark:text-gray-200 h-[100dvh] w-screen overflow-hidden text-sm md:text-base">

<div id="app" class="h-full flex flex-col md:flex-row relative">

    <!-- DEBUG CONSOLE (Hidden by default) -->
    <div v-if="ui.showDebug" class="fixed top-0 left-0 w-full h-1/3 bg-black/90 text-green-400 font-mono text-xs p-4 z-[9999] overflow-y-auto border-b border-green-500">
        <div class="flex justify-between mb-2 sticky top-0 bg-black/90 pb-2 border-b border-white/20">
            <h3 class="font-bold">SYSTEM LOGS</h3>
            <button @click="ui.showDebug = false" class="text-white">CLOSE [X]</button>
        </div>
        <div v-for="(log, i) in logs" :key="i" class="mb-1">
            <span class="opacity-50">[{{ log.time }}]</span> 
            <span :class="{'text-red-500 font-bold': log.type === 'error', 'text-yellow-400': log.type === 'warn'}">{{ log.msg }}</span>
        </div>
    </div>

    <!-- ONBOARDING -->
    <div v-if="!user.setupComplete" class="absolute inset-0 z-50 bg-white dark:bg-[#1a1a1a] flex items-center justify-center p-4">
        <div class="w-full max-w-sm text-center">
            <div class="w-20 h-20 bg-tg-blue rounded-full mx-auto mb-4 flex items-center justify-center text-white text-3xl shadow-lg shadow-blue-500/30">
                <i class="fa-regular fa-paper-plane"></i>
            </div>
            <h1 class="text-xl font-bold mb-6">Tweeyer Setup</h1>
            
            <div class="relative w-20 h-20 mx-auto mb-4" @click="$refs.avaInput.click()">
                <img :src="tempAvatar || defaultAvatar" class="w-full h-full rounded-full object-cover border-2 border-gray-200">
                <div class="absolute bottom-0 right-0 bg-tg-blue text-white w-6 h-6 rounded-full flex items-center justify-center text-xs border border-white">
                    <i class="fa-solid fa-camera"></i>
                </div>
            </div>
            <input type="file" ref="avaInput" @change="handleAvatar" accept="image/*" class="hidden">

            <input v-model="tempName" placeholder="Твое имя" class="w-full p-3 bg-gray-100 dark:bg-[#2c2c2c] rounded-xl mb-4 text-center outline-none focus:ring-2 focus:ring-tg-blue">
            <button @click="finishSetup" :disabled="!tempName" class="w-full bg-tg-blue text-white py-3 rounded-xl font-bold disabled:opacity-50">Начать</button>
        </div>
    </div>

    <!-- SIDEBAR -->
    <aside class="w-full md:w-80 bg-white dark:bg-[#212121] border-r dark:border-[#2f2f2f] flex flex-col z-20 absolute md:relative h-full transition-transform duration-300" 
           :class="mobileView === 'chat' ? '-translate-x-full md:translate-x-0' : 'translate-x-0'">
        
        <div class="p-4 border-b dark:border-[#2f2f2f] flex items-center justify-between">
            <div class="flex items-center gap-3">
                <img :src="user.avatar || defaultAvatar" class="w-10 h-10 rounded-full object-cover">
                <div>
                    <div class="font-bold leading-tight">{{ user.name }}</div>
                    <div class="text-xs font-mono opacity-60 flex items-center gap-1">
                        <span class="w-2 h-2 rounded-full" :class="peerId ? 'bg-green-500' : 'bg-red-500'"></span>
                        {{ statusText }}
                    </div>
                </div>
            </div>
            <div class="flex gap-2">
                <button @click="ui.showDebug = !ui.showDebug" class="w-8 h-8 rounded-full bg-gray-100 dark:bg-white/10 flex items-center justify-center">
                    <i class="fa-solid fa-bug text-xs"></i>
                </button>
                <button @click="toggleTheme" class="w-8 h-8 rounded-full bg-gray-100 dark:bg-white/10 flex items-center justify-center">
                    <i class="fa-solid" :class="theme === 'dark' ? 'fa-sun' : 'fa-moon'"></i>
                </button>
            </div>
        </div>

        <div class="p-4 bg-gray-50 dark:bg-[#1a1a1a]">
            <label class="text-xs font-bold uppercase text-gray-400 block mb-1">Мой ID (Кидай другу)</label>
            <div class="flex bg-white dark:bg-[#2c2c2c] p-2 rounded border dark:border-[#3a3a3a] mb-4">
                <input readonly :value="peerId" class="flex-1 bg-transparent text-xs font-mono outline-none text-tg-blue" @click="copyId">
                <i class="fa-regular fa-copy text-gray-400 cursor-pointer hover:text-tg-blue" @click="copyId"></i>
            </div>

            <label class="text-xs font-bold uppercase text-gray-400 block mb-1">ID Друга</label>
            <div class="flex gap-2">
                <input v-model="targetId" placeholder="Вставь ID сюда..." class="flex-1 bg-white dark:bg-[#2c2c2c] p-2 rounded border dark:border-[#3a3a3a] outline-none text-sm font-mono">
                <button @click="connect" :disabled="!peerId || connecting" class="bg-tg-blue text-white px-3 rounded hover:bg-blue-600 disabled:opacity-50">
                    <i class="fa-solid" :class="connecting ? 'fa-spinner fa-spin' : 'fa-link'"></i>
                </button>
            </div>
            <div v-if="connError" class="mt-2 text-xs text-red-500 font-bold bg-red-100 p-2 rounded">
                {{ connError }}
            </div>
        </div>

        <div class="flex-1 overflow-y-auto p-2">
            <div v-if="connection && connection.open" class="p-3 bg-tg-blue/10 rounded-xl border-l-4 border-tg-blue cursor-pointer" @click="mobileView = 'chat'">
                <div class="flex justify-between items-center">
                    <span class="font-bold">{{ partner.name || 'Собеседник' }}</span>
                    <span class="text-xs text-green-600 font-bold">ONLINE</span>
                </div>
                <div class="text-xs text-gray-500 truncate mt-1">Нажмите, чтобы открыть чат</div>
            </div>
            <div v-else class="text-center mt-10 opacity-40">
                <i class="fa-solid fa-users-slash text-3xl mb-2"></i>
                <p class="text-xs">Нет подключений</p>
            </div>
        </div>
    </aside>

    <!-- CHAT AREA -->
    <main class="flex-1 flex flex-col bg-[#eef2f5] dark:bg-[#0f0f0f] relative w-full h-full" 
          :class="mobileView === 'sidebar' ? 'translate-x-full md:translate-x-0 hidden md:flex' : 'translate-x-0'">
        
        <!-- Header -->
        <header class="h-14 bg-white dark:bg-[#212121] border-b dark:border-[#2f2f2f] flex items-center px-4 gap-3 z-10 shadow-sm">
            <button @click="mobileView = 'sidebar'" class="md:hidden text-gray-500"><i class="fa-solid fa-arrow-left"></i></button>
            <div class="flex items-center gap-3">
                <div class="w-9 h-9 rounded-full bg-gray-300 overflow-hidden">
                    <img v-if="partner.avatar" :src="partner.avatar" class="w-full h-full object-cover">
                </div>
                <div>
                    <div class="font-bold text-sm">{{ partner.name || 'Ожидание...' }}</div>
                    <div class="text-xs" :class="connection && connection.open ? 'text-green-500' : 'text-gray-400'">
                        {{ connection && connection.open ? 'В сети' : 'Не подключено' }}
                    </div>
                </div>
            </div>
            <div class="ml-auto flex gap-4">
                <button v-if="connection && connection.open" @click="callUser" class="text-tg-blue hover:scale-110 transition"><i class="fa-solid fa-phone"></i></button>
            </div>
        </header>

        <!-- Messages -->
        <div ref="chatBox" class="flex-1 overflow-y-auto p-4 space-y-2">
            <div v-for="(msg, i) in messages" :key="i" class="flex flex-col" :class="msg.sender === 'me' ? 'items-end' : 'items-start'">
                <div class="max-w-[75%] px-3 py-2 rounded-lg text-sm shadow-sm break-words relative group"
                     :class="msg.sender === 'me' ? 'bg-[#eeffde] dark:bg-tg-blue dark:text-white rounded-br-none' : 'bg-white dark:bg-[#212121] rounded-bl-none'">
                    
                    <p v-if="msg.type === 'text'">{{ msg.content }}</p>
                    <img v-if="msg.type === 'image'" :src="msg.content" class="rounded max-h-60 max-w-full cursor-pointer" @click="openZoom(msg.content)">
                    
                    <div v-if="msg.type === 'voice'" class="flex items-center gap-2 min-w-[150px]">
                         <button @click="playAudio(msg.content)" class="w-6 h-6 rounded-full bg-black/10 flex items-center justify-center"><i class="fa-solid fa-play text-xs"></i></button>
                         <div class="h-1 flex-1 bg-black/10 rounded-full"></div>
                    </div>

                    <div class="text-[10px] text-right mt-1 opacity-50">{{ formatTime(msg.timestamp) }}</div>
                </div>
            </div>
        </div>

        <!-- Input -->
        <footer class="bg-white dark:bg-[#212121] p-2 flex items-end gap-2 border-t dark:border-[#2f2f2f]">
             <div class="relative">
                <button @click="ui.showAttach = !ui.showAttach" class="w-10 h-10 text-gray-400 hover:text-tg-blue"><i class="fa-solid fa-paperclip"></i></button>
                <div v-if="ui.showAttach" class="absolute bottom-12 left-0 bg-white dark:bg-[#333] shadow-xl border dark:border-[#444] rounded-lg p-2 flex flex-col gap-2 w-32">
                    <button @click="$refs.imgInput.click(); ui.showAttach=false" class="text-left px-2 py-1 hover:bg-gray-100 dark:hover:bg-white/10 rounded"><i class="fa-regular fa-image mr-2"></i>Фото</button>
                </div>
                <input type="file" ref="imgInput" class="hidden" accept="image/*" @change="sendImage">
            </div>

            <textarea v-model="text" @keydown.enter.prevent="sendText" rows="1" placeholder="Сообщение..." class="flex-1 bg-gray-100 dark:bg-[#2c2c2c] rounded-2xl px-4 py-2.5 outline-none resize-none max-h-32"></textarea>
            
            <button v-if="text.trim()" @click="sendText" class="w-10 h-10 rounded-full bg-tg-blue text-white flex items-center justify-center hover:bg-blue-600 transition">
                <i class="fa-solid fa-paper-plane"></i>
            </button>
            <button v-else @mousedown="startRec" @mouseup="stopRec" @touchstart.prevent="startRec" @touchend.prevent="stopRec" class="w-10 h-10 rounded-full flex items-center justify-center transition" :class="recording ? 'bg-red-500 text-white animate-pulse' : 'text-gray-400 hover:bg-gray-100'">
                <i class="fa-solid fa-microphone"></i>
            </button>
        </footer>

        <!-- Call Overlay -->
        <div v-if="callState.active || callState.incoming" class="absolute inset-0 z-50 bg-black/90 flex flex-col items-center justify-center text-white">
            <div class="w-24 h-24 rounded-full overflow-hidden mb-4 border-4 border-white/20 animate-pulse">
                <img :src="partner.avatar || defaultAvatar" class="w-full h-full object-cover">
            </div>
            <h2 class="text-2xl font-bold mb-2">{{ partner.name }}</h2>
            <p class="mb-8 opacity-70">{{ callState.incoming ? 'Входящий звонок...' : 'Разговор...' }}</p>
            <div class="flex gap-8">
                <button v-if="callState.incoming" @click="answerCall" class="w-16 h-16 rounded-full bg-green-500 flex items-center justify-center text-2xl"><i class="fa-solid fa-phone"></i></button>
                <button @click="endCall" class="w-16 h-16 rounded-full bg-red-500 flex items-center justify-center text-2xl"><i class="fa-solid fa-phone-slash"></i></button>
            </div>
        </div>
    </main>

    <!-- Zoom Image -->
    <div v-if="zoomImg" @click="zoomImg = null" class="fixed inset-0 z-[100] bg-black/95 flex items-center justify-center p-2">
        <img :src="zoomImg" class="max-w-full max-h-full rounded">
    </div>

</div>

<script>
const { createApp, reactive, ref, onMounted, nextTick, watch } = Vue;

createApp({
    setup() {
        // STATE
        const logs = ref([]);
        const log = (msg, type='info') => {
            console.log(`[${type.toUpperCase()}] ${msg}`);
            logs.value.unshift({ time: new Date().toLocaleTimeString(), msg, type });
        };

        const user = reactive({ name: '', avatar: '', setupComplete: false });
        const partner = reactive({ name: '', avatar: '' });
        const messages = ref([]);
        const text = ref('');
        const peerId = ref('');
        const targetId = ref('');
        const mobileView = ref('sidebar');
        const theme = ref('light');
        const connecting = ref(false);
        const connError = ref('');
        
        const ui = reactive({ showDebug: false, showAttach: false });
        const callState = reactive({ active: false, incoming: false, stream: null, callObj: null });
        const recording = ref(false);
        
        // Temp vars
        const tempName = ref('');
        const tempAvatar = ref('');
        const defaultAvatar = 'https://cdn-icons-png.flaticon.com/512/149/149071.png';
        const zoomImg = ref(null);

        // Core Objects
        let peer = null;
        let connection = null;
        let mediaRecorder = null;
        let audioChunks = [];

        // --- INITIALIZATION ---
        onMounted(() => {
            // Load LocalStorage
            const u = localStorage.getItem('tw_user');
            if(u) {
                Object.assign(user, JSON.parse(u));
                initPeer();
            }
            const t = localStorage.getItem('tw_theme');
            if(t) setTheme(t);
            const m = localStorage.getItem('tw_msgs');
            if(m) messages.value = JSON.parse(m);
        });

        watch(messages, (val) => localStorage.setItem('tw_msgs', JSON.stringify(val)), { deep: true });

        // --- PEER JS LOGIC (ROBUST) ---
        const initPeer = () => {
            log("Initializing PeerJS...");
            // Use public Google STUN servers for better NAT traversal
            const config = {
                debug: 1,
                config: {
                    iceServers: [
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ]
                }
            };

            // Create new Peer (Random ID to avoid collisions)
            peer = new Peer(null, config);

            peer.on('open', (id) => {
                log(`My ID generated: ${id}`);
                peerId.value = id;
            });

            peer.on('connection', (conn) => {
                log(`Incoming connection from: ${conn.peer}`);
                handleConn(conn);
            });

            peer.on('call', (call) => {
                log("Incoming Call...");
                callState.incoming = true;
                callState.callObj = call;
            });

            peer.on('error', (err) => {
                log(`Peer Error: ${err.type}`, 'error');
                if(err.type === 'peer-unavailable') connError.value = "Пользователь не найден (он оффлайн или неверный ID)";
                if(err.type === 'network') connError.value = "Проблема с сетью/интернетом";
                connecting.value = false;
            });

            peer.on('disconnected', () => {
                log("Disconnected from Signaling Server. Reconnecting...", 'warn');
                peer.reconnect();
            });
        };

        const connect = () => {
            if(!targetId.value) return;
            connError.value = '';
            connecting.value = true;
            log(`Attempting to connect to ${targetId.value.trim()}...`);
            
            const conn = peer.connect(targetId.value.trim(), {
                reliable: true,
                serialization: 'json' // More stable for simple data
            });

            handleConn(conn);
        };

        const handleConn = (conn) => {
            connection = conn;
            
            conn.on('open', () => {
                log("Connection ESTABLISHED!", 'success');
                connecting.value = false;
                connError.value = '';
                mobileView.value = 'chat';
                
                // Send my info
                conn.send({ type: 'info', payload: { name: user.name, avatar: user.avatar } });
            });

            conn.on('data', (data) => {
                if(data.type === 'info') {
                    partner.name = data.payload.name;
                    partner.avatar = data.payload.avatar;
                } else {
                    messages.value.push({ ...data, sender: 'partner' });
                    scrollToBottom();
                }
            });

            conn.on('close', () => {
                log("Connection Closed", 'warn');
                connection = null;
            });

            conn.on('error', (err) => {
                log(`Connection Error: ${err}`, 'error');
                connError.value = "Ошибка соединения";
                connecting.value = false;
            });
        };

        // --- MESSAGING ---
        const sendText = () => {
            if(!text.value.trim() || !connection) return;
            const msg = { type: 'text', content: text.value, timestamp: Date.now() };
            connection.send(msg);
            messages.value.push({ ...msg, sender: 'me' });
            text.value = '';
            scrollToBottom();
        };

        const sendImage = (e) => {
            const file = e.target.files[0];
            if(!file || !connection) return;
            const reader = new FileReader();
            reader.onload = (evt) => {
                const msg = { type: 'image', content: evt.target.result, timestamp: Date.now() };
                connection.send(msg);
                messages.value.push({ ...msg, sender: 'me' });
                scrollToBottom();
            };
            reader.readAsDataURL(file);
        };

        // --- CALLS ---
        const callUser = async () => {
            if(!connection) return;
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                callState.stream = stream;
                const call = peer.call(connection.peer, stream);
                callState.callObj = call;
                callState.active = true;
                
                call.on('stream', (remoteStream) => playStream(remoteStream));
                call.on('close', endCall);
            } catch(e) { log("Mic Error: " + e, 'error'); alert("Нужен доступ к микрофону!"); }
        };

        const answerCall = async () => {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                callState.stream = stream;
                callState.callObj.answer(stream);
                callState.incoming = false;
                callState.active = true;
                
                callState.callObj.on('stream', (remoteStream) => playStream(remoteStream));
                callState.callObj.on('close', endCall);
            } catch(e) { log("Mic Error: " + e, 'error'); }
        };

        const endCall = () => {
            if(callState.callObj) callState.callObj.close();
            if(callState.stream) callState.stream.getTracks().forEach(t => t.stop());
            callState.active = false;
            callState.incoming = false;
        };

        const playStream = (stream) => {
            const audio = new Audio();
            audio.srcObject = stream;
            audio.play();
        };

        // --- VOICE MSG ---
        const startRec = async () => {
            if(!connection) return;
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                recording.value = true;
                mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                mediaRecorder.onstop = () => {
                    const blob = new Blob(audioChunks);
                    const reader = new FileReader();
                    reader.readAsDataURL(blob);
                    reader.onloadend = () => {
                        const msg = { type: 'voice', content: reader.result, timestamp: Date.now() };
                        connection.send(msg);
                        messages.value.push({ ...msg, sender: 'me' });
                        scrollToBottom();
                    };
                    stream.getTracks().forEach(t => t.stop());
                };
                mediaRecorder.start();
            } catch(e) { alert("Mic required"); }
        };

        const stopRec = () => {
            if(mediaRecorder && recording.value) {
                mediaRecorder.stop();
                recording.value = false;
            }
        };

        const playAudio = (b64) => new Audio(b64).play();

        // --- UTILS ---
        const finishSetup = () => {
            user.name = tempName.value;
            user.avatar = tempAvatar.value;
            user.setupComplete = true;
            localStorage.setItem('tw_user', JSON.stringify(user));
            initPeer();
        };
        const handleAvatar = (e) => {
            const r = new FileReader();
            r.onload = (ev) => tempAvatar.value = ev.target.result;
            if(e.target.files[0]) r.readAsDataURL(e.target.files[0]);
        };
        const copyId = () => navigator.clipboard.writeText(peerId.value);
        const scrollToBottom = () => nextTick(() => { 
            const el = document.querySelector('main > div.overflow-y-auto');
            if(el) el.scrollTop = el.scrollHeight; 
        });
        const formatTime = (ts) => new Date(ts).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
        const toggleTheme = () => setTheme(theme.value === 'dark' ? 'light' : 'dark');
        const setTheme = (t) => {
            theme.value = t;
            localStorage.setItem('tw_theme', t);
            if(t==='dark') document.documentElement.classList.add('dark');
            else document.documentElement.classList.remove('dark');
        };
        const openZoom = (src) => zoomImg.value = src;
        const statusText = Vue.computed(() => {
            if(!peerId.value) return 'Connecting to server...';
            return 'Server OK';
        });

        return {
            user, partner, messages, text, peerId, targetId, mobileView, theme, 
            logs, ui, connecting, connError, callState, recording, zoomImg,
            tempName, tempAvatar, defaultAvatar, statusText,
            finishSetup, handleAvatar, copyId, connect, sendText, sendImage,
            startRec, stopRec, playAudio, callUser, answerCall, endCall,
            formatTime, toggleTheme, openZoom
        };
    }
}).mount('#app');
</script>
</body>
</html>
