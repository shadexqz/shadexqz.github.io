<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Дурак Онлайн (P2P)</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg-color: #2d5e40; /* Классическое зеленое сукно */
            --card-width: 80px;
            --card-height: 112px;
            --radius: 8px;
            --shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        * { box-sizing: border-box; user-select: none; }
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at center, #35654d 0%, #1e3c29 100%);
            color: white;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* --- UI Лобби --- */
        #lobby {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .panel {
            background: white;
            color: #333;
            padding: 2rem;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            max-width: 400px;
            width: 90%;
        }
        button {
            background: #d32f2f;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: 0.2s;
            margin: 5px;
            font-weight: bold;
        }
        button:hover { background: #b71c1c; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        input {
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
            width: 100%;
            margin-bottom: 10px;
            font-size: 16px;
        }

        /* --- Игровое поле --- */
        #game-board {
            flex: 1;
            display: none; /* Скрыто до начала игры */
            flex-direction: column;
            position: relative;
        }

        /* Зоны */
        .opponent-area { height: 120px; display: flex; justify-content: center; align-items: center; position: relative; }
        .table-area { flex: 1; position: relative; display: flex; justify-content: center; align-items: center; }
        .player-area { height: 160px; display: flex; justify-content: center; align-items: flex-end; padding-bottom: 20px; position: relative; }

        /* Колода и Козырь */
        .deck-area {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
        }
        .trump-card {
            position: absolute;
            left: 20px;
            transform: rotate(90deg) translateX(-20px);
            z-index: 0;
        }
        .deck-stack {
            position: relative;
            z-index: 1;
            background: #fff;
            border: 2px solid #fff;
            background-image: repeating-linear-gradient(45deg, #b71c1c 0, #b71c1c 10px, #d32f2f 10px, #d32f2f 20px);
        }
        .deck-count {
            position: absolute;
            top: -25px;
            left: 10px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }

        /* Карты */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            background: white;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            position: relative;
            margin: 0 5px;
            color: black;
            font-weight: bold;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px;
            cursor: pointer;
            transition: transform 0.2s, margin 0.2s;
        }
        .card:hover { transform: translateY(-10px); }
        .card.selected { border: 2px solid #ffeb3b; transform: translateY(-15px); }
        
        .card.red { color: #d32f2f; }
        .card.black { color: #212121; }

        .card-top { font-size: 18px; line-height: 1; display: flex; flex-direction: column; align-items: center; width: 20px;}
        .card-center { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 40px; }
        .card-bottom { transform: rotate(180deg); font-size: 18px; line-height: 1; display: flex; flex-direction: column; align-items: center; width: 20px; align-self: flex-end;}

        .card-back {
            background: #fff;
            background-image: repeating-linear-gradient(45deg, #1565c0 0, #1565c0 10px, #0d47a1 10px, #0d47a1 20px);
            border: 2px solid white;
        }
        .card-back * { display: none; }

        /* Стол (карты в игре) */
        .field-slot {
            margin: 0 10px;
            position: relative;
            width: var(--card-width);
            height: var(--card-height);
        }
        .field-card { position: absolute; top: 0; left: 0; transition: all 0.3s; }
        .field-card:nth-child(2) { top: 20px; left: 15px; transform: rotate(10deg); z-index: 2; }

        /* Статус бар и кнопки */
        .game-ui {
            position: absolute;
            right: 20px;
            bottom: 180px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }
        .status-badge {
            background: rgba(0,0,0,0.6);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 18px;
            margin-bottom: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        .action-btn {
            background: #ffb300;
            color: #000;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 18px;
            box-shadow: 0 5px 15px rgba(255,179,0,0.4);
            display: none;
        }
        .action-btn.active { display: block; }

        /* --- ЧАТ --- */
        #chat-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 300px;
            height: 200px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: opacity 0.3s;
            opacity: 0; /* Скрыт пока не в игре */
            pointer-events: none;
        }
        #chat-container.visible { opacity: 1; pointer-events: all; }
        
        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 14px;
            text-shadow: 1px 1px 1px black;
        }
        .msg { margin-bottom: 4px; }
        .msg.me { color: #81c784; }
        .msg.opp { color: #e57373; }
        .msg.sys { color: #ffd54f; font-style: italic; }

        #chat-input-area {
            display: flex;
            padding: 5px;
            background: rgba(0,0,0,0.3);
        }
        #chat-input {
            flex: 1;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 5px;
            border-radius: 4px;
        }
        #chat-send {
            background: transparent;
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            padding: 0 10px;
        }

        /* Адаптив для мобилок */
        @media (max-width: 600px) {
            :root { --card-width: 60px; --card-height: 84px; }
            .trump-card { transform: rotate(90deg) translateX(-10px); left: 10px;}
            .game-ui { bottom: 150px; right: 10px; }
            #chat-container { width: 200px; height: 150px; top: 5px; right: 5px; font-size: 12px; }
            .opponent-area { height: 90px; }
            .player-area { height: 130px; }
        }
    </style>
</head>
<body>

    <!-- ЛОББИ -->
    <div id="lobby">
        <div class="panel">
            <h1>Дурак Онлайн</h1>
            <p>P2P Карточная игра</p>
            <hr style="opacity:0.2">
            
            <div id="host-controls">
                <button onclick="GameApp.hostGame()">Создать игру</button>
                <div id="invite-area" style="display:none; margin-top:15px;">
                    <p>Ожидание соперника...</p>
                    <input type="text" id="invite-link" readonly>
                    <button onclick="GameApp.copyLink()" style="background:#388e3c; font-size:14px;">Копировать ссылку</button>
                </div>
            </div>

            <hr style="opacity:0.2; margin: 20px 0;">

            <div id="join-controls">
                <input type="text" id="game-id-input" placeholder="Вставьте ID игры">
                <button onclick="GameApp.joinGame()">Присоединиться</button>
            </div>
            
            <p id="lobby-status" style="color:#e57373; font-size: 14px; min-height: 20px;"></p>
        </div>
    </div>

    <!-- ИГРА -->
    <div id="game-board">
        <!-- Чат -->
        <div id="chat-container">
            <div id="chat-messages"></div>
            <div id="chat-input-area">
                <input type="text" id="chat-input" placeholder="Чат..." onkeypress="if(event.key==='Enter') GameApp.sendChat()">
                <button id="chat-send" onclick="GameApp.sendChat()">➤</button>
            </div>
        </div>

        <div class="opponent-area" id="opponent-hand">
            <!-- Карты соперника (рубашки) -->
        </div>

        <div class="table-area">
            <div class="deck-area">
                <div id="trump-slot" class="trump-card"></div>
                <div id="deck-slot" class="deck-stack card card-back"></div>
                <div id="deck-counter" class="deck-count">36</div>
            </div>
            <div id="field" style="display: flex; justify-content: center;">
                <!-- Пары карт на столе -->
            </div>
        </div>

        <div class="game-ui">
            <div id="game-status" class="status-badge">Ожидание...</div>
            <button id="action-btn" class="action-btn" onclick="GameApp.performAction()">Действие</button>
        </div>

        <div class="player-area" id="my-hand">
            <!-- Мои карты -->
        </div>
    </div>

    <script>
        // --- КОНСТАНТЫ И УТИЛИТЫ ---
        const SUITS = ['♠', '♣', '♥', '♦'];
        const RANKS = ['6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        // Русская локализация карт
        const RANK_DISPLAY = {'6':'6', '7':'7', '8':'8', '9':'9', '10':'10', 'J':'В', 'Q':'Д', 'K':'К', 'A':'Т'};
        
        function getCardColor(suit) {
            return (suit === '♥' || suit === '♦') ? 'red' : 'black';
        }

        // --- ЛОГИКА ИГРЫ (Game Engine) ---
        class DurakEngine {
            constructor() {
                this.deck = [];
                this.trumpCard = null;
                this.trumpSuit = null;
                this.hands = { host: [], client: [] };
                this.field = []; // Array of {attack: Card, defend: Card|null}
                this.attacker = 'host'; // 'host' or 'client'
                this.gameState = 'LOBBY'; // LOBBY, PLAYING, ENDED
                this.winner = null;
            }

            initGame() {
                this.deck = [];
                SUITS.forEach(s => RANKS.forEach(r => this.deck.push({ rank: r, suit: s })));
                this.shuffleDeck();
                
                // Раздача
                this.hands.host = this.drawCards(6);
                this.hands.client = this.drawCards(6);
                
                // Козырь
                this.trumpCard = this.deck.shift(); // Последняя карта - козырь, лежит внизу
                this.trumpSuit = this.trumpCard.suit;
                this.deck.push(this.trumpCard); // Кладем её "под низ" (в массиве она последняя, визуально обработаем)

                // Определение первого хода (у кого младший козырь)
                this.attacker = this.findFirstAttacker();
                this.gameState = 'PLAYING';
            }

            shuffleDeck() {
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }

            drawCards(count) {
                const drawn = [];
                // Берем карты с "верха" (начала массива), но козырь в конце массива
                // В реализации массива: 0 - верх, length-1 - низ (козырь)
                // Чтобы было удобно, будем брать с 0. Козырь (последний элемент) берем последним.
                while(drawn.length < count && this.deck.length > 0) {
                    drawn.push(this.deck.shift());
                }
                return drawn;
            }

            findFirstAttacker() {
                let minTrumpHost = 100;
                let minTrumpClient = 100;
                const getVal = (c) => RANKS.indexOf(c.rank);

                this.hands.host.forEach(c => { if(c.suit === this.trumpSuit) minTrumpHost = Math.min(minTrumpHost, getVal(c)); });
                this.hands.client.forEach(c => { if(c.suit === this.trumpSuit) minTrumpClient = Math.min(minTrumpClient, getVal(c)); });

                if (minTrumpHost < minTrumpClient) return 'host';
                if (minTrumpClient < minTrumpHost) return 'client';
                return 'host'; // Default
            }

            getRankVal(rank) { return RANKS.indexOf(rank); }

            // Проверка возможности защиты
            canBeat(attackCard, defendCard) {
                if (defendCard.suit === attackCard.suit) {
                    return this.getRankVal(defendCard.rank) > this.getRankVal(attackCard.rank);
                }
                return defendCard.suit === this.trumpSuit;
            }

            // --- ДЕЙСТВИЯ ---
            
            // Атака
            playAttack(player, cardIdx) {
                if (player !== this.attacker) return false;
                const card = this.hands[player][cardIdx];

                // Если поле пустое - любая карта
                // Если не пустое - ранг должен совпадать с картами на столе
                if (this.field.length > 0) {
                    const ranksOnTable = new Set();
                    this.field.forEach(slot => {
                        ranksOnTable.add(slot.attack.rank);
                        if(slot.defend) ranksOnTable.add(slot.defend.rank);
                    });
                    if (!ranksOnTable.has(card.rank)) return false;
                }
                
                // Лимит карт на столе (6 или кол-во карт у защищающегося)
                const defender = player === 'host' ? 'client' : 'host';
                const unbeatCards = this.field.filter(f => !f.defend).length;
                if (unbeatCards >= this.hands[defender].length && this.field.length > 0) return false; // Нельзя подкинуть больше чем есть карт
                if (this.field.length >= 6) return false;

                // Move card
                this.hands[player].splice(cardIdx, 1);
                this.field.push({ attack: card, defend: null });
                return true;
            }

            // Защита
            playDefend(player, cardIdx, slotIdx) {
                if (player === this.attacker) return false;
                if (!this.field[slotIdx] || this.field[slotIdx].defend) return false; // Слот занят или не существует

                const attackCard = this.field[slotIdx].attack;
                const defCard = this.hands[player][cardIdx];

                if (this.canBeat(attackCard, defCard)) {
                    this.hands[player].splice(cardIdx, 1);
                    this.field[slotIdx].defend = defCard;
                    return true;
                }
                return false;
            }

            // Бито (Завершение хода)
            actionBito(player) {
                if (player !== this.attacker) return false;
                // Все карты должны быть побиты
                const allBeaten = this.field.every(slot => slot.defend !== null);
                if (!allBeaten || this.field.length === 0) return false;

                // Очистка стола, добор карт, смена ролей
                this.field = [];
                this.refillHands();
                this.attacker = (this.attacker === 'host') ? 'client' : 'host';
                this.checkWin();
                return true;
            }

            // Взять (Сдаться)
            actionTake(player) {
                if (player === this.attacker) return false;
                
                // Забирает все карты со стола
                this.field.forEach(slot => {
                    this.hands[player].push(slot.attack);
                    if(slot.defend) this.hands[player].push(slot.defend);
                });
                this.field = [];
                this.refillHands(); // Атакующий добирает
                // Атакующий снова ходит (тот же), так как защищающийся взял
                this.checkWin();
                return true;
            }

            refillHands() {
                // Сначала атакующий, потом защищающийся
                const defender = (this.attacker === 'host') ? 'client' : 'host';
                
                while(this.hands[this.attacker].length < 6 && this.deck.length > 0) {
                    this.hands[this.attacker].push(this.deck.shift());
                }
                while(this.hands[defender].length < 6 && this.deck.length > 0) {
                    this.hands[defender].push(this.deck.shift());
                }
            }

            checkWin() {
                if (this.deck.length === 0) {
                    if (this.hands.host.length === 0) this.winner = 'host';
                    else if (this.hands.client.length === 0) this.winner = 'client';
                }
            }
            
            getState() {
                return {
                    deckCount: this.deck.length,
                    trumpCard: this.trumpCard,
                    trumpSuit: this.trumpSuit,
                    hands: { 
                        host: this.hands.host.length, // Client only needs count
                        client: this.hands.client.length 
                    }, 
                    myHand: null, // Populated before sending
                    field: this.field,
                    attacker: this.attacker,
                    winner: this.winner
                };
            }
        }

        // --- NETWORK & APP CONTROLLER ---
        class GameApp {
            static peer = null;
            static conn = null;
            static isHost = false;
            static engine = null;
            static myRole = null; // 'host' or 'client'
            static myId = null;

            static init() {
                // Check URL params for auto-join
                const urlParams = new URLSearchParams(window.location.search);
                const gameId = urlParams.get('game');
                if (gameId) {
                    document.getElementById('game-id-input').value = gameId;
                    // Optional: auto click join
                }
            }

            // --- HOST LOGIC ---
            static hostGame() {
                this.isHost = true;
                this.myRole = 'host';
                this.engine = new DurakEngine();
                
                this.peer = new Peer();
                
                this.peer.on('open', (id) => {
                    this.myId = id;
                    document.getElementById('invite-area').style.display = 'block';
                    const link = `${window.location.origin}${window.location.pathname}?game=${id}`;
                    document.getElementById('invite-link').value = link;
                    this.logStatus("Ожидание подключения соперника...");
                    
                    document.getElementById('host-controls').querySelector('button').disabled = true;
                    document.getElementById('join-controls').style.display = 'none';
                });

                this.peer.on('connection', (conn) => {
                    this.conn = conn;
                    this.setupConnection();
                    this.logStatus("Соперник подключился! Начинаем...");
                    
                    // Start Game
                    this.engine.initGame();
                    this.syncState();
                    this.showGameBoard();
                });
            }

            // --- CLIENT LOGIC ---
            static joinGame() {
                const gameId = document.getElementById('game-id-input').value.trim();
                if (!gameId) return alert("Введите ID игры");

                this.isHost = false;
                this.myRole = 'client';
                this.peer = new Peer();

                this.peer.on('open', (id) => {
                    this.conn = this.peer.connect(gameId);
                    this.setupConnection();
                });

                this.peer.on('error', (err) => {
                    this.logStatus("Ошибка соединения: " + err.type);
                });
            }

            // --- SHARED NETWORK LOGIC ---
            static setupConnection() {
                this.conn.on('open', () => {
                    console.log("Connected");
                });

                this.conn.on('data', (data) => {
                    if (data.type === 'STATE') {
                        UI.render(data.state, this.myRole);
                    } else if (data.type === 'ACTION') {
                        if (this.isHost) this.handleAction(data);
                    } else if (data.type === 'CHAT') {
                        UI.addChatMessage(data.sender, data.msg);
                    }
                });
                
                this.conn.on('close', () => {
                    alert("Соединение разорвано");
                    location.reload();
                });
            }

            // Only Host runs this
            static handleAction(data) {
                let success = false;
                const p = data.player;
                
                if (data.action === 'ATTACK') {
                    success = this.engine.playAttack(p, data.cardIdx);
                } else if (data.action === 'DEFEND') {
                    success = this.engine.playDefend(p, data.cardIdx, data.slotIdx);
                } else if (data.action === 'TAKE') {
                    success = this.engine.actionTake(p);
                } else if (data.action === 'BITO') {
                    success = this.engine.actionBito(p);
                }

                if (success) this.syncState();
                // If invalid move, state isn't updated, client syncs back to old state eventually or stays same
            }

            static syncState() {
                if (!this.isHost) return;
                
                // Prepare state for Host
                const fullState = this.engine.getState();
                
                // Update Host UI directly
                fullState.myHand = this.engine.hands.host;
                UI.render(fullState, 'host');

                // Send to Client (masking host hand)
                const clientState = JSON.parse(JSON.stringify(fullState));
                clientState.myHand = this.engine.hands.client; 
                // swap hand counts for client perspective logic if needed, but UI handles it by role
                this.conn.send({ type: 'STATE', state: clientState });
            }

            // --- UI ACTIONS -> NETWORK ---
            static sendAction(actionType, payload = {}) {
                if (this.isHost) {
                    this.handleAction({ player: 'host', action: actionType, ...payload });
                } else {
                    this.conn.send({ type: 'ACTION', player: 'client', action: actionType, ...payload });
                }
            }
            
            static sendChat() {
                const input = document.getElementById('chat-input');
                const msg = input.value.trim();
                if (!msg) return;
                
                input.value = '';
                // Show my own message
                UI.addChatMessage('Me', msg);
                
                // Send to peer
                const payload = { type: 'CHAT', msg: msg, sender: 'Opponent' };
                if (this.conn) this.conn.send(payload);
            }

            // --- UI HELPERS ---
            static copyLink() {
                const copyText = document.getElementById("invite-link");
                copyText.select();
                document.execCommand("copy");
                alert("Ссылка скопирована!");
            }
            
            static logStatus(msg) {
                document.getElementById('lobby-status').innerText = msg;
            }

            static showGameBoard() {
                document.getElementById('lobby').style.display = 'none';
                document.getElementById('game-board').style.display = 'flex';
                document.getElementById('chat-container').classList.add('visible');
            }
            
            // Кнопка действия (Бито/Взять)
            static performAction() {
                const btn = document.getElementById('action-btn');
                if (btn.innerText === "Бито") this.sendAction('BITO');
                else if (btn.innerText === "Взять") this.sendAction('TAKE');
            }
        }

        // --- RENDERER ---
        class UI {
            static selectedAttackCardIdx = null;

            static render(state, myRole) {
                if (state.winner) {
                    alert(state.winner === myRole ? "Победа! Ты красавчик!" : "Ты проиграл! Ну ты и Дурак...");
                    location.reload();
                    return;
                }

                // 1. Deck & Trump
                const trumpHtml = this.createCardHTML(state.trumpCard, false);
                document.getElementById('trump-slot').innerHTML = state.deckCount > 0 ? trumpHtml : '';
                document.getElementById('trump-slot').style.opacity = state.deckCount > 0 ? 1 : 0.5; // Fade if empty
                document.getElementById('deck-counter').innerText = state.deckCount;
                document.getElementById('deck-slot').style.visibility = state.deckCount > 1 ? 'visible' : 'hidden'; // Hide deck back if only trump left

                // 2. Opponent Hand
                const oppHandCount = (myRole === 'host') ? state.hands.client : state.hands.host;
                const oppContainer = document.getElementById('opponent-hand');
                oppContainer.innerHTML = '';
                for(let i=0; i<oppHandCount; i++) {
                    const card = document.createElement('div');
                    card.className = 'card card-back';
                    // Смещение карт веером
                    card.style.position = 'absolute';
                    card.style.marginLeft = (i * 30 - (oppHandCount*15)) + 'px';
                    oppContainer.appendChild(card);
                }

                // 3. Field
                const fieldContainer = document.getElementById('field');
                fieldContainer.innerHTML = '';
                state.field.forEach((slot, slotIdx) => {
                    const slotDiv = document.createElement('div');
                    slotDiv.className = 'field-slot';
                    
                    const attDiv = document.createElement('div');
                    attDiv.className = 'card field-card ' + getCardColor(slot.attack.suit);
                    attDiv.innerHTML = this.getCardInner(slot.attack);
                    slotDiv.appendChild(attDiv);

                    if (slot.defend) {
                        const defDiv = document.createElement('div');
                        defDiv.className = 'card field-card ' + getCardColor(slot.defend.suit);
                        defDiv.innerHTML = this.getCardInner(slot.defend);
                        slotDiv.appendChild(defDiv);
                    } else {
                        // Drop zone functionality for defense
                        if (myRole !== state.attacker) {
                            slotDiv.onclick = () => this.onFieldClick(slotIdx);
                        }
                    }
                    fieldContainer.appendChild(slotDiv);
                });

                // 4. My Hand
                const myContainer = document.getElementById('my-hand');
                myContainer.innerHTML = '';
                state.myHand.forEach((card, idx) => {
                    const cardDiv = document.createElement('div');
                    cardDiv.className = 'card ' + getCardColor(card.suit);
                    if (this.selectedAttackCardIdx === idx) cardDiv.classList.add('selected');
                    cardDiv.innerHTML = this.getCardInner(card);
                    cardDiv.onclick = () => this.onHandClick(idx, myRole, state);
                    myContainer.appendChild(cardDiv);
                });

                // 5. Status & Buttons
                const statusEl = document.getElementById('game-status');
                const btn = document.getElementById('action-btn');
                
                const isMyTurn = (myRole === state.attacker);
                const isDefending = !isMyTurn;

                if (isMyTurn) {
                    statusEl.innerText = "Ваш ход (Атака)";
                    statusEl.style.color = "#81c784";
                    // Кнопка "Бито" появляется, если есть карты на столе и все побиты (или ничего не побито - нельзя, но логика сервера проверит)
                    // Упрощение: Кнопка Бито если поле не пустое и все слоты закрыты (или хост решит)
                    // Реально: Бито доступно если все карты на столе побиты.
                    const allBeaten = state.field.length > 0 && state.field.every(s => s.defend);
                    
                    if (allBeaten) {
                        btn.innerText = "Бито";
                        btn.classList.add('active');
                        btn.style.background = "#d32f2f";
                        btn.style.color = "white";
                    } else {
                        btn.classList.remove('active');
                    }
                } else {
                    statusEl.innerText = "Защищайтесь!";
                    statusEl.style.color = "#e57373";
                    // Кнопка "Взять" если нас атакуют
                    if (state.field.some(s => !s.defend)) {
                        btn.innerText = "Взять";
                        btn.classList.add('active');
                        btn.style.background = "#ffb300";
                        btn.style.color = "black";
                    } else {
                         btn.classList.remove('active');
                    }
                }
            }

            static onHandClick(idx, myRole, state) {
                // Если я атакующий - клик сразу играет карту (если валидно)
                // Если я защищающийся - клик выбирает карту, потом клик по столу играет её
                
                if (myRole === state.attacker) {
                    GameApp.sendAction('ATTACK', { cardIdx: idx });
                } else {
                    // Защита: выделяем карту
                    if (this.selectedAttackCardIdx === idx) this.selectedAttackCardIdx = null;
                    else this.selectedAttackCardIdx = idx;
                    
                    // Перерисовка чтобы показать выделение (локально)
                    this.render(state, myRole);
                }
            }

            static onFieldClick(slotIdx) {
                if (this.selectedAttackCardIdx !== null) {
                    GameApp.sendAction('DEFEND', { cardIdx: this.selectedAttackCardIdx, slotIdx: slotIdx });
                    this.selectedAttackCardIdx = null;
                }
            }

            static createCardHTML(card, isBack) {
                if (!card) return '';
                if (isBack) return '<div class="card card-back"></div>';
                const color = getCardColor(card.suit);
                return `<div class="card ${color}">${this.getCardInner(card)}</div>`;
            }

            static getCardInner(card) {
                const r = RANK_DISPLAY[card.rank];
                return `
                    <div class="card-top"><span>${r}</span><span>${card.suit}</span></div>
                    <div class="card-center">${card.suit}</div>
                    <div class="card-bottom"><span>${r}</span><span>${card.suit}</span></div>
                `;
            }

            static addChatMessage(sender, text) {
                const box = document.getElementById('chat-messages');
                const div = document.createElement('div');
                div.className = 'msg ' + (sender === 'Me' ? 'me' : (sender==='System'?'sys':'opp'));
                div.innerHTML = `<b>${sender === 'Opponent' ? 'Соперник' : (sender === 'Me' ? 'Я' : '')}:</b> ${text}`;
                box.appendChild(div);
                box.scrollTop = box.scrollHeight;
            }
        }

        GameApp.init();

    </script>
</body>
</html>
